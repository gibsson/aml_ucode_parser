commit 8cc0774459707e366bd8089f03b2be2c6f394af6
Author: Chuangcheng Peng <chuangcheng.peng@amlogic.com>
Date:   Mon Mar 25 10:04:43 2019 +0800

    dvb: bringup for sm1 [1/2]
    
    PD#SWPL-6244
    
    Problem:
    sm1 add dsc sm4/isda,demux cascade
    
    Solution:
    change code for sm4/isda,dmx cascade
    
    Verify:
    verify at sm1
    
    Change-Id: Ia89c408d90b24e7c52512efefb7a3a3e93b70f89
    Signed-off-by: Chuangcheng Peng <chuangcheng.peng@amlogic.com>

diff --git a/drivers/stream_input/parser/hw_demux/aml_dmx.c b/drivers/stream_input/parser/hw_demux/aml_dmx.c
index c93542a..724bc0c 100644
--- a/drivers/stream_input/parser/hw_demux/aml_dmx.c
+++ b/drivers/stream_input/parser/hw_demux/aml_dmx.c
@@ -226,7 +226,6 @@ dmx_write_reg(int r, u32 v)
 			return;
 		}
 	}
-
 	WRITE_MPEG_REG(r, v);
 }
 
@@ -309,10 +308,8 @@ static inline int _set(int v, int b) { return b; }
 
 static int dsc_set_csa_key(struct aml_dsc_channel *ch, int flags,
 			enum ca_cw_type type, u8 *key);
-static int dsc_set_aes_des_key(struct aml_dsc_channel *ch, int flags,
+static int dsc_set_aes_des_sm4_key(struct aml_dsc_channel *ch, int flags,
 			enum ca_cw_type type, u8 *key);
-
-
 static void aml_ci_plus_disable(void);
 static void am_ci_plus_set_output(struct aml_dsc_channel *ch);
 
@@ -1586,6 +1583,10 @@ static void stb_enable(struct aml_dvb *dvb)
 		fec_clk = tsfile_clkdiv;
 		hiu = 1;
 		break;
+	case AM_TS_SRC_HIU1:
+		fec_clk = tsfile_clkdiv;
+		hiu = 1;
+		break;
 	default:
 		fec_clk = 0;
 		hiu = 0;
@@ -1709,13 +1710,21 @@ static void stb_enable(struct aml_dvb *dvb)
 		data |= 1 << TS_OUT_CLK_INVERT;
 		WRITE_MPEG_REG(TS_TOP_CONFIG, data);
 	}
-	/* invert ts out clk  end */
-	WRITE_MPEG_REG(TS_FILE_CONFIG,
-		       (demux_skipbyte << 16) |
-		       (6 << DES_OUT_DLY) |
-		       (3 << TRANSPORT_SCRAMBLING_CONTROL_ODD) |
-		       (3 << TRANSPORT_SCRAMBLING_CONTROL_ODD_2) |
-		       (hiu << TS_HIU_ENABLE) | (fec_clk << FEC_FILE_CLK_DIV));
+
+	if (src == AM_TS_SRC_HIU1) {
+		WRITE_MPEG_REG(TS_HIU1_CONFIG,
+			       (demux_skipbyte << FILE_M2TS_SKIP_BYTES_HIU1) |
+			       (hiu << TS_HIU_ENABLE_HIU1) |
+			       (fec_clk << FEC_CLK_DIV_HIU1));
+	} else {
+		/* invert ts out clk  end */
+		WRITE_MPEG_REG(TS_FILE_CONFIG,
+			       (demux_skipbyte << 16) |
+			       (6 << DES_OUT_DLY) |
+			       (3 << TRANSPORT_SCRAMBLING_CONTROL_ODD) |
+			       (3 << TRANSPORT_SCRAMBLING_CONTROL_ODD_2) |
+			       (hiu << TS_HIU_ENABLE) | (fec_clk << FEC_FILE_CLK_DIV));
+	}
 }
 
 int dsc_set_pid(struct aml_dsc_channel *ch, int pid)
@@ -1771,7 +1780,7 @@ int dsc_set_key(struct aml_dsc_channel *ch, int flags, enum ca_cw_type type,
 			else
 				pr_inf("dsc[%d:%d] enable (from ciplus)\n",
 					ch->dsc->id, ch->id);
-			ch->aes_mode = AES_ECB_MODE;
+			ch->mode = ECB_MODE;
 			ch->work_mode = DVBCSA_MODE;
 		}
 		break;
@@ -1781,8 +1790,12 @@ int dsc_set_key(struct aml_dsc_channel *ch, int flags, enum ca_cw_type type,
 	case CA_CW_AES_ODD_IV:
 	case CA_CW_DES_EVEN:
 	case CA_CW_DES_ODD:
+	case CA_CW_SM4_EVEN:
+	case CA_CW_SM4_ODD:
+	case CA_CW_SM4_EVEN_IV:
+	case CA_CW_SM4_ODD_IV:
 		am_ci_plus_set_output(ch);
-		ret = dsc_set_aes_des_key(ch, flags, type, key);
+		ret = dsc_set_aes_des_sm4_key(ch, flags, type, key);
 		if (ret != 0)
 			goto END;
 		/* Different with old mode, do change */
@@ -1818,17 +1831,21 @@ int dsc_set_keys(struct aml_dsc_channel *ch)
 			case CA_CW_DVB_CSA_EVEN:
 			case CA_CW_AES_EVEN:
 			case CA_CW_DES_EVEN:
+			case CA_CW_SM4_EVEN:
 				k = ch->even;
 				break;
 			case CA_CW_DVB_CSA_ODD:
 			case CA_CW_AES_ODD:
 			case CA_CW_DES_ODD:
+			case CA_CW_SM4_ODD:
 				k = ch->odd;
 				break;
 			case CA_CW_AES_EVEN_IV:
+			case CA_CW_SM4_EVEN_IV:
 				k = ch->even_iv;
 				break;
 			case CA_CW_AES_ODD_IV:
+			case CA_CW_SM4_ODD_IV:
 				k = ch->odd_iv;
 				break;
 			default:
@@ -1922,6 +1939,8 @@ static int dsc_set_csa_key(struct aml_dsc_channel *ch, int flags,
 #define KEY_WR_DES_B    1
 #define KEY_WR_DES_A    0
 
+#define IDSA_MODE_BIT	31
+#define SM4_MODE		30
 #define CNTL_ENABLE     3
 #define AES_CBC_DISABLE 2
 #define AES_EN          1
@@ -1934,6 +1953,9 @@ static int dsc_set_csa_key(struct aml_dsc_channel *ch, int flags,
 #define DES_MSG_IN_ENDIAN  4
 #define DES_KEY_ENDIAN  0
 
+#define ALGO_AES		0
+#define ALGO_SM4		1
+#define ALGO_DES		2
 
 #if 0
 static void aml_ci_plus_set_stb(void)
@@ -1980,14 +2002,16 @@ void aml_ci_plus_set_iv(struct aml_dsc_channel *ch, enum ca_cw_type type,
 	k1 = (key[8] << 24) | (key[9] << 16) | (key[10] << 8) | key[11];
 	k0 = (key[12] << 24) | (key[13] << 16) | (key[14] << 8) | key[15];
 
-	if (type == CA_CW_AES_EVEN_IV) {
+	if (type == CA_CW_AES_EVEN_IV ||
+		type == CA_CW_SM4_EVEN_IV) {
 		WRITE_MPEG_REG(CIPLUS_KEY0, k0);
 		WRITE_MPEG_REG(CIPLUS_KEY1, k1);
 		WRITE_MPEG_REG(CIPLUS_KEY2, k2);
 		WRITE_MPEG_REG(CIPLUS_KEY3, k3);
 		WRITE_MPEG_REG(CIPLUS_KEY_WR,
 			(ch->id << 9) | (1<<KEY_WR_AES_IV_A));
-	} else if (type == CA_CW_AES_ODD_IV) {
+	} else if (type == CA_CW_AES_ODD_IV ||
+			   type == CA_CW_SM4_ODD_IV) {
 		WRITE_MPEG_REG(CIPLUS_KEY0, k0);
 		WRITE_MPEG_REG(CIPLUS_KEY1, k1);
 		WRITE_MPEG_REG(CIPLUS_KEY2, k2);
@@ -2001,32 +2025,70 @@ void aml_ci_plus_set_iv(struct aml_dsc_channel *ch, enum ca_cw_type type,
  * Param:
  * key_endian
  *	S905D  7 for kl    0 for set key directly
- * aes_mode
+ * mode
  *  0 for ebc
  *  1 for cbc
  */
-static void aml_ci_plus_config(int key_endian, int mode, int aes_not_des)
+static void aml_ci_plus_config(int key_endian, int mode, int algo)
 {
 	unsigned int data;
-	int dis_aes_cbc =
-		(aes_not_des && (mode == AES_ECB_MODE)) ? 1 : 0;
-	WRITE_MPEG_REG(CIPLUS_ENDIAN,
-			(15 << AES_MSG_OUT_ENDIAN)
-			| (15 << AES_MSG_IN_ENDIAN)
-			| (key_endian << AES_KEY_ENDIAN)
-			|
-			(15 << DES_MSG_OUT_ENDIAN)
-			| (15 << DES_MSG_IN_ENDIAN)
-			| (key_endian << DES_KEY_ENDIAN)
-			);
+	unsigned int idsa_mode = 0;
+	unsigned int sm4_mode = 0;
+	unsigned int cbc_disable = 0;
+	unsigned int des_enable = 0;
+	unsigned int aes_enable = 1;
+
+	pr_dbg("%s mode:%d,alog:%d\n",__FUNCTION__,mode,algo);
+
+	if (get_cpu_type() < MESON_CPU_MAJOR_ID_SM1) {
+		WRITE_MPEG_REG(CIPLUS_ENDIAN,
+				(15 << AES_MSG_OUT_ENDIAN)
+				| (15 << AES_MSG_IN_ENDIAN)
+				| (key_endian << AES_KEY_ENDIAN)
+				|
+				(15 << DES_MSG_OUT_ENDIAN)
+				| (15 << DES_MSG_IN_ENDIAN)
+				| (key_endian << DES_KEY_ENDIAN)
+				);
+	} else {
+		WRITE_MPEG_REG(CIPLUS_ENDIAN, 0);
+	}
+
 	data = READ_MPEG_REG(CIPLUS_ENDIAN);
-	WRITE_MPEG_REG(CIPLUS_CONFIG,
-			(1 << CNTL_ENABLE)
-			| (dis_aes_cbc << AES_CBC_DISABLE)
-			| (((aes_not_des) ? 1 : 0) << AES_EN)
-			| (((aes_not_des) ? 0 : 1) << DES_EN)
-			);
-	data = READ_MPEG_REG(DEMUX_CONTROL);
+
+	if (algo == ALGO_SM4) {
+		sm4_mode = 1;
+	} else if (algo ==  ALGO_AES){
+		sm4_mode = 0;
+	} else {
+		sm4_mode = 0;
+		des_enable = 1;
+	}
+
+	if (mode == IDSA_MODE) {
+		idsa_mode = 1;
+		cbc_disable = 0;
+	} else if (mode == CBC_MODE) {
+		cbc_disable = 0;
+	} else {
+		cbc_disable = 1;
+	}
+	pr_dbg("idsa_mode:%d sm4_mode:%d cbc_disable:%d aes_enable:%d des_enable:%d\n", \
+		idsa_mode,sm4_mode,cbc_disable,aes_enable,des_enable);
+
+	data =  (idsa_mode << IDSA_MODE_BIT) |
+			(sm4_mode << SM4_MODE ) |
+			(cbc_disable << AES_CBC_DISABLE) |
+			/*1 << AES_CBC_DISABLE     : ECB
+			 *0 << AES_CBC_DISABLE     : CBC
+			 */
+			(1 << CNTL_ENABLE) |
+			(aes_enable << AES_EN) |
+			(des_enable << DES_EN);
+
+	WRITE_MPEG_REG(CIPLUS_CONFIG, data);
+	data = READ_MPEG_REG(CIPLUS_CONFIG);
+	pr_dbg("CIPLUS_CONFIG is 0x%x\n",data);
 }
 
 /*
@@ -2135,54 +2197,86 @@ static void aml_ci_plus_disable(void)
 			~((1 << CIPLUS_IN_SEL) | (7 << CIPLUS_OUT_SEL)));
 }
 
-static int dsc_set_aes_des_key(struct aml_dsc_channel *ch, int flags,
+static int dsc_set_aes_des_sm4_key(struct aml_dsc_channel *ch, int flags,
 			enum ca_cw_type type, u8 *key)
 {
 	unsigned int k0, k1, k2, k3;
 	int iv = 0, aes = 0, des = 0;
 	int ab_iv = 0, ab_aes = 0, ab_des = 0;
 	int from_kl = flags & CA_CW_FROM_KL;
+	int algo = 0;
 
 	if (!from_kl) {
+		if (get_cpu_type() < MESON_CPU_MAJOR_ID_SM1) {
 		k3 = (key[0] << 24) | (key[1] << 16) | (key[2] << 8) | key[3];
 		k2 = (key[4] << 24) | (key[5] << 16) | (key[6] << 8) | key[7];
 		k1 = (key[8] << 24) | (key[9] << 16) | (key[10] << 8) | key[11];
 		k0 = (key[12] << 24) | (key[13] << 16)
 			| (key[14] << 8) | key[15];
+		} else {
+		k0 = (key[0]) | (key[1] << 8) | (key[2] << 16) | (key[3] << 24);
+		k1 = (key[4]) | (key[5] << 8) | (key[6] << 16) | (key[7] << 24);
+		k2 = (key[8]) | (key[9] << 8) | (key[10] << 16)| (key[11] << 24);
+		k3 = (key[12])| (key[13] << 8)| (key[14] << 16)| (key[15] << 24);
+		}
 	} else
 		k0 = k1 = k2 = k3 = 0;
 
 	switch (type) {
 	case CA_CW_AES_EVEN:
+	case CA_CW_SM4_EVEN:
 		ab_aes = (from_kl) ? 0x2 : 0x1;
-		if (ch->aes_mode == -1)
-			ch->aes_mode = AES_ECB_MODE;
+		if (ch->mode == -1)
+			ch->mode = ECB_MODE;
 		aes = 1;
+		if (type == CA_CW_AES_EVEN)
+			algo = ALGO_AES;
+		else
+			algo = ALGO_SM4;
 		break;
 	case CA_CW_AES_ODD:
+	case CA_CW_SM4_ODD:
 		ab_aes = (from_kl) ? 0x1 : 0x2;
-		if (ch->aes_mode == -1)
-			ch->aes_mode = AES_ECB_MODE;
+		if (ch->mode == -1)
+			ch->mode = ECB_MODE;
 		aes = 1;
+		if (type == CA_CW_AES_ODD)
+			algo = ALGO_AES;
+		else
+			algo = ALGO_SM4;
 		break;
 	case CA_CW_AES_EVEN_IV:
+	case CA_CW_SM4_EVEN_IV:
 		ab_iv = 0x1;
-		ch->aes_mode = AES_CBC_MODE;
+		if (ch->mode == -1)
+			ch->mode = CBC_MODE;
 		iv = 1;
+		if (type == CA_CW_AES_EVEN_IV)
+			algo = ALGO_AES;
+		else
+			algo = ALGO_SM4;
 		break;
 	case CA_CW_AES_ODD_IV:
+	case CA_CW_SM4_ODD_IV:
 		ab_iv = 0x2;
-		ch->aes_mode = AES_CBC_MODE;
+		if (ch->mode == -1)
+			ch->mode = CBC_MODE;
 		iv = 1;
+		if (type == CA_CW_AES_ODD_IV)
+			algo = ALGO_AES;
+		else
+			algo = ALGO_SM4;
 		break;
 	case CA_CW_DES_EVEN:
 		ab_des = 0x1;
-		ch->aes_mode = AES_ECB_MODE;
+		ch->mode = ECB_MODE;
 		des = 1;
+		algo = ALGO_DES;
 		break;
 	case CA_CW_DES_ODD:
 		ab_des = 0x2;
-		ch->aes_mode = AES_ECB_MODE;
+		ch->mode = ECB_MODE;
+		algo = ALGO_DES;
 		des = 1;
 		break;
 	default:
@@ -2191,9 +2285,9 @@ static int dsc_set_aes_des_key(struct aml_dsc_channel *ch, int flags,
 
 	/* Set endian and cbc/ecb mode */
 	if (from_kl)
-		aml_ci_plus_config(7, ch->aes_mode, (aes && !des));
+		aml_ci_plus_config(7, ch->mode, algo);
 	else
-		aml_ci_plus_config(0, ch->aes_mode, (aes && !des));
+		aml_ci_plus_config(0, ch->mode, algo);
 
 	/* Write keys to work */
 	if (iv || aes) {
@@ -2808,6 +2902,29 @@ find_done:
 	return record_flag;
 }
 
+static void dmx_cascade_set(int cur_dmx, int source) {
+	int fec_sel_demux = 0;
+	int data;
+
+	switch (source) {
+		case AM_TS_SRC_DMX0:
+		case AM_TS_SRC_DMX1:
+		case AM_TS_SRC_DMX2:
+			fec_sel_demux = source -AM_TS_SRC_DMX0;
+			break;
+		default:
+			fec_sel_demux = cur_dmx;
+			break;
+	}
+
+	data = READ_MPEG_REG(TS_TOP_CONFIG1);
+	data &= ~(0x3 << (cur_dmx*2));
+	data |= (fec_sel_demux << (cur_dmx*2));
+	WRITE_MPEG_REG(TS_TOP_CONFIG1,data);
+
+	pr_dbg("%s id:%d, source:%d data:0x%0x\n",__FUNCTION__,cur_dmx,fec_sel_demux,data);
+}
+
 /*Enable the demux device*/
 static int dmx_enable(struct aml_dmx *dmx)
 {
@@ -2869,6 +2986,21 @@ static int dmx_enable(struct aml_dmx *dmx)
 		record = 0;
 		*/
 		break;
+	case AM_TS_SRC_HIU1:
+		fec_sel = 8;
+		fec_ctrl = 0;
+		/*
+			support record in HIU mode
+		record = 0;
+		*/
+		break;
+	case AM_TS_SRC_DMX0:
+	case AM_TS_SRC_DMX1:
+	case AM_TS_SRC_DMX2:
+		fec_sel = -1;
+		fec_ctrl = 0;
+		record = record ? 1 : 0;
+		break;
 	default:
 		fec_sel = 0;
 		fec_ctrl = 0;
@@ -2876,11 +3008,14 @@ static int dmx_enable(struct aml_dmx *dmx)
 		break;
 	}
 
-	if (dmx->channel[0].used || dmx->channel[1].used)
+	if (dmx->channel[0].used || dmx->channel[1].used) {
 		hi_bsf = 1;
-	else
+		if (fec_sel == 8) {
+			hi_bsf = 2; /*hi_bsf select hiu1*/
+		}
+	}else {
 		hi_bsf = 0;
-
+	}
 	if ((dvb->dsc[0].dst != -1)
 	    && ((dvb->dsc[0].dst - AM_TS_SRC_DMX0) == dmx->id))
 		fec_core_sel = 1;
@@ -3006,12 +3141,26 @@ static int dmx_enable(struct aml_dmx *dmx)
 			      (7 << OTHER_ENDIAN) |
 			      (7 << BYPASS_ENDIAN) | (0 << SECTION_ENDIAN));
 		DMX_WRITE_REG(dmx->id, TS_HIU_CTL,
-			      (0 << LAST_BURST_THRESHOLD) |
-			      (hi_bsf << USE_HI_BSF_INTERFACE));
+//			      (0 << LAST_BURST_THRESHOLD) |
+			   (hi_bsf << USE_HI_BSF_INTERFACE));
 
-		DMX_WRITE_REG(dmx->id, FEC_INPUT_CONTROL,
+		if (fec_sel == -1) {
+			dmx_cascade_set(dmx->id,dmx->source);
+			DMX_WRITE_REG(dmx->id, FEC_INPUT_CONTROL,
 			      (fec_core_sel << FEC_CORE_SEL) |
-			      (fec_sel << FEC_SEL) | (fec_ctrl << 0));
+			      (0 << FEC_SEL) | (fec_ctrl << 0));
+		} else {
+			dmx_cascade_set(dmx->id,dmx->source);
+			if (fec_sel != 8) {
+				DMX_WRITE_REG(dmx->id, FEC_INPUT_CONTROL,
+				      (fec_core_sel << FEC_CORE_SEL) |
+				      (fec_sel << FEC_SEL) | (fec_ctrl << 0));
+			} else {
+				DMX_WRITE_REG(dmx->id, FEC_INPUT_CONTROL,
+				      (fec_core_sel << FEC_CORE_SEL) |
+				      (1 << FEC_SEL_3BIT) | (fec_ctrl << 0));
+			}
+		}
 		DMX_WRITE_REG(dmx->id, STB_OM_CTL,
 			      (0x40 << MAX_OM_DMA_COUNT) |
 			      (0x7f << LAST_OM_ADDR));
@@ -3033,6 +3182,12 @@ static int dmx_enable(struct aml_dmx *dmx)
 		DMX_WRITE_REG(dmx->id, STB_INT_MASK, 0);
 		DMX_WRITE_REG(dmx->id, FEC_INPUT_CONTROL, 0);
 		DMX_WRITE_REG(dmx->id, DEMUX_CONTROL, 0);
+		//dmx not used, but it can cascade for other dmx
+		if ((dmx->source == AM_TS_SRC_DMX0 ||
+			dmx->source == AM_TS_SRC_DMX1 ||
+			dmx->source == AM_TS_SRC_DMX2 ) &&
+			(dmx->id != dmx->source-AM_TS_SRC_DMX0))
+			dmx_cascade_set(dmx->id,dmx->source);
 	}
 
 	return 0;
@@ -4725,6 +4880,18 @@ int aml_dmx_hw_set_source(struct dmx_demux *demux, dmx_source_t src)
 	case DMX_SOURCE_DVR0:
 		hw_src = AM_TS_SRC_HIU;
 		break;
+	case DMX_SOURCE_DVR1:
+		hw_src = AM_TS_SRC_HIU1;
+		break;
+	case DMX_SOURCE_FRONT0_OFFSET:
+		hw_src = AM_TS_SRC_DMX0;
+		break;
+	case DMX_SOURCE_FRONT1_OFFSET:
+		hw_src = AM_TS_SRC_DMX1;
+		break;
+	case DMX_SOURCE_FRONT2_OFFSET:
+		hw_src = AM_TS_SRC_DMX2;
+		break;
 	default:
 		pr_error("illegal demux source %d\n", src);
 		ret = -EINVAL;
@@ -4779,6 +4946,9 @@ int aml_stb_hw_set_source(struct aml_dvb *dvb, dmx_source_t src)
 	case DMX_SOURCE_DVR0:
 		hw_src = AM_TS_SRC_HIU;
 		break;
+	case DMX_SOURCE_DVR1:
+		hw_src = AM_TS_SRC_HIU1;
+		break;
 	case DMX_SOURCE_FRONT0_OFFSET:
 		hw_src = AM_TS_SRC_DMX0;
 		break;
diff --git a/drivers/stream_input/parser/hw_demux/aml_dvb.c b/drivers/stream_input/parser/hw_demux/aml_dvb.c
index acbf4d8..800c77e 100644
--- a/drivers/stream_input/parser/hw_demux/aml_dvb.c
+++ b/drivers/stream_input/parser/hw_demux/aml_dvb.c
@@ -402,7 +402,7 @@ static void dsc_channel_alloc(struct aml_dsc *dsc, int id, unsigned int pid)
 	ch->pid   = pid;
 	ch->set = 0;
 	ch->dsc   = dsc;
-	ch->aes_mode = -1;
+	ch->mode = -1;
 
 	dsc_set_pid(ch, ch->pid);
 }
@@ -419,7 +419,7 @@ static void dsc_channel_free(struct aml_dsc_channel *ch)
 	ch->pid   = 0x1fff;
 	ch->set = 0;
 	ch->work_mode = -1;
-	ch->aes_mode  = -1;
+	ch->mode  = -1;
 }
 
 static void dsc_reset(struct aml_dsc *dsc)
@@ -445,6 +445,10 @@ static int get_dsc_key_work_mode(enum ca_cw_type cw_type)
 	case CA_CW_AES_EVEN_IV:
 	case CA_CW_DES_EVEN:
 	case CA_CW_DES_ODD:
+	case CA_CW_SM4_EVEN:
+	case CA_CW_SM4_ODD:
+	case CA_CW_SM4_ODD_IV:
+	case CA_CW_SM4_EVEN_IV:
 		work_mode = CIPLUS_MODE;
 	default:
 		break;
@@ -494,17 +498,21 @@ static int dsc_set_cw(struct aml_dsc *dsc, struct ca_descr_ex *d)
 	case CA_CW_DVB_CSA_EVEN:
 	case CA_CW_AES_EVEN:
 	case CA_CW_DES_EVEN:
+	case CA_CW_SM4_EVEN:
 		memcpy(ch->even, d->cw, DSC_KEY_SIZE_MAX);
 		break;
 	case CA_CW_DVB_CSA_ODD:
 	case CA_CW_AES_ODD:
 	case CA_CW_DES_ODD:
+	case CA_CW_SM4_ODD:
 		memcpy(ch->odd, d->cw, DSC_KEY_SIZE_MAX);
 		break;
 	case CA_CW_AES_EVEN_IV:
+	case CA_CW_SM4_EVEN_IV:
 		memcpy(ch->even_iv, d->cw, DSC_KEY_SIZE_MAX);
 		break;
 	case CA_CW_AES_ODD_IV:
+	case CA_CW_SM4_ODD_IV:
 		memcpy(ch->odd_iv, d->cw, DSC_KEY_SIZE_MAX);
 		break;
 	default:
@@ -513,6 +521,10 @@ static int dsc_set_cw(struct aml_dsc *dsc, struct ca_descr_ex *d)
 
 	ch->set |= (1 << d->type) | (d->flags << 24);
 
+	if (d->mode == CA_DSC_IDSA) {
+		ch->mode = IDSA_MODE;
+	}
+
 	/*do key set*/
 	dsc_set_key(ch, d->flags, d->type, d->cw);
 	dsc_ciplus_switch_check(ch, d->type);
@@ -566,6 +578,7 @@ static int dvb_dsc_do_ioctl(struct file *file, unsigned int cmd,
 
 		dex.index = d->index;
 		dex.type  = d->parity ? CA_CW_DVB_CSA_ODD : CA_CW_DVB_CSA_EVEN;
+		dex.mode = -1;
 		dex.flags = 0;
 		memcpy(dex.cw, d->cw, sizeof(d->cw));
 
@@ -827,6 +840,9 @@ static ssize_t stb_show_source(struct class *class,
 	case AM_TS_SRC_HIU:
 		src = "hiu";
 		break;
+	case AM_TS_SRC_HIU1:
+		src = "hiu1";
+		break;
 	case AM_TS_SRC_DMX0:
 		src = "dmx0";
 		break;
@@ -876,6 +892,8 @@ static ssize_t stb_store_source(struct class *class,
 		src = DMX_SOURCE_FRONT3;
 	else if (!strncmp("hiu", buf, 3))
 		src = DMX_SOURCE_DVR0;
+	else if (!strncmp("hiu1", buf, 4))
+		src = DMX_SOURCE_DVR1;
 	else if (!strncmp("dmx0", buf, 4))
 		src = DMX_SOURCE_FRONT0 + 100;
 	else if (!strncmp("dmx1", buf, 4))
@@ -1099,9 +1117,21 @@ static ssize_t demux##i##_show_source(struct class *class,  \
 	CASE_PREFIX case AM_TS_SRC_S_TS2:\
 		src = "ts2";\
 	break;\
+	CASE_PREFIX case AM_TS_SRC_DMX0:\
+		src = "dmx0";\
+	break;\
+	CASE_PREFIX case AM_TS_SRC_DMX1:\
+		src = "dmx1";\
+	break;\
+	CASE_PREFIX case AM_TS_SRC_DMX2:\
+		src = "dmx2";\
+	break;\
 	CASE_PREFIX case AM_TS_SRC_HIU:\
 		src = "hiu";\
 	break;\
+	CASE_PREFIX case AM_TS_SRC_HIU1:\
+		src = "hiu1";\
+	break;\
 	CASE_PREFIX default :\
 		src = "";\
 	break;\
@@ -1122,6 +1152,14 @@ static ssize_t demux##i##_store_source(struct class *class,  \
 		src = DMX_SOURCE_FRONT2;\
 	} else if (!strncmp("hiu", buf, 3)) {\
 		src = DMX_SOURCE_DVR0;\
+	} else if (!strncmp("hiu1", buf, 3)) {\
+		src = DMX_SOURCE_DVR1;\
+	} else if (!strncmp("dmx0", buf, 4)) {\
+		src = DMX_SOURCE_FRONT0_OFFSET;\
+	} else if (!strncmp("dmx1", buf, 4)) {\
+		src = DMX_SOURCE_FRONT1_OFFSET;\
+	} else if (!strncmp("dmx2", buf, 4)) {\
+		src = DMX_SOURCE_FRONT2_OFFSET;\
 	} \
 	if (src != -1) {\
 		aml_dmx_hw_set_source(aml_dvb_device.dmx[i].dmxdev.demux, src);\
diff --git a/drivers/stream_input/parser/hw_demux/aml_dvb.h b/drivers/stream_input/parser/hw_demux/aml_dvb.h
index cc7d39f..50ad862 100644
--- a/drivers/stream_input/parser/hw_demux/aml_dvb.h
+++ b/drivers/stream_input/parser/hw_demux/aml_dvb.h
@@ -94,6 +94,7 @@ enum aml_ts_source_t {
 	AM_TS_SRC_S_TS2,
 
 	AM_TS_SRC_HIU,
+	AM_TS_SRC_HIU1,
 	AM_TS_SRC_DMX0,
 	AM_TS_SRC_DMX1,
 	AM_TS_SRC_DMX2
@@ -126,14 +127,17 @@ struct aml_filter {
 
 #define DVBCSA_MODE 0
 #define CIPLUS_MODE 1
-#define AES_CBC_MODE 0
-#define AES_ECB_MODE 1
+#define CBC_MODE 0
+#define ECB_MODE 1
+#define IDSA_MODE 2
 
 #define DSC_SET_EVEN     1
 #define DSC_SET_ODD      2
 #define DSC_SET_AES_EVEN 4
 #define DSC_SET_AES_ODD  8
 #define DSC_FROM_KL      16
+#define DSC_SET_SM4_EVEN 32
+#define DSC_SET_SM4_ODD  64
 
 #define DSC_KEY_SIZE_MAX 16
 
@@ -148,7 +152,7 @@ struct aml_dsc_channel {
 	int                  id;
 	struct aml_dsc      *dsc;
 	int                  work_mode;
-	int                  aes_mode;
+	int                  mode;
 };
 
 struct aml_dsc {
diff --git a/drivers/stream_input/parser/hw_demux/c_stb_define.h b/drivers/stream_input/parser/hw_demux/c_stb_define.h
index dce68e0..5f7f4e3 100644
--- a/drivers/stream_input/parser/hw_demux/c_stb_define.h
+++ b/drivers/stream_input/parser/hw_demux/c_stb_define.h
@@ -62,11 +62,12 @@
 /* bit 19 -- invert fec_valid for S2P1*/
 /* bit 18 -- invert fec_clk for S2P1*/
 /* bit 17:16 -- fec_s_sel for S2P1
- * 00 - select TS0, 01 -- select TS1, 10 -- select TS2, 11 - reserved*/
+ * 00 - select TS0, 01 -- select TS1, 10 -- select TS2, 11 - TS3*/
 /* Bit 15 -- enable_des_pl_clk*/
-/* Bit 14:13 -- reserved*/
+/* Bit 14 -- reserved*/
+/* Bit 13 -- use FAIL for TS3*/
 /* Bit 12:10 -- ts_out_select,
- * 0-TS0, 1-TS1, 2-TS2, 3,4-Reserved, 5-S2P1, 6-S2P0, 7-File*/
+ * 0-TS0, 1-TS1, 2-TS2, 3-TS3,4-S2P2, 5-S2P1, 6-S2P0, 7-File*/
 /* bit 9:8 -- des_i_sel 00 -- select demux0 as des input,
 *  01 -- select_demux1, 10 -- select_demux2, 11 - reserved*/
 /* bit 7 -- enable_des_pl*/
@@ -86,6 +87,7 @@
 #define INVERT_S2P1_FEC_CLK         18
 #define S2P1_FEC_SERIAL_SEL         16
 #define ENABLE_DES_PL_CLK           15
+#define FAIL_TS3					13
 #define TS_OUTPUT_SOURCE            10
 #define DES_INPUT_SEL               8
 #define ENABLE_DES_PL               7
@@ -107,6 +109,26 @@
 #define S2P2_FEC_SERIAL_SEL         0
 
 
+/* 31:24 --  file_m2ts_skip_bytes_hiu1*/
+/* 21 -- ts_hiu_enable_hiu1 */
+/*20:16  --  fec_clk_div_hiu1*/
+/*15:8  -- TS_package_length_sub_1_hiu1 */
+/*7:0  --  fec_sync_byte_hiu1*/
+/*#define TS_HIU1_CONFIG	(STB_CBUS_BASE + 0x4e)*/
+#define FILE_M2TS_SKIP_BYTES_HIU1		24
+#define TS_HIU_ENABLE_HIU1				21
+#define FEC_CLK_DIV_HIU1				16
+#define TS_PACKAGE_LENGTH_SUB_1_HIU1 	8
+#define FEC_SYNC_BYTE_HIU1				0
+
+/*5:4 -- fec_sel_demux_2, default:2*/
+/*3:2 -- fec_sel_demux_1, default:1*/
+/*1:0 -- fec_sel_demux_0, default:0*/
+/*#define TS_TOP_CONFIG1	(STB_CBUS_BASE + 0x4f)*/
+#define FEC_SEL_DEMUX_2					4
+#define FEC_SEL_DEMUX_1					2
+#define FEC_SEL_DEMUX_0					0
+
 /* 31:28 - s2p1_clk_div*/
 /* 27:24 - s2p0_clk_div*/
 /* 23    - s2p1_disable*/
@@ -213,6 +235,7 @@
 /*#define FEC_INPUT_CONTROL_3
  * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x02)  // 0x16a2*/
 /*----------- bit define -----------*/
+#define FEC_SEL_3BIT			   16
 #define FEC_CORE_SEL               15
 #define FEC_SEL                    12
 #define FEC_INPUT_FEC_CLK          11
diff --git a/drivers/stream_input/parser/hw_demux/c_stb_regs_define.h b/drivers/stream_input/parser/hw_demux/c_stb_regs_define.h
index b063fe0..b12db68 100644
--- a/drivers/stream_input/parser/hw_demux/c_stb_regs_define.h
+++ b/drivers/stream_input/parser/hw_demux/c_stb_regs_define.h
@@ -47,6 +47,12 @@
 #define DEMUX_3_OFFSET         0xa0
 
 
+#define TS_HIU1_CONFIG	(STB_CBUS_BASE + 0x4e)
+#define P_TS_HIU1_CONFIG                 CBUS_REG_ADDR(TS_HIU1_CONFIG)
+
+#define TS_TOP_CONFIG1	(STB_CBUS_BASE + 0x4f)
+#define P_TS_TOP_CONFIG1                 CBUS_REG_ADDR(TS_TOP_CONFIG1)
+
 #define STB_S2P2_CONFIG  (STB_CBUS_BASE + 0xef)
 #define P_STB_S2P2_CONFIG                CBUS_REG_ADDR(STB_S2P2_CONFIG)
 

commit c3494ff69b5d3b484392e2a9f394a7d9e4a316f9
Author: shihong.zheng <shihong.zheng@amlogic.com>
Date:   Fri Aug 2 17:39:45 2019 +0800

    media_modules: add dec slt test code. [2/3]
    
    PD#OPS-679
    
    Problem:
    add dec slt test code.
    
    Solution:
    add slt test interface in amstream and frame check.
    
    Verify:
    x301
    
    Change-Id: Ia44ebc862d194b4175a38b211f95124e3b304404
    Signed-off-by: shihong.zheng <shihong.zheng@amlogic.com>

diff --git a/drivers/frame_provider/decoder/utils/frame_check.c b/drivers/frame_provider/decoder/utils/frame_check.c
index b9eaec0..b46bf85 100644
--- a/drivers/frame_provider/decoder/utils/frame_check.c
+++ b/drivers/frame_provider/decoder/utils/frame_check.c
@@ -437,20 +437,30 @@ static int do_yuv_dump(struct pic_check_mgr_t *mgr, struct vframe_s *vf)
 	if (dump->dump_cnt >= dump->num)
 		return 0;
 
-	if (mgr->size_pic >
-		(dump->buf_size - dump->dump_cnt * mgr->size_pic)) {
-		if (dump->buf_size) {
+	if (single_mode_vdec != NULL) {
+		if (mgr->size_pic >
+			(dump->buf_size - dump->dump_cnt * mgr->size_pic)) {
+			if (dump->buf_size) {
+				dbg_print(FC_ERROR,
+					"not enough buf, force dump less\n");
+				dump->num = dump->dump_cnt;
+				check_schedule(mgr);
+			} else
+				set_disable(mgr, YUV_MASK);
+			return -1;
+		}
+		tmp_addr = dump->buf_addr +
+			mgr->size_pic * dump->dump_cnt;
+	} else {
+		if (mgr->size_pic > dump->buf_size) {
 			dbg_print(FC_ERROR,
-				"not enough buf, force dump less\n");
-			dump->num = dump->dump_cnt;
-			check_schedule(mgr);
-		} else
-			set_disable(mgr, YUV_MASK);
-		return -1;
+				"not enough size, pic/buf size: 0x%x/0x%x\n",
+				mgr->size_pic, dump->buf_size);
+			return -1;
+		}
+		tmp_addr = dump->buf_addr;
 	}
 
-	tmp_addr = dump->buf_addr +
-		mgr->size_pic * dump->dump_cnt;
 	if ((mgr->uv_vaddr == NULL) || (mgr->y_vaddr == NULL)) {
 		y_phyaddr = mgr->y_phyaddr;
 		uv_phyaddr = mgr->uv_phyaddr;
@@ -495,11 +505,34 @@ static int do_yuv_dump(struct pic_check_mgr_t *mgr, struct vframe_s *vf)
 		}
 	}
 	dump->dump_cnt++;
-	dbg_print(0, "----->dump frame num: %d, dump %dst, size %x\n",
-		mgr->frame_cnt, dump->dump_cnt, mgr->size_pic);
+	dbg_print(0, "----->dump %dst, size %x (%d x %d), dec total %d\n",
+		dump->dump_cnt, mgr->size_pic, vf->width, vf->height, mgr->frame_cnt);
 
-	if (dump->dump_cnt >= dump->num)
-		check_schedule(mgr);
+	if (single_mode_vdec != NULL) {
+		/* single mode need schedule work to write*/
+		if (dump->dump_cnt >= dump->num)
+			check_schedule(mgr);
+	} else {
+		int wr_size;
+		mm_segment_t old_fs;
+
+		/* dump for dec pic not in isr */
+		if (dump->yuv_fp == NULL) {
+			dump->yuv_fp = file_open(O_CREAT | O_WRONLY | O_TRUNC,
+				"%s%s-%d-%d.yuv", YUV_PATH, comp_crc, mgr->id, mgr->file_cnt);
+			if (dump->yuv_fp == NULL)
+				return -1;
+		}
+		old_fs = get_fs();
+		set_fs(KERNEL_DS);
+		wr_size = vfs_write(dump->yuv_fp, dump->buf_addr,
+			mgr->size_pic, &dump->yuv_pos);
+		if (mgr->size_pic != wr_size) {
+			dbg_print(FC_ERROR, "buf failed to write yuv file\n");
+		}
+		set_fs(old_fs);
+		vfs_fsync(dump->yuv_fp, 0);
+	}
 
 	return 0;
 }
@@ -533,14 +566,17 @@ static int crc_store(struct pic_check_mgr_t *mgr, struct vframe_s *vf,
 		if (comp_frame == mgr->frame_cnt) {
 			if ((comp_crc_y != crc_y) || (crc_uv != comp_crc_uv)) {
 					mgr->pic_dump.start = 0;
-					mgr->pic_dump.num++;
+					if (fc_debug || mgr->pic_dump.num < 3)
+						mgr->pic_dump.num++;
 					dbg_print(0, "\n\nError: %08d: %08x %08x != %08x %08x\n\n",
 						mgr->frame_cnt, crc_y, crc_uv, comp_crc_y, comp_crc_uv);
 					do_yuv_dump(mgr, vf);
 					if (fc_debug & FC_ERR_CRC_BLOCK_MODE)
 						mgr->err_crc_block = 1;
+					mgr->usr_cmp_result = -mgr->frame_cnt;
 			}
 		} else {
+			mgr->usr_cmp_result = -mgr->frame_cnt;
 			dbg_print(0, "frame num error: frame_cnt(%d) frame_comp(%d)\n",
 				mgr->frame_cnt, comp_frame);
 		}
@@ -769,6 +805,54 @@ static int fbc_check_prepare(struct pic_check_t *check,
 	return 0;
 }
 
+int load_user_cmp_crc(struct pic_check_mgr_t *mgr)
+{
+	int i;
+	struct pic_check_t *chk;
+	void *qaddr;
+
+	if (mgr == NULL ||
+		(mgr->cmp_pool == NULL)||
+		(mgr->usr_cmp_num == 0))
+		return 0;
+
+	chk = &mgr->pic_check;
+
+	if (chk->cmp_crc_cnt > 0) {
+		pr_info("cmp crc32 data is ready\n");
+		return -1;
+	}
+
+	if (chk->check_addr == NULL) {
+		pr_info("no cmp crc buf\n"); /* vmalloc again or return */
+		return -1;
+	}
+
+	if (mgr->usr_cmp_num >= USER_CMP_POOL_MAX_SIZE)
+		mgr->usr_cmp_num = USER_CMP_POOL_MAX_SIZE - 1;
+
+	for (i = 0; i < mgr->usr_cmp_num; i++) {
+		qaddr = chk->check_addr + i * SIZE_CRC;
+		dbg_print(FC_CRC_DEBUG, "%s, %8d: %08x %08x\n", __func__,
+			mgr->cmp_pool[i].pic_num,
+			mgr->cmp_pool[i].y_crc,
+			mgr->cmp_pool[i].uv_crc);
+		sprintf(qaddr, "%8d: %08x %08x\n",
+			mgr->cmp_pool[i].pic_num,
+			mgr->cmp_pool[i].y_crc,
+			mgr->cmp_pool[i].uv_crc);
+
+		kfifo_put(&chk->new_chk_q, qaddr);
+		chk->cmp_crc_cnt++;
+	}
+
+	mgr->usr_cmp_result = 0;
+
+	vfree(mgr->cmp_pool);
+	mgr->cmp_pool = NULL;
+
+	return 0;
+}
 
 
 int decoder_do_frame_check(struct vdec_s *vdec, struct vframe_s *vf)
@@ -798,8 +882,12 @@ int decoder_do_frame_check(struct vdec_s *vdec, struct vframe_s *vf)
 
 	if (mgr->last_size_pic != mgr->size_pic) {
 		resize = 1;
-		dbg_print(0, "size changed, %x-->%x\n",
-			mgr->last_size_pic, mgr->size_pic);
+		dbg_print(0, "size changed, %x-->%x [%d x %d]\n",
+			mgr->last_size_pic, mgr->size_pic,
+			vf->width, vf->height);
+		/* for slt, if no compare crc file, use the
+		 * cmp crc from amstream ioctl write */
+		load_user_cmp_crc(mgr);
 	} else
 		resize = 0;
 	mgr->last_size_pic = mgr->size_pic;
@@ -844,6 +932,10 @@ int decoder_do_frame_check(struct vdec_s *vdec, struct vframe_s *vf)
 	}
 	mgr->frame_cnt++;
 
+	if (mgr->usr_cmp_num > 0) {
+		mgr->usr_cmp_num -= 1;
+	}
+
 	return ret;
 }
 EXPORT_SYMBOL(decoder_do_frame_check);
@@ -975,7 +1067,8 @@ void frame_check_exit(struct pic_check_mgr_t *mgr)
 			cancel_work_sync(&mgr->frame_check_work);
 			atomic_set(&mgr->work_inited, 0);
 		}
-		write_yuv_work(mgr);
+		if (single_mode_vdec != NULL)
+			write_yuv_work(mgr);
 		write_crc_work(mgr);
 
 		for (i = 0; i < ARRAY_SIZE(check->fbc_planes); i++) {
@@ -989,6 +1082,11 @@ void frame_check_exit(struct pic_check_mgr_t *mgr)
 			check->check_addr = NULL;
 		}
 
+		if (mgr->cmp_pool) {
+			vfree(mgr->cmp_pool);
+			mgr->cmp_pool = NULL;
+		}
+
 		if (check->check_fp) {
 			filp_close(check->check_fp, current->files);
 			check->check_fp = NULL;
diff --git a/drivers/frame_provider/decoder/utils/frame_check.h b/drivers/frame_provider/decoder/utils/frame_check.h
index f1ba677..430015f 100644
--- a/drivers/frame_provider/decoder/utils/frame_check.h
+++ b/drivers/frame_provider/decoder/utils/frame_check.h
@@ -26,11 +26,13 @@
 
 #define FRAME_CHECK
 
-#define YUV_MAX_DUMP_NUM  20
+#define YUV_MAX_DUMP_NUM  60
 
 #define SIZE_CRC	64
 #define SIZE_CHECK_Q 128
 
+#define USER_CMP_POOL_MAX_SIZE (SIZE_CHECK_Q)
+
 struct pic_dump_t{
 	struct file *yuv_fp;
 	loff_t yuv_pos;
@@ -79,6 +81,10 @@ struct pic_check_mgr_t{
 
 	struct pic_check_t pic_check;
 	struct pic_dump_t  pic_dump;
+
+	struct usr_crc_info_t *cmp_pool;
+	int usr_cmp_num;
+	int usr_cmp_result;
 };
 
 int dump_yuv_trig(struct pic_check_mgr_t *mgr,
diff --git a/drivers/stream_input/amports/amstream.c b/drivers/stream_input/amports/amstream.c
index e2e4498..8c9ef11 100644
--- a/drivers/stream_input/amports/amstream.c
+++ b/drivers/stream_input/amports/amstream.c
@@ -3316,6 +3316,59 @@ static long amstream_do_ioctl_old(struct port_priv_s *priv,
 			tsync_set_apts(pts);
 		break;
 	}
+	case AMSTREAM_IOC_SET_CRC: {
+		struct usr_crc_info_t crc_info;
+		struct vdec_s *vdec;
+
+		if (copy_from_user(&crc_info, (void __user *)arg,
+			sizeof(struct usr_crc_info_t))) {
+			return -EFAULT;
+		}
+		/*
+		pr_info("id %d, frame %d, y_crc: %08x, uv_crc: %08x\n", crc_info.id,
+			crc_info.pic_num, crc_info.y_crc, crc_info.uv_crc);
+		*/
+		vdec = vdec_get_vdec_by_id(crc_info.id);
+		if (vdec == NULL)
+			return -ENODEV;
+		if (vdec->vfc.cmp_pool == NULL) {
+			vdec->vfc.cmp_pool =
+				vmalloc(USER_CMP_POOL_MAX_SIZE *
+					sizeof(struct usr_crc_info_t));
+			if (vdec->vfc.cmp_pool == NULL)
+				return -ENOMEM;
+		}
+		if (vdec->vfc.usr_cmp_num >= USER_CMP_POOL_MAX_SIZE) {
+			pr_info("warn: could not write any more, max %d",
+				USER_CMP_POOL_MAX_SIZE);
+			return -EFAULT;
+		}
+		memcpy(&vdec->vfc.cmp_pool[vdec->vfc.usr_cmp_num], &crc_info,
+			sizeof(struct usr_crc_info_t));
+		vdec->vfc.usr_cmp_num++;
+		break;
+	}
+	case AMSTREAM_IOC_GET_CRC_CMP_RESULT: {
+		int val, vdec_id;
+		struct vdec_s *vdec;
+
+		if (get_user(val, (int __user *)arg)) {
+			return -EFAULT;
+		}
+		vdec_id = val & 0x00ff;
+		vdec = vdec_get_vdec_by_id(vdec_id);
+		if (vdec == NULL)
+			return -ENODEV;
+		if (val & 0xff00)
+			put_user(vdec->vfc.usr_cmp_num, (int *)arg);
+		else
+			put_user(vdec->vfc.usr_cmp_result, (int *)arg);
+		/*
+		pr_info("amstream get crc32 cmpare num %d result: %d\n",
+			vdec->vfc.usr_cmp_num, vdec->vfc.usr_cmp_result);
+		*/
+		break;
+	}
 	default:
 		r = -ENOIOCTLCMD;
 		break;

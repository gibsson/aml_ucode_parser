commit c2c3714bbf9a1ce1833e5a52e3345cb688644303
Author: hualing chen <hualing.chen@amlogic.com>
Date:   Wed Jul 3 13:39:11 2019 +0800

    media_module: control CAM throw mcu and used api to control mcu. [3/9]
    
    PD#SWPL-10659
    
    Problem:
    not support control mcu by spi and rw cam card by spi mode.
    not support ts3 port.
    
    Solution:
    1 add control mcu function and rw cam card api.
    2 add ts3 port support.
    3 add en50221 funtion for mcu mode.
    
    Verify:
    verified on t962x3-t312 box.
    
    Change-Id: If87964cc26feed0145bb8ee8d57316c45f6342c2
    Signed-off-by: hualing chen <hualing.chen@amlogic.com>

diff --git a/drivers/stream_input/parser/dvb_ci/Makefile b/drivers/stream_input/parser/dvb_ci/Makefile
index bbfbdd4..25cdcb9 100644
--- a/drivers/stream_input/parser/dvb_ci/Makefile
+++ b/drivers/stream_input/parser/dvb_ci/Makefile
@@ -1,8 +1,9 @@
 obj-m += ci.o cimax-usb.o
 
-ci-objs = $(amlci-objs) $(cimax-objs)
+ci-objs = $(amlci-objs) $(cimcu-objs) $(cimax-objs)
 
-amlci-objs = aml_pcmcia.o  aml_ci.o
+amlci-objs = aml_pcmcia.o  aml_ci.o aml_spi.o
+cimcu-objs = cimcu/dvb_ca_en50221_cimcu.o
 cimax-objs = cimax/dvb_ca_en50221_cimax.o cimax/aml_cimax.o  cimax/dvb_ringbuffer.o
 cimax-usb-objs += cimax/usb/SRC/cimax+usb-driver.o cimax/usb/SRC/cimax+usb_fw.o
 cimax-usb-objs += cimax/usb/SRC/cimax+usb_config.o
diff --git a/drivers/stream_input/parser/dvb_ci/aml_ci.c b/drivers/stream_input/parser/dvb_ci/aml_ci.c
index 1462e2d..d457a05 100644
--- a/drivers/stream_input/parser/dvb_ci/aml_ci.c
+++ b/drivers/stream_input/parser/dvb_ci/aml_ci.c
@@ -29,6 +29,8 @@
 #include "aml_ci.h"
 #include "aml_spi.h"
 #include "cimax/aml_cimax.h"
+
+//#include "dvb_ca_en50221.h"
 #include <dvbdev.h>
 
 MODULE_PARM_DESC(aml_ci_debug, "\n\t\t dvb ci debug");
@@ -52,7 +54,7 @@ extern struct dvb_adapter *aml_get_dvb_adapter(void);
  *   - read value:ok
  *   - -EINVAL : error
  */
-static int aml_ci_mem_read(struct dvb_ca_en50221 *en50221, int slot, int addr)
+static int aml_ci_mem_read(struct dvb_ca_en50221_cimcu *en50221, int slot, int addr)
 {
 	struct aml_ci *ci = en50221->data;
 
@@ -76,7 +78,7 @@ static int aml_ci_mem_read(struct dvb_ca_en50221 *en50221, int slot, int addr)
  *   - 0:ok
  *   - -EINVAL : error
  */
-static int aml_ci_mem_write(struct dvb_ca_en50221 *en50221,
+static int aml_ci_mem_write(struct dvb_ca_en50221_cimcu *en50221,
 		int slot, int addr, u8 data)
 {
 
@@ -100,7 +102,7 @@ static int aml_ci_mem_write(struct dvb_ca_en50221 *en50221,
  *   - read value:ok
  *   - -EINVAL : error
  */
-static int aml_ci_io_read(struct dvb_ca_en50221 *en50221, int slot, u8 addr)
+static int aml_ci_io_read(struct dvb_ca_en50221_cimcu *en50221, int slot, u8 addr)
 {
 	struct aml_ci *ci = en50221->data;
 
@@ -124,7 +126,7 @@ static int aml_ci_io_read(struct dvb_ca_en50221 *en50221, int slot, u8 addr)
  *   - 0:ok
  *   - -EINVAL : error
  */
-static int aml_ci_io_write(struct dvb_ca_en50221 *en50221,
+static int aml_ci_io_write(struct dvb_ca_en50221_cimcu *en50221,
 		int slot, u8 addr, u8 data)
 {
 	struct aml_ci *ci = en50221->data;
@@ -147,7 +149,7 @@ static int aml_ci_io_write(struct dvb_ca_en50221 *en50221,
  *   - 0:ok
  *   - -EINVAL : error
  */
-static int aml_ci_slot_reset(struct dvb_ca_en50221 *en50221, int slot)
+static int aml_ci_slot_reset(struct dvb_ca_en50221_cimcu *en50221, int slot)
 {
 	struct aml_ci *ci = en50221->data;
 	pr_dbg("Slot(%d): Slot RESET\n", slot);
@@ -166,7 +168,7 @@ static int aml_ci_slot_reset(struct dvb_ca_en50221 *en50221, int slot)
  *   - 0:ok
  *   - -EINVAL : error
  */
-static int aml_ci_slot_shutdown(struct dvb_ca_en50221 *en50221, int slot)
+static int aml_ci_slot_shutdown(struct dvb_ca_en50221_cimcu *en50221, int slot)
 {
 	struct aml_ci *ci = en50221->data;
 	pr_dbg("Slot(%d): Slot shutdown\n", slot);
@@ -185,7 +187,7 @@ static int aml_ci_slot_shutdown(struct dvb_ca_en50221 *en50221, int slot)
  *   - 0:ok
  *   - -EINVAL : error
  */
-static int aml_ci_ts_control(struct dvb_ca_en50221 *en50221, int slot)
+static int aml_ci_ts_control(struct dvb_ca_en50221_cimcu *en50221, int slot)
 {
 
 		struct aml_ci *ci = en50221->data;
@@ -206,7 +208,7 @@ static int aml_ci_ts_control(struct dvb_ca_en50221 *en50221, int slot)
  *   - cam status
  *   - -EINVAL : error
  */
-static int aml_ci_slot_status(struct dvb_ca_en50221 *en50221,
+static int aml_ci_slot_status(struct dvb_ca_en50221_cimcu *en50221,
 		int slot, int open)
 {
 	struct aml_ci *ci = en50221->data;
@@ -554,22 +556,24 @@ int aml_ci_init(struct platform_device *pdev,
 		}
 	} else {
 		ca_flags		= DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE;
-		ci->en50221.read_attribute_mem	= aml_ci_mem_read;
-		ci->en50221.write_attribute_mem	= aml_ci_mem_write;
-		ci->en50221.read_cam_control	= aml_ci_io_read;
-		ci->en50221.write_cam_control	= aml_ci_io_write;
-		ci->en50221.slot_reset		= aml_ci_slot_reset;
-		ci->en50221.slot_shutdown	= aml_ci_slot_shutdown;
-		ci->en50221.slot_ts_enable	= aml_ci_ts_control;
-		ci->en50221.poll_slot_status	= aml_ci_slot_status;
-		ci->en50221.data		= ci;
+		/* register CA interface */
+		ci->en50221_cimcu.owner		= THIS_MODULE;
+		ci->en50221_cimcu.read_attribute_mem	= aml_ci_mem_read;
+		ci->en50221_cimcu.write_attribute_mem	= aml_ci_mem_write;
+		ci->en50221_cimcu.read_cam_control	= aml_ci_io_read;
+		ci->en50221_cimcu.write_cam_control	= aml_ci_io_write;
+		ci->en50221_cimcu.slot_reset		= aml_ci_slot_reset;
+		ci->en50221_cimcu.slot_shutdown	= aml_ci_slot_shutdown;
+		ci->en50221_cimcu.slot_ts_enable	= aml_ci_ts_control;
+		ci->en50221_cimcu.poll_slot_status	= aml_ci_slot_status;
+		ci->en50221_cimcu.data		= ci;
 
 
 		pr_dbg("Registering EN50221 device\n");
-		result = dvb_ca_en50221_init(dvb_adapter,
-			&ci->en50221, ca_flags, 1);
+		result = dvb_ca_en50221_cimcu_init(dvb_adapter,
+			&ci->en50221_cimcu, ca_flags, 1);
 		if (result != 0) {
-			pr_error("EN50221: Initialization failed <%d>\n",
+			pr_error("EN50221_cimcu: Initialization failed <%d>\n",
 				result);
 			goto err;
 		}
@@ -577,10 +581,10 @@ int aml_ci_init(struct platform_device *pdev,
 	*cip = ci;
 	pr_dbg("Registered EN50221 device\n");
 
-	if (ci->io_type == AML_DVB_IO_TYPE_SPI) {
+	if (ci->io_type == AML_DVB_IO_TYPE_SPI || ci->io_type == AML_DVB_IO_TYPE_SPI_T312) {
 		/* spi init */
-		//ci->ci_init = aml_spi_init;
-		//ci->ci_exit = aml_spi_exit;
+		ci->ci_init = aml_spi_init;
+		ci->ci_exit = aml_spi_exit;
 	} else if (ci->io_type == AML_DVB_IO_TYPE_CIMAX) {
 		ci->ci_init = aml_cimax_init;
 		ci->ci_exit = aml_cimax_exit;
@@ -591,10 +595,10 @@ int aml_ci_init(struct platform_device *pdev,
 
 	if (ci->ci_init)
 		result = ci->ci_init(pdev, ci);
-
-	if (result)
-		dvb_ca_en50221_cimax_release(&ci->en50221_cimax);
-
+	if (ci->io_type == AML_DVB_IO_TYPE_CIMAX) {
+		if (result)
+			dvb_ca_en50221_cimax_release(&ci->en50221_cimax);
+	}
 	return result;
 err:
 	kfree(ci);
@@ -608,7 +612,7 @@ void aml_ci_exit(struct aml_ci *ci)
 		if (ci->io_type == AML_DVB_IO_TYPE_CIMAX)
 			dvb_ca_en50221_cimax_release(&ci->en50221_cimax);
 		else
-			dvb_ca_en50221_release(&ci->en50221);
+			dvb_ca_en50221_cimcu_release(&ci->en50221_cimcu);
 		if (ci->ci_exit)
 			ci->ci_exit(ci);
 		kfree(ci);
@@ -670,6 +674,9 @@ static int aml_ci_probe(struct platform_device *pdev)
 		return err;
 	platform_set_drvdata(pdev, ci_dev);
 	aml_ci_register_class(ci_dev);
+	if (ci_dev->io_type == AML_DVB_IO_TYPE_SPI ||
+		ci_dev->io_type == AML_DVB_IO_TYPE_SPI_T312)
+			aml_spi_mod_init();
 	return 0;
 }
 
@@ -677,8 +684,10 @@ static int aml_ci_remove(struct platform_device *pdev)
 {
 	aml_ci_unregister_class(ci_dev);
 	platform_set_drvdata(pdev, NULL);
-	if (ci_dev->io_type == AML_DVB_IO_TYPE_SPI) {
-		//aml_spi_exit(ci_dev);
+	if (ci_dev->io_type == AML_DVB_IO_TYPE_SPI ||
+		ci_dev->io_type == AML_DVB_IO_TYPE_SPI_T312) {
+			aml_spi_exit(ci_dev);
+			aml_spi_mod_exit();
 		}
 	else if (ci_dev->io_type == AML_DVB_IO_TYPE_CIMAX)
 		aml_cimax_exit(ci_dev);
@@ -692,8 +701,9 @@ static int aml_ci_remove(struct platform_device *pdev)
 static int aml_ci_suspend(struct platform_device *pdev, pm_message_t state)
 {
 	pr_dbg("Amlogic CI Suspend!\n");
-	if (ci_dev->io_type == AML_DVB_IO_TYPE_SPI) {
-		//aml_spi_exit(ci_dev);
+	if (ci_dev->io_type == AML_DVB_IO_TYPE_SPI ||
+		ci_dev->io_type == AML_DVB_IO_TYPE_SPI_T312) {
+		  aml_spi_exit(ci_dev);
 		}
 	else if (ci_dev->io_type == AML_DVB_IO_TYPE_CIMAX)
 		aml_cimax_exit(ci_dev);
@@ -707,8 +717,9 @@ static int aml_ci_resume(struct platform_device *pdev)
 {
 	int err = 0;
 	pr_dbg("Amlogic CI Resume!\n");
-	if (ci_dev->io_type == AML_DVB_IO_TYPE_SPI) {
-		//aml_spi_init(pdev, ci_dev);
+	if (ci_dev->io_type == AML_DVB_IO_TYPE_SPI ||
+		ci_dev->io_type == AML_DVB_IO_TYPE_SPI_T312) {
+		  aml_spi_init(pdev, ci_dev);
 		}
 	else if (ci_dev->io_type == AML_DVB_IO_TYPE_CIMAX)
 		aml_cimax_init(pdev, ci_dev);
diff --git a/drivers/stream_input/parser/dvb_ci/aml_ci.h b/drivers/stream_input/parser/dvb_ci/aml_ci.h
index 2d52334..9006b7e 100644
--- a/drivers/stream_input/parser/dvb_ci/aml_ci.h
+++ b/drivers/stream_input/parser/dvb_ci/aml_ci.h
@@ -21,18 +21,22 @@
 #ifndef __AML_CI_H_
 #define __AML_CI_H_
 
-#include "drivers/media/dvb-core/dvb_ca_en50221.h"
+//#include "drivers/media/dvb-core/dvb_ca_en50221.h"
+#include "cimcu/dvb_ca_en50221_cimcu.h"
 #include "cimax/dvb_ca_en50221_cimax.h"
+#include <linux/platform_device.h>
 
 enum aml_dvb_io_type_e {
 	AML_DVB_IO_TYPE_IOBUS = 0,
 	AML_DVB_IO_TYPE_SPI,
 	AML_DVB_IO_TYPE_CIMAX,
+	AML_DVB_IO_TYPE_SPI_T312,
 	AML_DVB_IO_TYPE_MAX,
 };
 
 struct aml_ci {
-	struct dvb_ca_en50221		en50221;
+//	struct dvb_ca_en50221		en50221;
+	struct dvb_ca_en50221_cimcu	en50221_cimcu;
 	struct mutex			ci_lock;
 	int				io_type;
 	void				*priv;
diff --git a/drivers/stream_input/parser/dvb_ci/aml_pcmcia.c b/drivers/stream_input/parser/dvb_ci/aml_pcmcia.c
index ac8c87d..6b9def8 100644
--- a/drivers/stream_input/parser/dvb_ci/aml_pcmcia.c
+++ b/drivers/stream_input/parser/dvb_ci/aml_pcmcia.c
@@ -7,6 +7,7 @@
 #include <linux/device.h>
 
 #include "aml_pcmcia.h"
+#include "aml_ci.h"
 
 static int aml_pcmcia_debug = 1;
 
@@ -90,11 +91,34 @@ static void aml_pcmcia_work(struct work_struct *work)
 	}
 }
 
+static void aml_pcmcia_detect_cam(struct aml_pcmcia *pc)
+{
+	int cd1, cd2;
+
+	if (pc == NULL) {
+		return;
+	}
+	cd1 = pc->get_cd1(pc);
+	cd2 = pc->get_cd2(pc);
+
+	if (cd1 != cd2)
+		pr_error("CAM card not inerted. check end\n");
+	else {
+		if (!cd1) {
+			pr_error("Adapter(%d) Slot(0): CAM Plugin\n", 0);
+			pcmcia_plugin(pc);
+		} else {
+			pr_error("Adapter(%d) Slot(0): CAM Unplug\n", 0);
+			pcmcia_unplug(pc);
+		}
+	}
+}
 static struct aml_pcmcia *pc_cur;
 
 int aml_pcmcia_init(struct aml_pcmcia *pc)
 {
 	int err = 0;
+	unsigned long mode;
 	pr_dbg("aml_pcmcia_init start pc->irq=%d\r\n", pc->irq);
 	pc->rst(pc, AML_L);
 	/*power on*/
@@ -104,9 +128,14 @@ int aml_pcmcia_init(struct aml_pcmcia *pc)
 
 	INIT_WORK(&pc->pcmcia_work, aml_pcmcia_work);
 
+	mode = IRQF_ONESHOT;
+	if (pc->io_device_type == AML_DVB_IO_TYPE_SPI_T312) {
+		mode = mode | IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING;
+	}
+
 	err = request_irq(pc->irq,
 	pcmcia_irq_handler,
-	IRQF_ONESHOT, "aml-pcmcia", pc);
+	mode, "aml-pcmcia", pc);
 	if (err != 0) {
 		pr_error("ERROR: IRQ registration failed ! <%d>", err);
 		return -ENODEV;
@@ -114,6 +143,11 @@ int aml_pcmcia_init(struct aml_pcmcia *pc)
 
 	pc_cur = pc;
 	pr_dbg("aml_pcmcia_init ok\r\n");
+	if (pc->io_device_type == AML_DVB_IO_TYPE_SPI_T312) {
+		//mcu start very fast,so she can detect cam before soc init end.
+		//so we need add detect cam fun for first time.
+		aml_pcmcia_detect_cam(pc);
+	}
 	return 0;
 }
 EXPORT_SYMBOL(aml_pcmcia_init);
diff --git a/drivers/stream_input/parser/dvb_ci/aml_pcmcia.h b/drivers/stream_input/parser/dvb_ci/aml_pcmcia.h
index 612d577..7d0a275 100644
--- a/drivers/stream_input/parser/dvb_ci/aml_pcmcia.h
+++ b/drivers/stream_input/parser/dvb_ci/aml_pcmcia.h
@@ -48,6 +48,8 @@ struct aml_pcmcia {
 	int (*pcmcia_plugin)(struct aml_pcmcia *pc, int plugin);
 
 	void *priv;
+	/*device type*/
+	int io_device_type;
 };
 
 int aml_pcmcia_init(struct aml_pcmcia *pc);
diff --git a/drivers/stream_input/parser/dvb_ci/aml_spi.c b/drivers/stream_input/parser/dvb_ci/aml_spi.c
index 62f4f53..91efe2a 100644
--- a/drivers/stream_input/parser/dvb_ci/aml_spi.c
+++ b/drivers/stream_input/parser/dvb_ci/aml_spi.c
@@ -38,6 +38,9 @@
 #include "aml_ci.h"
 
 #define AML_MODE_NAME       "aml_dvbci_spi"
+
+#define AML_SPI_READ_LEN       16
+
 static int  AML_CI_GPIO_IRQ_BASE = 251;
 static struct aml_spi *g_spi_dev;
 static int aml_spi_debug = 1;
@@ -183,7 +186,7 @@ int aml_ci_spi_paser_bit(uint8_t value)
 * \param spi_dev: aml_spi obj,used this data to get spi obj
 * \param val: write value
 * \param len: write value len
-* \param mode: read or write
+* \param mode: cmd
 * \return
 *   - read value:ok
 *   - -EINVAL : error
@@ -194,6 +197,12 @@ static int aml_spi_io_api(struct aml_spi *spi_dev, u8 *val, int len, int mode)
 	int ret = 0;
 	int i = 0;
 	u8 rd = 0;
+	int j = 0;
+	int is_retry = 0;
+	if (spi_dev == NULL ) {
+		pr_error("%s spi_dev  is null\r\n", __func__);
+		return -EINVAL;
+	}
 	if (spi_dev->spi == NULL) {
 		pr_error("%s spi is null\r\n", __func__);
 		return -EINVAL;
@@ -201,32 +210,48 @@ static int aml_spi_io_api(struct aml_spi *spi_dev, u8 *val, int len, int mode)
 	spin_lock(&spi_dev->spi_lock);
 	if (spi_dev->cs_hold_delay)
 		udelay(spi_dev->cs_hold_delay);
+restart:
 	dirspi_start(spi_dev->spi);
 	if (spi_dev->cs_clk_delay)
 		udelay(spi_dev->cs_clk_delay);
 
-	dirspi_xfer(spi_dev->spi, val, rb, len);
-	/* wait mcu io */
+	ret = dirspi_xfer(spi_dev->spi, val, rb, len);
+	if (ret != 0)
+			pr_dbg("spi xfer value errro ret %d\r\n",  ret);
+	/* wait mcu io 1ms */
 	udelay(1000);
 	/* init rec flag */
 	G_rec_flag = AM_SPI_STEP_INIT;
 	memset(rbuf, 0, 8);
-	for (i = 0; i < 4*len; i++) {
+
+	for (i = 0; i < 4 * len; i++) {
 		udelay(50);
-		ret = dirspi_read(spi_dev->spi, &rd, 1);
-		if (ret != 0)
-			pr_dbg("spi read value timeout:%x\r\n", rd);
-		ret = aml_ci_spi_paser_bit(rd);
+		memset(rb, 0, 32);
+		ret = dirspi_read(spi_dev->spi, rb, AML_SPI_READ_LEN);
+		if (ret != 0) {
+			pr_dbg("spi read value timeout:%x ret %d\r\n", rd, ret);
+		}
+		for (j = 0; j < AML_SPI_READ_LEN; j++) {
+			/*pr_dbg("spi read value rb[%d]: 0x%2x\r\n", j, rb[j]);*/
+			ret = aml_ci_spi_paser_bit(rb[j]);
+			if (ret == 0)
+				break;
+		}
 		if (ret == 0)
 			break;
 	}
 	if (ret == 0) {
 		rd = rbuf[3];/* data */
 	} else {
-		pr_dbg("spi read value error\r\n");
-		rd = 0;
+		pr_dbg("*spi rec flag[%d]index [%d] read error[0x%x] mode[%d]addr[%d]****\r\n",
+			G_rec_flag, i,rd, mode, (val[5] << 8 | val[4]) & 0xffff);
+		dirspi_stop(spi_dev->spi);
+		//only retry once
+		if (is_retry == 0) {
+			is_retry = 1;
+			goto restart;
+		}
 	}
-
 	if (spi_dev->cs_clk_delay)
 		udelay(spi_dev->cs_clk_delay);
 
@@ -263,7 +288,7 @@ static int aml_set_gpio_out(struct gpio_desc *gpio, int val)
 	pr_dbg("dvb ci gpio out ret %d set val:%d\n", ret, val);
 	return ret;
 }
-#if 0
+#if 0//no used
 /**\brief aml_set_gpio_in:set gio in
 * \param gpio: gpio_desc obj,
 * \return
@@ -351,7 +376,7 @@ char *str, int input_output, int output_level)
 /*******             gpio api end           *************/
 /********************************************************/
 /********************************************************/
-#if 0
+#if 1
 /**\brief aml_ci_cis_test_by_spi:test cis
 * \param ci_dev: aml_ci obj,used this data to get spi_dev obj
 * \param slot: slot index
@@ -468,6 +493,76 @@ static int aml_ci_io_write_by_spi(
 }
 
 
+/**\brief aml_ci_rst_by_spi:reset cam by spi
+* \param ci_dev: aml_ci obj,used this data to get spi_dev obj
+* \param slot: slot index
+* \return
+*   - 0:ok
+*   - -EINVAL : error
+*/
+static int aml_ci_rst_by_spi(
+	struct aml_ci *ci_dev, int slot, int level)
+{
+	u8  data = (u8)level;
+	u16 addres = 0;
+	int value = 0;
+	struct aml_spi *spi_dev = ci_dev->data;
+	/*add by chl,need add time delay*/
+	mdelay(10);
+	aml_init_send_buf(AM_CI_CMD_RESET, data, addres);
+	value = aml_spi_io_api(spi_dev, sendbuf, SENDBUFLEN, AM_CI_CMD_RESET);
+	return value;
+}
+
+/**\brief aml_ci_power_by_spi:power cam by spi
+* \param ci_dev: aml_ci obj,used this data to get spi_dev obj
+* \param slot: slot index
+* \param enable: enable or disable cam
+* \return
+*   - 0:ok
+*   - -EINVAL : error
+*/
+static int aml_ci_power_by_spi(
+	struct aml_ci *ci_dev, int slot, int enable)
+{
+	u8  data = (u8)enable;
+	u16 addres = 0;
+	int value = 0;
+	struct aml_spi *spi_dev = ci_dev->data;
+	/*add by chl,need add time delay*/
+	/*power is controled by mcu*/
+	if (0) {
+		mdelay(10);
+		aml_init_send_buf(AM_CI_CMD_POWER, data, addres);
+		value = aml_spi_io_api(spi_dev, sendbuf, SENDBUFLEN, AM_CI_CMD_POWER);
+	}
+	return value;
+}
+
+/**\brief aml_ci_getcd12_by_spi:get cd12 cam by spi
+* \param ci_dev: aml_ci obj,used this data to get spi_dev obj
+* \param slot: slot index
+* \param cd12: cd1 or cd2 value
+* \return
+*   - 0:ok
+*   - -EINVAL : error
+*/
+static int aml_ci_getcd12_by_spi(
+	struct aml_ci *ci_dev, int slot, int cd12)
+{
+	u8  data = (u8)cd12;
+	u16 addres = 0;
+	int value = 0;
+	struct aml_spi *spi_dev = ci_dev->data;
+	/*add by chl,need add time delay*/
+	mdelay(10);
+	aml_init_send_buf(AM_CI_CMD_GETCD12, data, addres);
+	value = aml_spi_io_api(spi_dev, sendbuf, SENDBUFLEN, AM_CI_CMD_GETCD12);
+	return value;
+}
+
+
+
 /**\brief aml_ci_slot_reset:reset slot
 * \param ci_dev: aml_ci obj,used this data to get spi_dev obj
 * \param slot: slot index
@@ -480,7 +575,7 @@ static int aml_ci_slot_reset(struct aml_ci *ci_dev, int slot)
 	struct aml_spi *spi_dev = ci_dev->data;
 	pr_dbg("Slot(%d): Slot RESET\n", slot);
 	aml_pcmcia_reset(&spi_dev->pc);
-	dvb_ca_en50221_camready_irq(&ci_dev->en50221, 0);
+	dvb_ca_en50221_cimcu_camready_irq(&ci_dev->en50221_cimcu, 0);
 	return 0;
 }
 /**\brief aml_ci_slot_shutdown:show slot
@@ -532,7 +627,7 @@ static int aml_ci_slot_status(struct aml_ci *ci_dev, int slot, int open)
 	}
 	return -EINVAL;
 }
-#if 0
+#if 1
 /**\brief aml_ci_gio_get_irq:get gpio cam irq pin value
 * \return
 *   - irq pin value
@@ -541,7 +636,12 @@ static int aml_ci_slot_status(struct aml_ci *ci_dev, int slot, int open)
 static int aml_ci_gio_get_irq(void)
 {
 	int ret = 0;
-	ret = aml_get_gpio_value(g_spi_dev->irq_cam_pin);
+	if (g_spi_dev->io_device_type == AML_DVB_IO_TYPE_SPI)
+		ret = aml_get_gpio_value(g_spi_dev->irq_cam_pin);
+	else if (g_spi_dev->io_device_type == AML_DVB_IO_TYPE_SPI)
+		ret = aml_get_gpio_value(g_spi_dev->mcu_irq_pin);
+	else
+		pr_error("aml_ci_gio_get_irq io type not surport\n");
 	return ret;
 }
 #endif
@@ -567,12 +667,19 @@ static int aml_gio_power(struct aml_pcmcia *pc, int enable)
 		return -1;
 	}
 	pr_dbg("%s : %d\r\n", __func__, enable);
-	if (enable == AML_PWR_OPEN) {
+	if (spi_dev->io_device_type == AML_DVB_IO_TYPE_SPI) {
+		if (enable == AML_PWR_OPEN) {
 		/*hi level ,open power*/
 		ret = aml_set_gpio_out(spi_dev->pwr_pin, AML_GPIO_HIGH);
+		} else {
+			/*low level ,close power*/
+			ret = aml_set_gpio_out(spi_dev->pwr_pin, AML_GPIO_LOW);
+		}
+	} else if (spi_dev->io_device_type == AML_DVB_IO_TYPE_SPI_T312) {
+		//no need power cam,we power cam card on MCU.
+		aml_ci_power_by_spi((struct aml_ci *)spi_dev->priv, 0, enable);
 	} else {
-		/*low level ,close power*/
-		ret = aml_set_gpio_out(spi_dev->pwr_pin, AML_GPIO_LOW);
+		pr_dbg("aml_gio_power type [%d] enable: %d\r\n", spi_dev->io_device_type, enable);
 	}
 	return ret;
 }
@@ -588,11 +695,25 @@ static int aml_gio_reset(struct aml_pcmcia *pc, int enable)
 	/*need set hi and sleep set low*/
 	int ret = 0;
 	struct aml_spi *spi_dev = pc->priv;
-	pr_dbg("%s : %d\r\n", __func__, enable);
-	if (enable == AML_L)
-		ret = aml_set_gpio_out(spi_dev->reset_pin, AML_GPIO_LOW);
-	else
-		ret = aml_set_gpio_out(spi_dev->reset_pin, AML_GPIO_HIGH);
+
+	if (spi_dev != NULL)
+		pr_dbg("%s : %d  \r\n", __func__, enable);
+
+	pr_dbg("%s : %d  type: %d\r\n", __func__, enable, spi_dev->io_device_type);
+	if (spi_dev->io_device_type == AML_DVB_IO_TYPE_SPI) {
+		if (enable == AML_L)
+			ret = aml_set_gpio_out(spi_dev->reset_pin, AML_GPIO_LOW);
+		else
+			ret = aml_set_gpio_out(spi_dev->reset_pin, AML_GPIO_HIGH);
+	} else if (spi_dev->io_device_type == AML_DVB_IO_TYPE_SPI_T312) {
+		if (spi_dev == NULL || spi_dev->priv == NULL) {
+			pr_dbg("rst by spi-spidev-null-\r\n");
+			return -1;
+		}
+		aml_ci_rst_by_spi((struct aml_ci *)spi_dev->priv, 0, enable);
+	} else {
+		pr_dbg("aml_gio_power type [%d] enable: %d\r\n", spi_dev->io_device_type, enable);
+	}
 	return ret;
 }
 
@@ -605,17 +726,17 @@ static int aml_gio_reset(struct aml_pcmcia *pc, int enable)
 */
 /*need change*/
 static int aml_gio_init_irq(struct aml_pcmcia *pc, int flag)
-	{
+{
 		struct aml_spi *spi_dev = (struct aml_spi *)pc->priv;
-	
+
 #if 0
 		int cd1_pin = desc_to_gpio(spi_dev->cd_pin1);
-	
+
 		int irq = pc->irq-AML_CI_GPIO_IRQ_BASE;
-	
+
 		printk("----cd1_pin=%d irq=%d\r\n", cd1_pin, irq);
 		aml_set_gpio_in(spi_dev->cd_pin1);
-	
+
 		if (flag == IRQF_TRIGGER_RISING)
 			gpio_for_irq(cd1_pin,
 				AML_GPIO_IRQ(irq, FILTER_NUM7, GPIO_IRQ_RISING));
@@ -631,10 +752,15 @@ static int aml_gio_init_irq(struct aml_pcmcia *pc, int flag)
 		else
 			return -1;
 #endif
+	if (spi_dev->io_device_type == AML_DVB_IO_TYPE_SPI) {
 		gpiod_to_irq(spi_dev->cd_pin1);
-	
-		return 0;
+	} else if (spi_dev->io_device_type == AML_DVB_IO_TYPE_SPI_T312) {
+		gpiod_to_irq(spi_dev->mcu_irq_pin);
+	} else {
+		pr_dbg("aml_gio_init_irq type [%d] \r\n", spi_dev->io_device_type);
 	}
+	return 0;
+}
 
 /**\brief aml_gio_get_cd1:get gpio cd1 pin value
 * \param pc: aml_pcmcia obj,used this priv to get spi_dev obj
@@ -644,9 +770,15 @@ static int aml_gio_init_irq(struct aml_pcmcia *pc, int flag)
 */
 static int aml_gio_get_cd1(struct aml_pcmcia *pc)
 {
-	int ret = 0;
+	int ret = 1;
 	struct aml_spi *spi_dev = pc->priv;
-	ret = aml_get_gpio_value(spi_dev->cd_pin1);
+	if (spi_dev->io_device_type == AML_DVB_IO_TYPE_SPI) {
+		ret = aml_get_gpio_value(spi_dev->cd_pin1);
+	} else if (spi_dev->io_device_type == AML_DVB_IO_TYPE_SPI_T312) {
+		ret = aml_ci_getcd12_by_spi((struct aml_ci *)spi_dev->priv, 0, 0);
+	} else {
+		pr_dbg("aml_gio_get_cd1 not surport type [%d] \r\n", spi_dev->io_device_type);
+	}
 	return ret;
 }
 /**\brief aml_gio_get_cd2:get gpio cd2 pin value
@@ -659,8 +791,13 @@ static int aml_gio_get_cd2(struct aml_pcmcia *pc)
 {
 	int ret = 0;
 	struct aml_spi *spi_dev = pc->priv;
-	ret = aml_get_gpio_value(spi_dev->cd_pin2);
-	pr_dbg("%s : %d\r\n", __func__, ret);
+	if (spi_dev->io_device_type == AML_DVB_IO_TYPE_SPI) {
+		ret = aml_get_gpio_value(spi_dev->cd_pin2);
+	} else if (spi_dev->io_device_type == AML_DVB_IO_TYPE_SPI_T312) {
+		ret = aml_ci_getcd12_by_spi((struct aml_ci *)spi_dev->priv, 0, 1);
+	} else {
+		pr_dbg("aml_gio_get_cd2 not surport type [%d] \r\n", spi_dev->io_device_type);
+	}
 	return ret;
 }
 /**\brief aml_cam_plugin:notify en50221 cam card in or out
@@ -676,10 +813,10 @@ static int aml_cam_plugin(struct aml_pcmcia *pc, int plugin)
 	((struct aml_spi *)(pc->priv))->priv;
 	pr_dbg("%s : %d\r\n", __func__, plugin);
 	if (plugin) {
-		dvb_ca_en50221_camchange_irq(&ci->en50221,
+		dvb_ca_en50221_cimcu_camchange_irq(&ci->en50221_cimcu,
 			0, DVB_CA_EN50221_CAMCHANGE_INSERTED);
 	} else {
-		dvb_ca_en50221_camchange_irq(&ci->en50221,
+		dvb_ca_en50221_cimcu_camchange_irq(&ci->en50221_cimcu,
 			0, DVB_CA_EN50221_CAMCHANGE_REMOVED);
 	}
 	return 0;
@@ -706,6 +843,7 @@ static void aml_pcmcia_alloc(struct aml_spi *spi_dev,
 	(*pcmcia)->slot_state = MODULE_XTRACTED;
 	(*pcmcia)->priv = spi_dev;
 	(*pcmcia)->run_type = 0;/*0:irq;1:poll*/
+	(*pcmcia)->io_device_type = AML_DVB_IO_TYPE_CIMAX;
 }
 
 /**\brief aml_spi_get_config_from_dts:get spi config and gpio config from dts
@@ -776,62 +914,79 @@ static int aml_spi_get_config_from_dts(struct aml_spi *spi_dev)
 		spi_dev->write_check = 0;
 	else
 		spi_dev->write_check = (unsigned char)val;
-	/*get  cd1 irq num*/
-	ret = of_property_read_u32(child, "irq_cd1", &val);
-	if (ret) {
-		spi_dev->irq = 5;
-	} else {
-		/*set irq value need add
-		AML_CI_GPIO_IRQ_BASE,but
-		we need minus
-		AML_CI_GPIO_IRQ_BASE
-		when gpio request irq */
-		spi_dev->irq = val+AML_CI_GPIO_IRQ_BASE;
-	}
 
-	spi_dev->irq = irq_of_parse_and_map(
-	pdev->dev.of_node, 0);
-	AML_CI_GPIO_IRQ_BASE = spi_dev->irq - val;
-	pr_dbg("get spi irq : %d  0:%d USEDBASE:%d val:%d\r\n",
-		spi_dev->irq, INT_GPIO_0, AML_CI_GPIO_IRQ_BASE, val);
-	/*get reset pwd cd1 cd2 gpio pin*/
-	spi_dev->reset_pin = NULL;
-	ret = spi_get_gpio_by_name(spi_dev, &spi_dev->reset_pin,
-	&spi_dev->reset_pin_value, "reset_pin",
-	OUTPUT, OUTLEVEL_HIGH);
-	if (ret) {
-		pr_error("dvb ci reset pin request failed\n");
-		return -1;
-	}
-	spi_dev->cd_pin1 = NULL;
-	ret = spi_get_gpio_by_name(spi_dev,
-		&spi_dev->cd_pin1,
-		&spi_dev->cd_pin1_value, "cd_pin1",
-		INPUT, OUTLEVEL_HIGH);
-	if (ret) {
-		pr_error("dvb ci cd_pin1 pin request failed\n");
-		return -1;
-	}
-	spi_dev->cd_pin2 = spi_dev->cd_pin1;
-	spi_dev->cd_pin2_value = spi_dev->cd_pin1_value;
-	spi_dev->pwr_pin = NULL;
-	pr_dbg("spi_dev->cd_pin1_value==%d\r\n", spi_dev->cd_pin1_value);
-	ret = spi_get_gpio_by_name(spi_dev,
-		&spi_dev->pwr_pin, &spi_dev->pwr_pin_value,
-		"pwr_pin", OUTPUT, OUTLEVEL_HIGH);
-	if (ret) {
-		pr_error("dvb ci pwr_pin pin request failed\n");
-		return -1;
-	}
-	spi_dev->irq_cam_pin = NULL;
-	ret = spi_get_gpio_by_name(spi_dev,
-		&spi_dev->irq_cam_pin, &spi_dev->irq_cam_pin_value,
-		"irq_cam_pin", INPUT, OUTLEVEL_HIGH);
-	if (ret) {
-		pr_error("dvbci  irq_cam_pin pin request failed\n");
-		return -1;
-	}
+	//below is get cd1 cd2 pwr irq reset gpio info
+	if (spi_dev->io_device_type == AML_DVB_IO_TYPE_SPI) {
+		/*get  cd1 irq num*/
+		ret = of_property_read_u32(child, "irq_cd1", &val);
+		if (ret) {
+			spi_dev->irq = 5;
+		} else {
+			/*set irq value need add
+			AML_CI_GPIO_IRQ_BASE,but
+			we need minus
+			AML_CI_GPIO_IRQ_BASE
+			when gpio request irq */
+			spi_dev->irq = val+AML_CI_GPIO_IRQ_BASE;
+		}
 
+		spi_dev->irq = irq_of_parse_and_map(
+		pdev->dev.of_node, 0);
+		AML_CI_GPIO_IRQ_BASE = spi_dev->irq - val;
+		pr_dbg("get spi irq : %d  0:%d USEDBASE:%d val:%d\r\n",
+			spi_dev->irq, INT_GPIO_0, AML_CI_GPIO_IRQ_BASE, val);
+		/*get reset pwd cd1 cd2 gpio pin*/
+		spi_dev->reset_pin = NULL;
+		ret = spi_get_gpio_by_name(spi_dev, &spi_dev->reset_pin,
+		&spi_dev->reset_pin_value, "reset_pin",
+		OUTPUT, OUTLEVEL_HIGH);
+		if (ret) {
+			pr_error("dvb ci reset pin request failed\n");
+			return -1;
+		}
+		spi_dev->cd_pin1 = NULL;
+		ret = spi_get_gpio_by_name(spi_dev,
+			&spi_dev->cd_pin1,
+			&spi_dev->cd_pin1_value, "cd_pin1",
+			INPUT, OUTLEVEL_HIGH);
+		if (ret) {
+			pr_error("dvb ci cd_pin1 pin request failed\n");
+			return -1;
+		}
+		spi_dev->cd_pin2 = spi_dev->cd_pin1;
+		spi_dev->cd_pin2_value = spi_dev->cd_pin1_value;
+		spi_dev->pwr_pin = NULL;
+		pr_dbg("spi_dev->cd_pin1_value==%d\r\n", spi_dev->cd_pin1_value);
+		ret = spi_get_gpio_by_name(spi_dev,
+			&spi_dev->pwr_pin, &spi_dev->pwr_pin_value,
+			"pwr_pin", OUTPUT, OUTLEVEL_HIGH);
+		if (ret) {
+			pr_error("dvb ci pwr_pin pin request failed\n");
+			return -1;
+		}
+		spi_dev->irq_cam_pin = NULL;
+		ret = spi_get_gpio_by_name(spi_dev,
+			&spi_dev->irq_cam_pin, &spi_dev->irq_cam_pin_value,
+			"irq_cam_pin", INPUT, OUTLEVEL_HIGH);
+		if (ret) {
+			pr_error("dvbci  irq_cam_pin pin request failed\n");
+			return -1;
+		}
+	} else if (spi_dev->io_device_type == AML_DVB_IO_TYPE_SPI_T312) {
+		//get mcu irq gpio
+		spi_dev->mcu_irq_pin = NULL;
+		ret = spi_get_gpio_by_name(spi_dev,
+			&spi_dev->mcu_irq_pin,
+			&spi_dev->mcu_irq_pin_value, "mcu_irq_pin",
+			INPUT, OUTLEVEL_HIGH);
+		if (ret) {
+			pr_error("dvb ci mcu_irq_pin pin request failed\n");
+			return -1;
+		}
+		spi_dev->irq = gpiod_to_irq(spi_dev->mcu_irq_pin) ;
+	} else {
+		pr_error("dvbci  io device type error [%d]\n", spi_dev->io_device_type);
+	}
 	return 0;
 }
 /**\brief aml_ci_free_gpio:free ci gpio
@@ -877,7 +1032,8 @@ static void aml_ci_free_gpio(struct aml_spi *spi_dev)
 static int ci_spi_dev_probe(struct spi_device *spi)
 {
 	int ret;
-	pr_dbg("spi Dev probe--\n");
+	pr_dbg("spi Dev probe--\r\n");
+	spin_lock(&(g_spi_dev->spi_lock));
 	if (g_spi_dev)
 		g_spi_dev->spi = spi;
 	 else
@@ -886,6 +1042,7 @@ static int ci_spi_dev_probe(struct spi_device *spi)
 	ret = spi_setup(spi);
 	if (ret)
 		pr_dbg("spi setup failed\n");
+	spin_unlock(&(g_spi_dev->spi_lock));
 	return ret;
 }
 /**\brief ci_spi_dev_remove:spi remove api
@@ -933,21 +1090,27 @@ int aml_spi_init(struct platform_device *pdev, struct aml_ci *ci_dev)
 	g_spi_dev = spi_dev;
 	spi_dev->pdev = pdev;
 	spi_dev->priv = ci_dev;
+	spi_dev->spi = NULL;
+	/*init io device type*/
+	spi_dev->io_device_type = ci_dev->io_type;
+	pr_dbg("*********spi Dev type [%d]\n", ci_dev->io_type);
 	/*get config from dts*/
 	aml_spi_get_config_from_dts(spi_dev);
+
+	/*init spi_lock*/
+	spin_lock_init(&(spi_dev->spi_lock));
 	/*regist api dev*/
-	spi_register_board_info(spi_dev->spi_bdinfo, 1);
+	pr_dbg("*********spi Dev regist**********\r\n");
+	result = spi_register_board_info(spi_dev->spi_bdinfo, 1);
+	if (result) {
+		pr_error("register amlspi_dev spi boardinfo failed\n");
+		goto fail1;
+	}
 	result = spi_register_driver(&ci_spi_dev_driver);
 	if (result) {
 		pr_error("register amlspi_dev spi driver failed\n");
 		goto fail1;
 	}
-	aml_pcmcia_alloc(spi_dev, &pc);
-	result = aml_pcmcia_init(pc);
-	if (result < 0) {
-		pr_error("aml_pcmcia_init failed\n");
-		goto fail2;
-	}
 
 	/*init ci_dev used api.*/
 	ci_dev->ci_mem_read  = aml_ci_mem_read_by_spi;
@@ -959,8 +1122,14 @@ int aml_spi_init(struct platform_device *pdev, struct aml_ci *ci_dev)
 	ci_dev->ci_slot_ts_enable = aml_ci_ts_control;
 	ci_dev->ci_poll_slot_status = aml_ci_slot_status;
 	ci_dev->data = spi_dev;
-	/*init spi_lock*/
-	spin_lock_init(&(spi_dev->spi_lock));
+
+	aml_pcmcia_alloc(spi_dev, &pc);
+	pc->io_device_type = spi_dev->io_device_type;
+	result = aml_pcmcia_init(pc);
+	if (result < 0) {
+		pr_error("aml_pcmcia_init failed\n");
+		goto fail2;
+	}
 	return 0;
 fail2:
 	spi_unregister_driver(&ci_spi_dev_driver);
@@ -993,7 +1162,7 @@ int aml_spi_exit(struct aml_ci *ci)
 EXPORT_SYMBOL(aml_spi_exit);
 
 
-#if 0
+#if 1
 /********************************************************/
 /********************************************************/
 /*******        for spi test api            *************/
@@ -1545,6 +1714,7 @@ static ssize_t aml_spi_io_test(struct class *class,
 struct class_attribute *attr, const char *buf, size_t size)
 {
 	int n = 0;
+	int i = 0;
 	char *buf_orig, *ps, *token;
 	char *parm[3];
 	unsigned int addr = 0, val = 0, retval = 0;
@@ -1554,7 +1724,7 @@ struct class_attribute *attr, const char *buf, size_t size)
 	ps = buf_orig;
 	while (1) {
 		/*need set '\n' to ' \n'*/
-		token = strsep(&ps, "\n");
+		token = strsep(&ps, " ");
 		if (token == NULL)
 			break;
 		if (*token == '\0')
@@ -1563,13 +1733,13 @@ struct class_attribute *attr, const char *buf, size_t size)
 	}
 
 	if (!n || ((n > 0) && (strlen(parm[0]) != 2))) {
-		pr_err("invalid command\n");
+		pr_err("invalid command n[%x]p[%x][%s]\n", n,(int)strlen(parm[0]),parm[0]);
 		kfree(buf_orig);
 		return size;
 	}
 
 	if ((parm[0][0] == 'r')) {
-		if (n != 2) {
+		if (n > 2) {
 			pr_err("read: invalid parameter\n");
 			kfree(buf_orig);
 			return size;
@@ -1577,16 +1747,18 @@ struct class_attribute *attr, const char *buf, size_t size)
 	if (kstrtol(parm[1], 0, &value) == 0)
 		addr = (int)value;
 		pr_err("%s 0x%x\n", parm[0], addr);
-	/*	switch ((char)parm[0][1]) {
+		switch ((char)parm[0][1]) {
 			case 'i':
-				retval = aml_ci_io_read_by_spi(ci, 0, addr);
+				for (i = 0; i < 1000; i++)
+					retval = aml_ci_io_read_by_spi(ci, 0, addr);
 				break;
 			case 'a':
-				retval = aml_ci_mem_read_by_spi(ci, 0, addr);
+				for (i = 0; i < 1000; i++)
+					retval = aml_ci_mem_read_by_spi(ci, 0, addr);
 				break;
 			default:
 				break;
-		}*/
+		}
 		pr_dbg("%s: 0x%x --> 0x%x\n", parm[0], addr, retval);
 	} else if ((parm[0][0] == 'w')) {
 		if (n != 3) {
@@ -1645,20 +1817,44 @@ static struct class aml_spi_class = {
 	.class_attrs = aml_spi_class_attrs,
 };
 
-static int  aml_spi_mod_init(void)
+
+/**\brief aml_con_gpio_by_spi:control gpio by spi
+* \param gpio: the value is from AM_CON_GPIO def
+* \param level: 0: set low,1:set hight
+* \return
+*   - 0:ok
+*   - -EINVAL : error
+*/
+int aml_con_gpio_by_spi(int gpio, int level)
+{
+	u8  data = gpio;
+	u16 addres = level;
+	int value = 0;
+	struct aml_spi *spi_dev = g_spi_dev;
+	/*add by chl,need add time delay*/
+	mdelay(10);
+	aml_init_send_buf(AM_CI_CMD_CONGPIO, data, addres);
+	value = aml_spi_io_api(spi_dev, sendbuf, SENDBUFLEN, AM_CI_CMD_CONGPIO);
+	return value;
+}
+EXPORT_SYMBOL(aml_con_gpio_by_spi);
+
+int  aml_spi_mod_init(void)
 {
 	int ret;
 	pr_dbg("Amlogic DVB SPI Init\n");
 	ret = class_register(&aml_spi_class);
 	return 0;
 }
-
-static void  aml_spi_mod_exit(void)
+//EXPORT_SYMBOL(aml_spi_mod_init);
+void  aml_spi_mod_exit(void)
 {
 	pr_dbg("Amlogic DVB SPI Exit\n");
 	class_unregister(&aml_spi_class);
 }
-
+EXPORT_SYMBOL(aml_spi_mod_exit);
+#endif
+#if 0
 module_init(aml_spi_mod_init);
 module_exit(aml_spi_mod_exit);
 
diff --git a/drivers/stream_input/parser/dvb_ci/aml_spi.h b/drivers/stream_input/parser/dvb_ci/aml_spi.h
index 1b04caf..12eff6d 100644
--- a/drivers/stream_input/parser/dvb_ci/aml_spi.h
+++ b/drivers/stream_input/parser/dvb_ci/aml_spi.h
@@ -30,35 +30,40 @@
 aml spi dev
 */
 struct aml_spi {
-		spinlock_t spi_lock;
+	spinlock_t spi_lock;
 
-		/* add SPI DEV */
-		struct spi_board_info *spi_bdinfo;
-		struct spi_device *spi;
-		struct platform_device *pdev;
-		struct device *dev;
+	/* add SPI DEV */
+	struct spi_board_info *spi_bdinfo;
+	struct spi_device *spi;
+	struct platform_device *pdev;
+	struct device *dev;
 
-		/* spi otherconfig */
-		int cs_hold_delay;
-		int cs_clk_delay;
-		int write_check;
+	/* spi otherconfig */
+	int cs_hold_delay;
+	int cs_clk_delay;
+	int write_check;
 
-		/* add gpio pin */
-		struct gpio_desc *reset_pin;
-		int reset_pin_value;
-		struct gpio_desc *cd_pin1;
-		int cd_pin1_value;
-		struct gpio_desc *cd_pin2;
-		int cd_pin2_value;
-		struct gpio_desc *pwr_pin;
-		int pwr_pin_value;
+	/* add gpio pin */
+	struct gpio_desc *reset_pin;
+	int reset_pin_value;
+	struct gpio_desc *cd_pin1;
+	int cd_pin1_value;
+	struct gpio_desc *cd_pin2;
+	int cd_pin2_value;
+	struct gpio_desc *pwr_pin;
+	int pwr_pin_value;
 
-		/* cam and mcu irq */
-		struct gpio_desc *irq_cam_pin;
-		int irq_cam_pin_value;
-		int irq;
-		struct aml_pcmcia pc;
-		void *priv;
+	/* cam and mcu irq */
+	struct gpio_desc *irq_cam_pin;
+	int irq_cam_pin_value;
+	int irq;
+	struct aml_pcmcia pc;
+	void *priv;
+	/*for AML_DVB_IO_TYPE_SPI_T312 device*/
+	struct gpio_desc *mcu_irq_pin;
+	int mcu_irq_pin_value;
+	/*device type*/
+	int io_device_type;
 };
 enum aml_gpio_level_e {
 		AML_GPIO_LOW = 0,
@@ -74,7 +79,11 @@ enum AM_CI_CMD {
 		AM_CI_CMD_MEMR,
 		AM_CI_CMD_MEMW,
 		AM_CI_CMD_FULLTEST,
-		AM_CI_CMD_CISTEST
+		AM_CI_CMD_CISTEST,
+		AM_CI_CMD_GETCD12,
+		AM_CI_CMD_POWER,
+		AM_CI_CMD_RESET,
+		AM_CI_CMD_CONGPIO,
 };
 enum AM_SPI_RECIVERSTEP {
 		AM_SPI_STEP_INIT = 0,
@@ -87,6 +96,16 @@ enum AM_SPI_RECIVERSTEP {
 		AM_SPI_STEP_END1,
 		AM_SPI_STEP_END2
 };
+
+enum AM_CON_GPIO
+{
+	AM_CONGPIO_SEL_LVDS = 0,
+	AM_CONGPIO_SCN_EN,
+	AM_CONGPIO_LD_EN2,
+	AM_CONGPIO_2D3D,
+	AM_CONGPIO_AMP_RST,
+};
+
 extern int dirspi_xfer(struct spi_device *spi, u8 *tx_buf, u8 *rx_buf,
 		       int len);
 extern int dirspi_write(struct spi_device *spi, u8 *buf, int len);
@@ -96,5 +115,7 @@ extern void dirspi_stop(struct spi_device *spi);
 extern void dvb_ca_en50221_camready_irq(struct dvb_ca_en50221 *pubca, int slot);
 extern int aml_spi_init(struct platform_device *pdev, struct aml_ci *ci_dev);
 extern int aml_spi_exit(struct aml_ci *ci_dev);
+extern int aml_spi_mod_init(void);
+extern void aml_spi_mod_exit(void);
 
 #endif				/* __AML_SPI_H_ */
diff --git a/drivers/stream_input/parser/dvb_ci/cimcu/dvb_ca_en50221_cimcu.c b/drivers/stream_input/parser/dvb_ci/cimcu/dvb_ca_en50221_cimcu.c
new file mode 100644
index 0000000..762f5ff
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimcu/dvb_ca_en50221_cimcu.c
@@ -0,0 +1,1967 @@
+/*
+ * dvb_ca.c: generic DVB functions for EN50221 CAM interfaces
+ *
+ * Copyright (C) 2004 Andrew de Quincey
+ *
+ * Parts of this file were based on sources as follows:
+ *
+ * Copyright (C) 2003 Ralph Metzler <rjkm@metzlerbros.de>
+ *
+ * based on code:
+ *
+ * Copyright (C) 1999-2002 Ralph  Metzler
+ *                       & Marcus Metzler for convergence integrated media GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+
+#include "dvb_ca_en50221_cimcu.h"
+#include "../cimax/dvb_ringbuffer.h"
+
+#define READ_LPDU_PKT
+
+static int dvb_ca_en50221_debug;
+
+module_param_named(cammcu_debug, dvb_ca_en50221_debug, int, 0644);
+MODULE_PARM_DESC(cammcu_debug, "enable verbose debug messages");
+
+#define dprintk if (dvb_ca_en50221_debug) printk
+
+#define INIT_TIMEOUT_SECS 10
+
+#define HOST_LINK_BUF_SIZE 0x200
+
+#define RX_BUFFER_SIZE 65535
+
+#define MAX_RX_PACKETS_PER_ITERATION 10
+
+#define CTRLIF_DATA      0
+#define CTRLIF_COMMAND   1
+#define CTRLIF_STATUS    1
+#define CTRLIF_SIZE_LOW  2
+#define CTRLIF_SIZE_HIGH 3
+
+#define CMDREG_HC        1	/* Host control */
+#define CMDREG_SW        2	/* Size write */
+#define CMDREG_SR        4	/* Size read */
+#define CMDREG_RS        8	/* Reset interface */
+#define CMDREG_FRIE   0x40	/* Enable FR interrupt */
+#define CMDREG_DAIE   0x80	/* Enable DA interrupt */
+#define IRQEN (CMDREG_DAIE)
+
+#define STATUSREG_RE     1	/* read error */
+#define STATUSREG_WE     2	/* write error */
+#define STATUSREG_FR  0x40	/* module free */
+#define STATUSREG_DA  0x80	/* data available */
+#define STATUSREG_TXERR (STATUSREG_RE|STATUSREG_WE)	/* general transfer error */
+
+
+#define DVB_CA_SLOTSTATE_NONE           0
+#define DVB_CA_SLOTSTATE_UNINITIALISED  1
+#define DVB_CA_SLOTSTATE_RUNNING        2
+#define DVB_CA_SLOTSTATE_INVALID        3
+#define DVB_CA_SLOTSTATE_WAITREADY      4
+#define DVB_CA_SLOTSTATE_VALIDATE       5
+#define DVB_CA_SLOTSTATE_WAITFR         6
+#define DVB_CA_SLOTSTATE_LINKINIT       7
+
+
+/* Information on a CA slot */
+struct dvb_ca_slot {
+
+	/* current state of the CAM */
+	int slot_state;
+
+	/* mutex used for serializing access to one CI slot */
+	struct mutex slot_lock;
+
+	/* Number of CAMCHANGES that have occurred since last processing */
+	atomic_t camchange_count;
+
+	/* Type of last CAMCHANGE */
+	int camchange_type;
+
+	/* base address of CAM config */
+	u32 config_base;
+
+	/* value to write into Config Control register */
+	u8 config_option;
+
+	/* if 1, the CAM supports DA IRQs */
+	u8 da_irq_supported:1;
+
+#ifdef READ_LPDU_PKT
+	/* Offset into current ringbuffer when user buffer was not big enough
+	   to return entire pkt */
+	int rx_offset;
+#endif
+
+	/* size of the buffer to use when talking to the CAM */
+	int link_buf_size;
+
+	/* buffer for incoming packets */
+	struct dvb_ringbuffer rx_buffer;
+
+	/* timer used during various states of the slot */
+	unsigned long timeout;
+};
+
+/* Private CA-interface information */
+struct dvb_ca_private {
+	struct kref refcount;
+
+	/* pointer back to the public data structure */
+	struct dvb_ca_en50221_cimcu *pub;
+
+	/* the DVB device */
+	struct dvb_device *dvbdev;
+
+	/* Flags describing the interface (DVB_CA_FLAG_*) */
+	u32 flags;
+
+	/* number of slots supported by this CA interface */
+	unsigned int slot_count;
+
+	/* information on each slot */
+	struct dvb_ca_slot *slot_info;
+
+	/* wait queues for read() and write() operations */
+	wait_queue_head_t wait_queue;
+
+	/* PID of the monitoring thread */
+	struct task_struct *thread;
+
+	/* Flag indicating if the CA device is open */
+	unsigned int open:1;
+
+	/* Flag indicating the thread should wake up now */
+	unsigned int wakeup:1;
+
+	/* Delay the main thread should use */
+	unsigned long delay;
+
+	/* Slot to start looking for data to read from in the next user-space read operation */
+	int next_read_slot;
+
+	/* mutex serializing ioctls */
+	struct mutex ioctl_mutex;
+};
+
+static void dvb_ca_private_free(struct dvb_ca_private *ca)
+{
+	unsigned int i;
+
+	dvb_unregister_device(ca->dvbdev);
+	for (i = 0; i < ca->slot_count; i++)
+		vfree(ca->slot_info[i].rx_buffer.data);
+
+	kfree(ca->slot_info);
+	kfree(ca);
+}
+
+static void dvb_ca_private_release(struct kref *ref)
+{
+	struct dvb_ca_private *ca = container_of(ref, struct dvb_ca_private, refcount);
+	dvb_ca_private_free(ca);
+}
+
+static void dvb_ca_private_get(struct dvb_ca_private *ca)
+{
+	kref_get(&ca->refcount);
+}
+
+static void dvb_ca_private_put(struct dvb_ca_private *ca)
+{
+	kref_put(&ca->refcount, dvb_ca_private_release);
+}
+
+static void dvb_ca_en50221_thread_wakeup(struct dvb_ca_private *ca);
+static int dvb_ca_en50221_read_data(struct dvb_ca_private *ca, int slot, u8 * ebuf, int ecount);
+static int dvb_ca_en50221_write_data(struct dvb_ca_private *ca, int slot, u8 * ebuf, int ecount);
+
+
+/**
+ * Safely find needle in haystack.
+ *
+ * @haystack: Buffer to look in.
+ * @hlen: Number of bytes in haystack.
+ * @needle: Buffer to find.
+ * @nlen: Number of bytes in needle.
+ * @return Pointer into haystack needle was found at, or NULL if not found.
+ */
+static char *findstr(char * haystack, int hlen, char * needle, int nlen)
+{
+	int i;
+
+	if (hlen < nlen)
+		return NULL;
+
+	for (i = 0; i <= hlen - nlen; i++) {
+		if (!strncmp(haystack + i, needle, nlen))
+			return haystack + i;
+	}
+
+	return NULL;
+}
+
+
+
+/* ******************************************************************************** */
+/* EN50221 physical interface functions */
+
+
+/**
+ * dvb_ca_en50221_check_camstatus - Check CAM status.
+ */
+static int dvb_ca_en50221_check_camstatus(struct dvb_ca_private *ca, int slot)
+{
+	int slot_status;
+	int cam_present_now;
+	int cam_changed;
+
+	/* IRQ mode */
+	if (ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE) {
+		return (atomic_read(&ca->slot_info[slot].camchange_count) != 0);
+	}
+
+	/* poll mode */
+	slot_status = ca->pub->poll_slot_status(ca->pub, slot, ca->open);
+
+	cam_present_now = (slot_status & DVB_CA_EN50221_POLL_CAM_PRESENT) ? 1 : 0;
+	cam_changed = (slot_status & DVB_CA_EN50221_POLL_CAM_CHANGED) ? 1 : 0;
+	if (!cam_changed) {
+		int cam_present_old = (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_NONE);
+		cam_changed = (cam_present_now != cam_present_old);
+	}
+
+	if (cam_changed) {
+		if (!cam_present_now) {
+			ca->slot_info[slot].camchange_type = DVB_CA_EN50221_CAMCHANGE_REMOVED;
+		} else {
+			ca->slot_info[slot].camchange_type = DVB_CA_EN50221_CAMCHANGE_INSERTED;
+		}
+		atomic_set(&ca->slot_info[slot].camchange_count, 1);
+	} else {
+		if ((ca->slot_info[slot].slot_state == DVB_CA_SLOTSTATE_WAITREADY) &&
+		    (slot_status & DVB_CA_EN50221_POLL_CAM_READY)) {
+			// move to validate state if reset is completed
+			ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_VALIDATE;
+		}
+	}
+
+	return cam_changed;
+}
+
+
+/**
+ * dvb_ca_en50221_wait_if_status - Wait for flags to become set on the STATUS
+ *	 register on a CAM interface, checking for errors and timeout.
+ *
+ * @ca: CA instance.
+ * @slot: Slot on interface.
+ * @waitfor: Flags to wait for.
+ * @timeout_ms: Timeout in milliseconds.
+ *
+ * @return 0 on success, nonzero on error.
+ */
+static int dvb_ca_en50221_wait_if_status(struct dvb_ca_private *ca, int slot,
+					 u8 waitfor, int timeout_hz)
+{
+	unsigned long timeout;
+	unsigned long start;
+
+	dprintk("%s\n", __func__);
+
+	/* loop until timeout elapsed */
+	start = jiffies;
+	timeout = jiffies + timeout_hz;
+	while (1) {
+		/* read the status and check for error */
+		int res = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS);
+		if (res < 0)
+			return -EIO;
+
+		/* if we got the flags, it was successful! */
+		if (res & waitfor) {
+			dprintk("%s succeeded timeout:%lu\n", __func__, jiffies - start);
+			return 0;
+		}
+
+		/* check for timeout */
+		if (time_after(jiffies, timeout)) {
+			break;
+		}
+
+		/* wait for a bit */
+		msleep(1);
+	}
+
+	dprintk("%s failed timeout:%lu\n", __func__, jiffies - start);
+
+	/* if we get here, we've timed out */
+	return -ETIMEDOUT;
+}
+
+
+/**
+ * dvb_ca_en50221_link_init - Initialise the link layer connection to a CAM.
+ *
+ * @ca: CA instance.
+ * @slot: Slot id.
+ *
+ * @return 0 on success, nonzero on failure.
+ */
+static int dvb_ca_en50221_link_init(struct dvb_ca_private *ca, int slot)
+{
+	int ret;
+	int buf_size;
+	u8 buf[2];
+
+	dprintk("%s\n", __func__);
+
+	/* we'll be determining these during this function */
+	ca->slot_info[slot].da_irq_supported = 0;
+#ifdef READ_LPDU_PKT
+	ca->slot_info[slot].rx_offset = 0;
+#endif
+	/* set the host link buffer size temporarily. it will be overwritten with the
+	 * real negotiated size later. */
+	ca->slot_info[slot].link_buf_size = 2;
+
+	/* read the buffer size from the CAM */
+	if ((ret = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_COMMAND, IRQEN | CMDREG_SR)) != 0)
+		return ret;
+	if ((ret = dvb_ca_en50221_wait_if_status(ca, slot, STATUSREG_DA, HZ / 10)) != 0)
+		return ret;
+	if ((ret = dvb_ca_en50221_read_data(ca, slot, buf, 2)) != 2)
+		return -EIO;
+	if ((ret = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_COMMAND, IRQEN)) != 0)
+		return ret;
+
+	/* store it, and choose the minimum of our buffer and the CAM's buffer size */
+	buf_size = (buf[0] << 8) | buf[1];
+	if (buf_size > HOST_LINK_BUF_SIZE)
+		buf_size = HOST_LINK_BUF_SIZE;
+	ca->slot_info[slot].link_buf_size = buf_size;
+	buf[0] = buf_size >> 8;
+	buf[1] = buf_size & 0xff;
+	dprintk("Chosen link buffer size of %i\n", buf_size);
+
+	/* write the buffer size to the CAM */
+	if ((ret = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_COMMAND, IRQEN | CMDREG_SW)) != 0)
+		return ret;
+	if ((ret = dvb_ca_en50221_wait_if_status(ca, slot, STATUSREG_FR, HZ / 10)) != 0)
+		return ret;
+	if ((ret = dvb_ca_en50221_write_data(ca, slot, buf, 2)) != 2)
+		return -EIO;
+	if ((ret = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_COMMAND, IRQEN)) != 0)
+		return ret;
+
+	/* success */
+	return 0;
+}
+
+/**
+ * dvb_ca_en50221_read_tuple - Read a tuple from attribute memory.
+ *
+ * @ca: CA instance.
+ * @slot: Slot id.
+ * @address: Address to read from. Updated.
+ * @tupleType: Tuple id byte. Updated.
+ * @tupleLength: Tuple length. Updated.
+ * @tuple: Dest buffer for tuple (must be 256 bytes). Updated.
+ *
+ * @return 0 on success, nonzero on error.
+ */
+static int dvb_ca_en50221_read_tuple(struct dvb_ca_private *ca, int slot,
+				     int *address, int *tupleType, int *tupleLength, u8 * tuple)
+{
+	int i;
+	int _tupleType;
+	int _tupleLength;
+	int _address = *address;
+
+	/* grab the next tuple length and type */
+	if ((_tupleType = ca->pub->read_attribute_mem(ca->pub, slot, _address)) < 0)
+		return _tupleType;
+	if (_tupleType == 0xff) {
+		dprintk("END OF CHAIN TUPLE type:0x%x\n", _tupleType);
+		*address += 2;
+		*tupleType = _tupleType;
+		*tupleLength = 0;
+		return 0;
+	}
+	if ((_tupleLength = ca->pub->read_attribute_mem(ca->pub, slot, _address + 2)) < 0)
+		return _tupleLength;
+	_address += 4;
+
+	dprintk("TUPLE type:0x%x length:%i\n", _tupleType, _tupleLength);
+
+	/* read in the whole tuple */
+	for (i = 0; i < _tupleLength; i++) {
+		tuple[i] = ca->pub->read_attribute_mem(ca->pub, slot, _address + (i * 2));
+		dprintk("  0x%02x: 0x%02x %c\n",
+			i, tuple[i] & 0xff,
+			((tuple[i] > 31) && (tuple[i] < 127)) ? tuple[i] : '.');
+	}
+	_address += (_tupleLength * 2);
+
+	// success
+	*tupleType = _tupleType;
+	*tupleLength = _tupleLength;
+	*address = _address;
+	return 0;
+}
+
+
+/**
+ * dvb_ca_en50221_parse_attributes - Parse attribute memory of a CAM module,
+ *	extracting Config register, and checking it is a DVB CAM module.
+ *
+ * @ca: CA instance.
+ * @slot: Slot id.
+ *
+ * @return 0 on success, <0 on failure.
+ */
+static int dvb_ca_en50221_parse_attributes(struct dvb_ca_private *ca, int slot)
+{
+	int address = 0;
+	int tupleLength;
+	int tupleType;
+	u8 tuple[257];
+	char *dvb_str;
+	int rasz;
+	int status;
+	int got_cftableentry = 0;
+	int end_chain = 0;
+	int i;
+	u16 manfid = 0;
+	u16 devid = 0;
+
+
+	// CISTPL_DEVICE_0A
+	if ((status =
+	     dvb_ca_en50221_read_tuple(ca, slot, &address, &tupleType, &tupleLength, tuple)) < 0)
+		return status;
+	if (tupleType != 0x1D)
+		return -EINVAL;
+
+
+
+	// CISTPL_DEVICE_0C
+	if ((status =
+	     dvb_ca_en50221_read_tuple(ca, slot, &address, &tupleType, &tupleLength, tuple)) < 0)
+		return status;
+	if (tupleType != 0x1C)
+		return -EINVAL;
+
+
+
+	// CISTPL_VERS_1
+	if ((status =
+	     dvb_ca_en50221_read_tuple(ca, slot, &address, &tupleType, &tupleLength, tuple)) < 0)
+		return status;
+	if (tupleType != 0x15)
+		return -EINVAL;
+
+
+
+	// CISTPL_MANFID
+	if ((status = dvb_ca_en50221_read_tuple(ca, slot, &address, &tupleType,
+						&tupleLength, tuple)) < 0)
+		return status;
+	if (tupleType != 0x20)
+		return -EINVAL;
+	if (tupleLength != 4)
+		return -EINVAL;
+	manfid = (tuple[1] << 8) | tuple[0];
+	devid = (tuple[3] << 8) | tuple[2];
+
+
+
+	// CISTPL_CONFIG
+	if ((status = dvb_ca_en50221_read_tuple(ca, slot, &address, &tupleType,
+						&tupleLength, tuple)) < 0)
+		return status;
+	if (tupleType != 0x1A)
+		return -EINVAL;
+	if (tupleLength < 3)
+		return -EINVAL;
+
+	/* extract the configbase */
+	rasz = tuple[0] & 3;
+	if (tupleLength < (3 + rasz + 14))
+		return -EINVAL;
+	ca->slot_info[slot].config_base = 0;
+	for (i = 0; i < rasz + 1; i++) {
+		ca->slot_info[slot].config_base |= (tuple[2 + i] << (8 * i));
+	}
+
+	/* check it contains the correct DVB string */
+	dvb_str = findstr((char *)tuple, tupleLength, "DVB_CI_V", 8);
+	if (dvb_str == NULL)
+		return -EINVAL;
+	if (tupleLength < ((dvb_str - (char *) tuple) + 12))
+		return -EINVAL;
+
+	/* is it a version we support? */
+	if (strncmp(dvb_str + 8, "1.00", 4)) {
+		printk("dvb_ca adapter %d: Unsupported DVB CAM module version %c%c%c%c\n",
+		       ca->dvbdev->adapter->num, dvb_str[8], dvb_str[9], dvb_str[10], dvb_str[11]);
+		return -EINVAL;
+	}
+
+	/* process the CFTABLE_ENTRY tuples, and any after those */
+	while ((!end_chain) && (address < 0x1000)) {
+		if ((status = dvb_ca_en50221_read_tuple(ca, slot, &address, &tupleType,
+							&tupleLength, tuple)) < 0)
+			return status;
+		switch (tupleType) {
+		case 0x1B:	// CISTPL_CFTABLE_ENTRY
+			if (tupleLength < (2 + 11 + 17))
+				break;
+
+			/* if we've already parsed one, just use it */
+			if (got_cftableentry)
+				break;
+
+			/* get the config option */
+			ca->slot_info[slot].config_option = tuple[0] & 0x3f;
+
+			/* OK, check it contains the correct strings */
+			if ((findstr((char *)tuple, tupleLength, "DVB_HOST", 8) == NULL) ||
+			    (findstr((char *)tuple, tupleLength, "DVB_CI_MODULE", 13) == NULL))
+				break;
+
+			got_cftableentry = 1;
+			break;
+
+		case 0x14:	// CISTPL_NO_LINK
+			break;
+
+		case 0xFF:	// CISTPL_END
+			end_chain = 1;
+			break;
+
+		default:	/* Unknown tuple type - just skip this tuple and move to the next one */
+			dprintk("dvb_ca: Skipping unknown tuple type:0x%x length:0x%x\n", tupleType,
+				tupleLength);
+			break;
+		}
+	}
+
+	if ((address > 0x1000) || (!got_cftableentry))
+		return -EINVAL;
+
+	dprintk("Valid DVB CAM detected MANID:%x DEVID:%x CONFIGBASE:0x%x CONFIGOPTION:0x%x\n",
+		manfid, devid, ca->slot_info[slot].config_base, ca->slot_info[slot].config_option);
+
+	// success!
+	return 0;
+}
+
+
+/**
+ * dvb_ca_en50221_set_configoption - Set CAM's configoption correctly.
+ *
+ * @ca: CA instance.
+ * @slot: Slot containing the CAM.
+ */
+static int dvb_ca_en50221_set_configoption(struct dvb_ca_private *ca, int slot)
+{
+	int configoption;
+
+	dprintk("%s\n", __func__);
+
+	/* set the config option */
+	ca->pub->write_attribute_mem(ca->pub, slot,
+				     ca->slot_info[slot].config_base,
+				     ca->slot_info[slot].config_option);
+
+	/* check it */
+	configoption = ca->pub->read_attribute_mem(ca->pub, slot, ca->slot_info[slot].config_base);
+	dprintk("Set configoption 0x%x, read configoption 0x%x\n",
+		ca->slot_info[slot].config_option, configoption & 0x3f);
+
+	/* fine! */
+	return 0;
+
+}
+
+
+/**
+ * dvb_ca_en50221_read_data - This function talks to an EN50221 CAM control
+ *	interface. It reads a buffer of data from the CAM. The data can either
+ *	be stored in a supplied buffer, or automatically be added to the slot's
+ *	rx_buffer.
+ *
+ * @ca: CA instance.
+ * @slot: Slot to read from.
+ * @ebuf: If non-NULL, the data will be written to this buffer. If NULL,
+ * the data will be added into the buffering system as a normal fragment.
+ * @ecount: Size of ebuf. Ignored if ebuf is NULL.
+ *
+ * @return Number of bytes read, or < 0 on error
+ */
+static int dvb_ca_en50221_read_data(struct dvb_ca_private *ca, int slot, u8 * ebuf, int ecount)
+{
+	int bytes_read;
+	int status;
+	u8 buf[HOST_LINK_BUF_SIZE];
+	int i;
+
+	dprintk("%s\n", __func__);
+
+	/* check if we have space for a link buf in the rx_buffer */
+	if (ebuf == NULL) {
+		int buf_free;
+
+		if (ca->slot_info[slot].rx_buffer.data == NULL) {
+			status = -EIO;
+			goto exit;
+		}
+		buf_free = dvb_ringbuffer_free(&ca->slot_info[slot].rx_buffer);
+
+		if (buf_free < (ca->slot_info[slot].link_buf_size + DVB_RINGBUFFER_PKTHDRSIZE)) {
+			status = -EAGAIN;
+			goto exit;
+		}
+	}
+
+	/* check if there is data available */
+	if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0)
+		goto exit;
+	if (!(status & STATUSREG_DA)) {
+		/* no data */
+		status = 0;
+		goto exit;
+	}
+
+	/* read the amount of data */
+	if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_SIZE_HIGH)) < 0)
+		goto exit;
+	bytes_read = status << 8;
+	if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_SIZE_LOW)) < 0)
+		goto exit;
+	bytes_read |= status;
+
+	/* check it will fit */
+	if (ebuf == NULL) {
+		if (bytes_read > ca->slot_info[slot].link_buf_size) {
+			printk("dvb_ca adapter %d: CAM tried to send a buffer larger than the link buffer size (%i > %i)!\n",
+			       ca->dvbdev->adapter->num, bytes_read, ca->slot_info[slot].link_buf_size);
+			ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
+			status = -EIO;
+			goto exit;
+		}
+		if (bytes_read < 2) {
+			printk("dvb_ca adapter %d: CAM sent a buffer that was less than 2 bytes!\n",
+			       ca->dvbdev->adapter->num);
+			ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
+			status = -EIO;
+			goto exit;
+		}
+	} else {
+		if (bytes_read > ecount) {
+			printk("dvb_ca adapter %d: CAM tried to send a buffer larger than the ecount size!\n",
+			       ca->dvbdev->adapter->num);
+			status = -EIO;
+			goto exit;
+		}
+	}
+
+	/* fill the buffer */
+	for (i = 0; i < bytes_read; i++) {
+		/* read byte and check */
+		if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_DATA)) < 0)
+			goto exit;
+
+		/* OK, store it in the buffer */
+		buf[i] = status;
+	}
+
+	/* check for read error (RE should now be 0) */
+	if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0)
+		goto exit;
+	if (status & STATUSREG_RE) {
+		ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
+		status = -EIO;
+		goto exit;
+	}
+
+	/* OK, add it to the receive buffer, or copy into external buffer if supplied */
+	if (ebuf == NULL) {
+		if (ca->slot_info[slot].rx_buffer.data == NULL) {
+			status = -EIO;
+			goto exit;
+		}
+		dvb_ringbuffer_pkt_write(&ca->slot_info[slot].rx_buffer, buf, bytes_read);
+	} else {
+		memcpy(ebuf, buf, bytes_read);
+	}
+
+	dprintk("Received CA packet for slot %i connection id 0x%x last_frag:%i size:0x%x\n", slot,
+		buf[0], (buf[1] & 0x80) == 0, bytes_read);
+#ifndef READ_LPDU_PKT
+	/* wake up readers when a last_fragment is received */
+	if ((buf[1] & 0x80) == 0x00)
+#endif
+		wake_up_interruptible(&ca->wait_queue);
+	status = bytes_read;
+
+exit:
+	return status;
+}
+
+
+/**
+ * dvb_ca_en50221_write_data - This function talks to an EN50221 CAM control
+ *				interface. It writes a buffer of data to a CAM.
+ *
+ * @ca: CA instance.
+ * @slot: Slot to write to.
+ * @ebuf: The data in this buffer is treated as a complete link-level packet to
+ * be written.
+ * @count: Size of ebuf.
+ *
+ * @return Number of bytes written, or < 0 on error.
+ */
+static int dvb_ca_en50221_write_data(struct dvb_ca_private *ca, int slot, u8 * buf, int bytes_write)
+{
+	int status;
+	int i;
+
+	dprintk("%s\n", __func__);
+
+
+	/* sanity check */
+	if (bytes_write > ca->slot_info[slot].link_buf_size)
+		return -EINVAL;
+
+	/* it is possible we are dealing with a single buffer implementation,
+	   thus if there is data available for read or if there is even a read
+	   already in progress, we do nothing but awake the kernel thread to
+	   process the data if necessary. */
+	if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0)
+		goto exitnowrite;
+	if (status & (STATUSREG_DA | STATUSREG_RE)) {
+		if (status & STATUSREG_DA)
+			dvb_ca_en50221_thread_wakeup(ca);
+
+		status = -EAGAIN;
+		goto exitnowrite;
+	}
+
+	/* OK, set HC bit */
+	if ((status = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_COMMAND,
+						 IRQEN | CMDREG_HC)) != 0)
+		goto exit;
+
+	/* check if interface is still free */
+	if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0)
+		goto exit;
+	if (!(status & STATUSREG_FR)) {
+		/* it wasn't free => try again later */
+		status = -EAGAIN;
+		goto exit;
+	}
+
+	/*
+	 * It may need some time for the CAM to settle down, or there might
+	 * be a race condition between the CAM, writing HC and our last
+	 * check for DA. This happens, if the CAM asserts DA, just after
+	 * checking DA before we are setting HC. In this case it might be
+	 * a bug in the CAM to keep the FR bit, the lower layer/HW
+	 * communication requires a longer timeout or the CAM needs more
+	 * time internally. But this happens in reality!
+	 * We need to read the status from the HW again and do the same
+	 * we did for the previous check for DA
+	 */
+	status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS);
+	if (status < 0)
+		goto exit;
+
+	if (status & (STATUSREG_DA | STATUSREG_RE)) {
+		if (status & STATUSREG_DA)
+			dvb_ca_en50221_thread_wakeup(ca);
+
+		status = -EAGAIN;
+		goto exit;
+	}
+
+	/* send the amount of data */
+	if ((status = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_SIZE_HIGH, bytes_write >> 8)) != 0)
+		goto exit;
+	if ((status = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_SIZE_LOW,
+						 bytes_write & 0xff)) != 0)
+		goto exit;
+
+	/* send the buffer */
+	for (i = 0; i < bytes_write; i++) {
+		if ((status = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_DATA, buf[i])) != 0)
+			goto exit;
+	}
+
+	/* check for write error (WE should now be 0) */
+	if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0)
+		goto exit;
+	if (status & STATUSREG_WE) {
+		ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
+		status = -EIO;
+		goto exit;
+	}
+	status = bytes_write;
+
+	dprintk("Wrote CA packet for slot %i, connection id 0x%x last_frag:%i size:0x%x\n", slot,
+		buf[0], (buf[1] & 0x80) == 0, bytes_write);
+
+exit:
+	ca->pub->write_cam_control(ca->pub, slot, CTRLIF_COMMAND, IRQEN);
+
+exitnowrite:
+	return status;
+}
+EXPORT_SYMBOL(dvb_ca_en50221_cimcu_camchange_irq);
+
+
+
+/* ******************************************************************************** */
+/* EN50221 higher level functions */
+
+
+/**
+ * dvb_ca_en50221_camready_irq - A CAM has been removed => shut it down.
+ *
+ * @ca: CA instance.
+ * @slot: Slot to shut down.
+ */
+static int dvb_ca_en50221_slot_shutdown(struct dvb_ca_private *ca, int slot)
+{
+	dprintk("%s\n", __func__);
+
+	ca->pub->slot_shutdown(ca->pub, slot);
+	ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_NONE;
+
+	/* need to wake up all processes to check if they're now
+	   trying to write to a defunct CAM */
+	wake_up_interruptible(&ca->wait_queue);
+
+	dprintk("Slot %i shutdown\n", slot);
+
+	/* success */
+	return 0;
+}
+EXPORT_SYMBOL(dvb_ca_en50221_cimcu_camready_irq);
+
+
+/**
+ * dvb_ca_en50221_camready_irq - A CAMCHANGE IRQ has occurred.
+ *
+ * @ca: CA instance.
+ * @slot: Slot concerned.
+ * @change_type: One of the DVB_CA_CAMCHANGE_* values.
+ */
+void dvb_ca_en50221_cimcu_camchange_irq(struct dvb_ca_en50221_cimcu *pubca, int slot, int change_type)
+{
+	struct dvb_ca_private *ca = pubca->private;
+
+	dprintk("CAMCHANGE IRQ slot:%i change_type:%i\n", slot, change_type);
+
+	switch (change_type) {
+	case DVB_CA_EN50221_CAMCHANGE_REMOVED:
+	case DVB_CA_EN50221_CAMCHANGE_INSERTED:
+		break;
+
+	default:
+		return;
+	}
+
+	ca->slot_info[slot].camchange_type = change_type;
+	atomic_inc(&ca->slot_info[slot].camchange_count);
+	dvb_ca_en50221_thread_wakeup(ca);
+}
+EXPORT_SYMBOL(dvb_ca_en50221_cimcu_frda_irq);
+
+
+/**
+ * dvb_ca_en50221_cimcu_camready_irq - A CAMREADY IRQ has occurred.
+ *
+ * @ca: CA instance.
+ * @slot: Slot concerned.
+ */
+void dvb_ca_en50221_cimcu_camready_irq(struct dvb_ca_en50221_cimcu *pubca, int slot)
+{
+	struct dvb_ca_private *ca = pubca->private;
+
+	dprintk("CAMREADY IRQ slot:%i\n", slot);
+
+	if (ca->slot_info[slot].slot_state == DVB_CA_SLOTSTATE_WAITREADY) {
+		ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_VALIDATE;
+		dvb_ca_en50221_thread_wakeup(ca);
+	}
+}
+
+
+/**
+ * An FR or DA IRQ has occurred.
+ *
+ * @ca: CA instance.
+ * @slot: Slot concerned.
+ */
+void dvb_ca_en50221_cimcu_frda_irq(struct dvb_ca_en50221_cimcu *pubca, int slot)
+{
+	struct dvb_ca_private *ca = pubca->private;
+	int flags;
+
+	dprintk("FR/DA IRQ slot:%i\n", slot);
+
+	switch (ca->slot_info[slot].slot_state) {
+	case DVB_CA_SLOTSTATE_LINKINIT:
+		flags = ca->pub->read_cam_control(pubca, slot, CTRLIF_STATUS);
+		if (flags & STATUSREG_DA) {
+			dprintk("CAM supports DA IRQ\n");
+			ca->slot_info[slot].da_irq_supported = 1;
+		}
+		break;
+
+	case DVB_CA_SLOTSTATE_RUNNING:
+		if (ca->open)
+			dvb_ca_en50221_thread_wakeup(ca);
+		break;
+	}
+}
+
+
+
+/* ******************************************************************************** */
+/* EN50221 thread functions */
+
+/**
+ * Wake up the DVB CA thread
+ *
+ * @ca: CA instance.
+ */
+static void dvb_ca_en50221_thread_wakeup(struct dvb_ca_private *ca)
+{
+
+	dprintk("%s\n", __func__);
+
+	ca->wakeup = 1;
+	mb();
+	wake_up_process(ca->thread);
+}
+
+/**
+ * Update the delay used by the thread.
+ *
+ * @ca: CA instance.
+ */
+static void dvb_ca_en50221_thread_update_delay(struct dvb_ca_private *ca)
+{
+	int delay;
+	int curdelay = 100000000;
+	int slot;
+
+	/* Beware of too high polling frequency, because one polling
+	 * call might take several hundred milliseconds until timeout!
+	 */
+	for (slot = 0; slot < ca->slot_count; slot++) {
+		switch (ca->slot_info[slot].slot_state) {
+		default:
+		case DVB_CA_SLOTSTATE_NONE:
+			delay = HZ * 60;  /* 60s */
+			if (!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE))
+				delay = HZ * 5;  /* 5s */
+			break;
+		case DVB_CA_SLOTSTATE_INVALID:
+			delay = HZ * 60;  /* 60s */
+			if (!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE))
+				delay = HZ / 10;  /* 100ms */
+			break;
+
+		case DVB_CA_SLOTSTATE_UNINITIALISED:
+		case DVB_CA_SLOTSTATE_WAITREADY:
+		case DVB_CA_SLOTSTATE_VALIDATE:
+		case DVB_CA_SLOTSTATE_WAITFR:
+		case DVB_CA_SLOTSTATE_LINKINIT:
+			delay = HZ / 10;  /* 100ms */
+			break;
+
+		case DVB_CA_SLOTSTATE_RUNNING:
+			delay = HZ * 60;  /* 60s */
+			if (!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE))
+				delay = HZ / 10;  /* 100ms */
+			if (ca->open) {
+				if ((!ca->slot_info[slot].da_irq_supported) ||
+				    (!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_DA)))
+					delay = HZ / 10;  /* 100ms */
+			}
+			break;
+		}
+
+		if (delay < curdelay)
+			curdelay = delay;
+	}
+
+	ca->delay = curdelay;
+}
+
+
+
+/**
+ * Kernel thread which monitors CA slots for CAM changes, and performs data transfers.
+ */
+static int dvb_ca_en50221_thread(void *data)
+{
+	struct dvb_ca_private *ca = data;
+	int slot;
+	int flags;
+	int status;
+	int pktcount;
+	void *rxbuf;
+
+	dprintk("%s\n", __func__);
+
+	/* choose the correct initial delay */
+	dvb_ca_en50221_thread_update_delay(ca);
+
+	/* main loop */
+	while (!kthread_should_stop()) {
+		/* sleep for a bit */
+		if (!ca->wakeup) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(ca->delay);
+			if (kthread_should_stop())
+				return 0;
+		}
+		ca->wakeup = 0;
+
+		/* go through all the slots processing them */
+		for (slot = 0; slot < ca->slot_count; slot++) {
+
+			mutex_lock(&ca->slot_info[slot].slot_lock);
+
+			// check the cam status + deal with CAMCHANGEs
+			while (dvb_ca_en50221_check_camstatus(ca, slot)) {
+				/* clear down an old CI slot if necessary */
+				if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_NONE)
+					dvb_ca_en50221_slot_shutdown(ca, slot);
+
+				/* if a CAM is NOW present, initialise it */
+				if (ca->slot_info[slot].camchange_type == DVB_CA_EN50221_CAMCHANGE_INSERTED) {
+					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_UNINITIALISED;
+				}
+
+				/* we've handled one CAMCHANGE */
+				dvb_ca_en50221_thread_update_delay(ca);
+				atomic_dec(&ca->slot_info[slot].camchange_count);
+			}
+
+			// CAM state machine
+			switch (ca->slot_info[slot].slot_state) {
+			case DVB_CA_SLOTSTATE_NONE:
+			case DVB_CA_SLOTSTATE_INVALID:
+				// no action needed
+				break;
+
+			case DVB_CA_SLOTSTATE_UNINITIALISED:
+				ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_WAITREADY;
+				ca->pub->slot_reset(ca->pub, slot);
+				ca->slot_info[slot].timeout = jiffies + (INIT_TIMEOUT_SECS * HZ);
+				break;
+
+			case DVB_CA_SLOTSTATE_WAITREADY:
+				if (time_after(jiffies, ca->slot_info[slot].timeout)) {
+					printk("dvb_ca adaptor %d: PC card did not respond :(\n",
+					       ca->dvbdev->adapter->num);
+					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
+					dvb_ca_en50221_thread_update_delay(ca);
+					break;
+				}
+				// no other action needed; will automatically change state when ready
+				break;
+
+			case DVB_CA_SLOTSTATE_VALIDATE:
+				if (dvb_ca_en50221_parse_attributes(ca, slot) != 0) {
+					/* we need this extra check for annoying interfaces like the budget-av */
+					if ((!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE)) &&
+					    (ca->pub->poll_slot_status)) {
+						status = ca->pub->poll_slot_status(ca->pub, slot, 0);
+						if (!(status & DVB_CA_EN50221_POLL_CAM_PRESENT)) {
+							ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_NONE;
+							dvb_ca_en50221_thread_update_delay(ca);
+							break;
+						}
+					}
+
+					printk("dvb_ca adapter %d: Invalid PC card inserted :(\n",
+					       ca->dvbdev->adapter->num);
+					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
+					dvb_ca_en50221_thread_update_delay(ca);
+					break;
+				}
+				if (dvb_ca_en50221_set_configoption(ca, slot) != 0) {
+					printk("dvb_ca adapter %d: Unable to initialise CAM :(\n",
+					       ca->dvbdev->adapter->num);
+					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
+					dvb_ca_en50221_thread_update_delay(ca);
+					break;
+				}
+				if (ca->pub->write_cam_control(ca->pub, slot,
+							       CTRLIF_COMMAND, CMDREG_RS) != 0) {
+					printk("dvb_ca adapter %d: Unable to reset CAM IF\n",
+					       ca->dvbdev->adapter->num);
+					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
+					dvb_ca_en50221_thread_update_delay(ca);
+					break;
+				}
+				dprintk("DVB CAM validated successfully\n");
+
+				ca->slot_info[slot].timeout = jiffies + (INIT_TIMEOUT_SECS * HZ);
+				ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_WAITFR;
+				ca->wakeup = 1;
+				break;
+
+			case DVB_CA_SLOTSTATE_WAITFR:
+				if (time_after(jiffies, ca->slot_info[slot].timeout)) {
+					printk("dvb_ca adapter %d: DVB CAM did not respond :(\n",
+					       ca->dvbdev->adapter->num);
+					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
+					dvb_ca_en50221_thread_update_delay(ca);
+					break;
+				}
+
+				flags = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS);
+				if (flags & STATUSREG_FR) {
+					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
+					ca->wakeup = 1;
+				}
+				break;
+
+			case DVB_CA_SLOTSTATE_LINKINIT:
+				if (dvb_ca_en50221_link_init(ca, slot) != 0) {
+					/* we need this extra check for annoying interfaces like the budget-av */
+					if ((!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE)) &&
+					    (ca->pub->poll_slot_status)) {
+						status = ca->pub->poll_slot_status(ca->pub, slot, 0);
+						if (!(status & DVB_CA_EN50221_POLL_CAM_PRESENT)) {
+							ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_NONE;
+							dvb_ca_en50221_thread_update_delay(ca);
+							break;
+						}
+					}
+
+					printk("dvb_ca adapter %d: DVB CAM link initialisation failed :(\n", ca->dvbdev->adapter->num);
+					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
+					dvb_ca_en50221_thread_update_delay(ca);
+					break;
+				}
+
+				if (ca->slot_info[slot].rx_buffer.data == NULL) {
+					rxbuf = vmalloc(RX_BUFFER_SIZE);
+					if (rxbuf == NULL) {
+						printk("dvb_ca adapter %d: Unable to allocate CAM rx buffer :(\n", ca->dvbdev->adapter->num);
+						ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
+						dvb_ca_en50221_thread_update_delay(ca);
+						break;
+					}
+					dvb_ringbuffer_init(&ca->slot_info[slot].rx_buffer, rxbuf, RX_BUFFER_SIZE);
+				}
+
+				ca->pub->slot_ts_enable(ca->pub, slot);
+				ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_RUNNING;
+				dvb_ca_en50221_thread_update_delay(ca);
+				printk("dvb_ca adapter %d: DVB CAM detected and initialised successfully\n", ca->dvbdev->adapter->num);
+				break;
+
+			case DVB_CA_SLOTSTATE_RUNNING:
+				if (!ca->open)
+					break;
+
+				// poll slots for data
+				pktcount = 0;
+				while ((status = dvb_ca_en50221_read_data(ca, slot, NULL, 0)) > 0) {
+					if (!ca->open)
+						break;
+
+					/* if a CAMCHANGE occurred at some point, do not do any more processing of this slot */
+					if (dvb_ca_en50221_check_camstatus(ca, slot)) {
+						// we dont want to sleep on the next iteration so we can handle the cam change
+						ca->wakeup = 1;
+						break;
+					}
+
+					/* check if we've hit our limit this time */
+					if (++pktcount >= MAX_RX_PACKETS_PER_ITERATION) {
+						// dont sleep; there is likely to be more data to read
+						ca->wakeup = 1;
+						break;
+					}
+				}
+				break;
+			}
+
+			mutex_unlock(&ca->slot_info[slot].slot_lock);
+		}
+	}
+
+	return 0;
+}
+
+
+
+/* ******************************************************************************** */
+/* EN50221 IO interface functions */
+
+/**
+ * Real ioctl implementation.
+ * NOTE: CA_SEND_MSG/CA_GET_MSG ioctls have userspace buffers passed to them.
+ *
+ * @inode: Inode concerned.
+ * @file: File concerned.
+ * @cmd: IOCTL command.
+ * @arg: Associated argument.
+ *
+ * @return 0 on success, <0 on error.
+ */
+static int dvb_ca_en50221_io_do_ioctl(struct file *file,
+				      unsigned int cmd, void *parg)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct dvb_ca_private *ca = dvbdev->priv;
+	int err = 0;
+	int slot;
+
+	dprintk("%s\n", __func__);
+
+	if (mutex_lock_interruptible(&ca->ioctl_mutex)) {
+		printk("ci lock interrupt error\r\n");
+		return -ERESTARTSYS;
+	}
+
+	switch (cmd) {
+	case CA_RESET:
+		dprintk("ci reset---\r\n");
+		for (slot = 0; slot < ca->slot_count; slot++) {
+			mutex_lock(&ca->slot_info[slot].slot_lock);
+			if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_NONE) {
+				dvb_ca_en50221_slot_shutdown(ca, slot);
+				if (ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE)
+					dvb_ca_en50221_cimcu_camchange_irq(ca->pub,
+								     slot,
+								     DVB_CA_EN50221_CAMCHANGE_INSERTED);
+			}
+			mutex_unlock(&ca->slot_info[slot].slot_lock);
+		}
+		ca->next_read_slot = 0;
+		dvb_ca_en50221_thread_wakeup(ca);
+		break;
+
+	case CA_GET_CAP: {
+		struct ca_caps *caps = parg;
+
+		caps->slot_num = ca->slot_count;
+		caps->slot_type = CA_CI_LINK;
+		caps->descr_num = 0;
+		caps->descr_type = 0;
+		break;
+	}
+
+	case CA_GET_SLOT_INFO: {
+		struct ca_slot_info *info = parg;
+
+		if ((info->num > ca->slot_count) || (info->num < 0)) {
+			err = -EINVAL;
+			goto out_unlock;
+		}
+
+		info->type = CA_CI_LINK;
+		info->flags = 0;
+		if ((ca->slot_info[info->num].slot_state != DVB_CA_SLOTSTATE_NONE)
+			&& (ca->slot_info[info->num].slot_state != DVB_CA_SLOTSTATE_INVALID)) {
+			info->flags = CA_CI_MODULE_PRESENT;
+		}
+		if (ca->slot_info[info->num].slot_state == DVB_CA_SLOTSTATE_RUNNING) {
+			info->flags |= CA_CI_MODULE_READY;
+		}
+		break;
+	}
+
+	default:
+		err = -EINVAL;
+		break;
+	}
+
+out_unlock:
+	mutex_unlock(&ca->ioctl_mutex);
+	return err;
+}
+static int dvb_usercopy__(struct file *file,
+		   unsigned int cmd, unsigned long arg,
+		   int (*func)(struct file *file,
+		   unsigned int cmd, void *arg))
+{
+  char	  sbuf[128];
+  void	  *mbuf = NULL;
+  void	  *parg = NULL;
+  int	  err  = -EINVAL;
+
+  /*  Copy arguments into temp kernel buffer  */
+  switch (_IOC_DIR(cmd)) {
+  case _IOC_NONE:
+	  /*
+	   * For this command, the pointer is actually an integer
+	   * argument.
+	   */
+	  parg = (void *) arg;
+	  break;
+  case _IOC_READ: /* some v4l ioctls are marked wrong ... */
+  case _IOC_WRITE:
+  case (_IOC_WRITE | _IOC_READ):
+	  if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {
+		  parg = sbuf;
+	  } else {
+		  /* too big to allocate from stack */
+		  mbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);
+		  if (NULL == mbuf)
+			  return -ENOMEM;
+		  parg = mbuf;
+	  }
+
+	  err = -EFAULT;
+	  if (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))
+		  goto out;
+	  break;
+  }
+
+  /* call driver */
+  if ((err = func(file, cmd, parg)) == -ENOIOCTLCMD)
+	  err = -ENOTTY;
+
+  if (err < 0)
+	  goto out;
+
+  /*  Copy results into user buffer  */
+  switch (_IOC_DIR(cmd))
+  {
+  case _IOC_READ:
+  case (_IOC_WRITE | _IOC_READ):
+	  if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
+		  err = -EFAULT;
+	  break;
+  }
+
+out:
+  kfree(mbuf);
+  return err;
+}
+
+/**
+ * Wrapper for ioctl implementation.
+ *
+ * @inode: Inode concerned.
+ * @file: File concerned.
+ * @cmd: IOCTL command.
+ * @arg: Associated argument.
+ *
+ * @return 0 on success, <0 on error.
+ */
+static long dvb_ca_en50221_io_ioctl(struct file *file,
+				    unsigned int cmd, unsigned long arg)
+{
+	return dvb_usercopy__(file, cmd, arg, dvb_ca_en50221_io_do_ioctl);
+}
+
+
+/**
+ * Implementation of write() syscall.
+ *
+ * @file: File structure.
+ * @buf: Source buffer.
+ * @count: Size of source buffer.
+ * @ppos: Position in file (ignored).
+ *
+ * @return Number of bytes read, or <0 on error.
+ */
+static ssize_t dvb_ca_en50221_io_write(struct file *file,
+				       const char __user * buf, size_t count, loff_t * ppos)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct dvb_ca_private *ca = dvbdev->priv;
+	u8 slot, connection_id;
+	int status;
+	u8 fragbuf[HOST_LINK_BUF_SIZE];
+	int fragpos = 0;
+	int fraglen;
+	unsigned long timeout;
+	int written;
+
+	dprintk("%s\n", __func__);
+
+	/* Incoming packet has a 2 byte header. hdr[0] = slot_id, hdr[1] = connection_id */
+	if (count < 2)
+		return -EINVAL;
+
+	/* extract slot & connection id */
+	if (copy_from_user(&slot, buf, 1))
+		return -EFAULT;
+	if (copy_from_user(&connection_id, buf + 1, 1))
+		return -EFAULT;
+	buf += 2;
+	count -= 2;
+
+	/* check if the slot is actually running */
+	if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_RUNNING)
+		return -EINVAL;
+
+	/* fragment the packets & store in the buffer */
+	while (fragpos < count) {
+		fraglen = ca->slot_info[slot].link_buf_size - 2;
+		if (fraglen < 0)
+			break;
+		if (fraglen > HOST_LINK_BUF_SIZE - 2)
+			fraglen = HOST_LINK_BUF_SIZE - 2;
+		if ((count - fragpos) < fraglen)
+			fraglen = count - fragpos;
+
+		fragbuf[0] = connection_id;
+		fragbuf[1] = ((fragpos + fraglen) < count) ? 0x80 : 0x00;
+		status = copy_from_user(fragbuf + 2, buf + fragpos, fraglen);
+		if (status) {
+			status = -EFAULT;
+			goto exit;
+		}
+
+		timeout = jiffies + HZ / 2;
+		written = 0;
+		while (!time_after(jiffies, timeout)) {
+			/* check the CAM hasn't been removed/reset in the meantime */
+			if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_RUNNING) {
+				status = -EIO;
+				goto exit;
+			}
+
+			mutex_lock(&ca->slot_info[slot].slot_lock);
+			status = dvb_ca_en50221_write_data(ca, slot, fragbuf, fraglen + 2);
+			mutex_unlock(&ca->slot_info[slot].slot_lock);
+			if (status == (fraglen + 2)) {
+				written = 1;
+				break;
+			}
+			if (status != -EAGAIN)
+				goto exit;
+
+			msleep(1);
+		}
+		if (!written) {
+			status = -EIO;
+			goto exit;
+		}
+
+		fragpos += fraglen;
+	}
+	status = count + 2;
+
+exit:
+	return status;
+}
+
+
+/**
+ * Condition for waking up in dvb_ca_en50221_io_read_condition
+ */
+static int dvb_ca_en50221_io_read_condition(struct dvb_ca_private *ca,
+					    int *result, int *_slot)
+{
+	int slot;
+	int slot_count = 0;
+	int idx;
+	size_t fraglen;
+	int connection_id = -1;
+	int found = 0;
+	u8 hdr[2];
+
+	slot = ca->next_read_slot;
+	while ((slot_count < ca->slot_count) && (!found)) {
+		if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_RUNNING)
+			goto nextslot;
+
+		if (ca->slot_info[slot].rx_buffer.data == NULL)
+			return 0;
+#ifdef READ_LPDU_PKT
+		if (ca->slot_info[slot].rx_offset != 0) {
+			*_slot = slot;
+			return 1;
+		}
+#endif
+		idx = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer, -1, &fraglen);
+		while (idx != -1) {
+			dvb_ringbuffer_pkt_read(&ca->slot_info[slot].rx_buffer, idx, 0, hdr, 2);
+			if (connection_id == -1)
+				connection_id = hdr[0];
+			if ((hdr[0] == connection_id)
+#ifndef READ_LPDU_PKT
+				&& ((hdr[1] & 0x80) == 0)
+#endif
+			) {
+				*_slot = slot;
+				found = 1;
+				break;
+			}
+
+			idx = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer, idx, &fraglen);
+		}
+
+nextslot:
+		slot = (slot + 1) % ca->slot_count;
+		slot_count++;
+	}
+
+	ca->next_read_slot = slot;
+	return found;
+}
+
+
+/**
+ * Implementation of read() syscall.
+ *
+ * @file: File structure.
+ * @buf: Destination buffer.
+ * @count: Size of destination buffer.
+ * @ppos: Position in file (ignored).
+ *
+ * @return Number of bytes read, or <0 on error.
+ */
+static ssize_t dvb_ca_en50221_io_read(struct file *file, char __user * buf,
+				      size_t count, loff_t * ppos)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct dvb_ca_private *ca = dvbdev->priv;
+	int status;
+	int result = 0;
+	u8 hdr[2];
+	int slot;
+	int connection_id = -1;
+	size_t idx, idx2;
+	int last_fragment = 0;
+	size_t fraglen;
+	int pktlen;
+	int dispose = 0;
+
+#ifdef READ_LPDU_PKT
+	int offset;
+	u8 flag = 0;
+#endif
+	dprintk("%s\n", __func__);
+
+	/* Outgoing packet has a 2 byte header. hdr[0] = slot_id, hdr[1] = connection_id */
+	if (count < 2)
+		return -EINVAL;
+
+	/* wait for some data */
+	if ((status = dvb_ca_en50221_io_read_condition(ca, &result, &slot)) == 0) {
+
+		/* if we're in nonblocking mode, exit immediately */
+		if (file->f_flags & O_NONBLOCK)
+			return -EWOULDBLOCK;
+
+		/* wait for some data */
+		status = wait_event_interruptible(ca->wait_queue,
+						  dvb_ca_en50221_io_read_condition
+						  (ca, &result, &slot));
+	}
+	if ((status < 0) || (result < 0)) {
+		if (result)
+			return result;
+		return status;
+	}
+
+	idx = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer, -1, &fraglen);
+	pktlen = 2;
+	do {
+		if (idx == -1) {
+			printk("dvb_ca adapter %d: BUG: read packet ended before last_fragment encountered\n", ca->dvbdev->adapter->num);
+			status = -EIO;
+			goto exit;
+		}
+#ifdef READ_LPDU_PKT
+		offset = 2 + ca->slot_info[slot].rx_offset;
+#endif
+		dvb_ringbuffer_pkt_read(&ca->slot_info[slot].rx_buffer, idx, 0, hdr, 2);
+		if (connection_id == -1)
+			connection_id = hdr[0];
+#ifdef READ_LPDU_PKT
+		flag = hdr[1];
+		if (hdr[0] == connection_id) {
+			if (pktlen < count) {
+				if ((pktlen + fraglen - offset) > (count - 2)) {
+					fraglen = (count - 2) - pktlen;
+					ca->slot_info[slot].rx_offset +=
+									fraglen;
+					/* more data for user,
+					   but cannot send,
+					   so force return to user,
+					   rather than dispose of it */
+					flag |= 0x80;
+				} else {
+					ca->slot_info[slot].rx_offset = 0;
+					fraglen -= offset;
+					dispose = 1;
+				}
+
+				status = dvb_ringbuffer_pkt_read_user(
+					&ca->slot_info[slot].rx_buffer,
+					idx,
+					offset,
+					buf + pktlen + 2,
+					fraglen);
+				if (status < 0)
+					goto exit;
+				pktlen += fraglen;
+			}
+
+			last_fragment = 1;
+		}
+#else
+		if (hdr[0] == connection_id) {
+			if (pktlen < count) {
+				if ((pktlen + fraglen - 2) > count) {
+					fraglen = count - pktlen;
+				} else {
+					fraglen -= 2;
+				}
+
+				if ((status = dvb_ringbuffer_pkt_read_user(&ca->slot_info[slot].rx_buffer, idx, 2,
+								      buf + pktlen, fraglen)) < 0) {
+					goto exit;
+				}
+				pktlen += fraglen;
+			}
+
+			if ((hdr[1] & 0x80) == 0)
+				last_fragment = 1;
+			dispose = 1;
+		}
+#endif
+		idx2 = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer,
+				idx, &fraglen);
+		if (dispose)
+			dvb_ringbuffer_pkt_dispose(&ca->slot_info[slot].rx_buffer, idx);
+		idx = idx2;
+		dispose = 0;
+	} while (!last_fragment);
+
+	hdr[0] = slot;
+	hdr[1] = connection_id;
+	status = copy_to_user(buf, hdr, 2);
+	if (status) {
+		status = -EFAULT;
+		goto exit;
+	}
+	status = pktlen;
+
+#ifdef READ_LPDU_PKT
+	hdr[0] = flag;
+	hdr[1] = 0;
+
+	status = copy_to_user(buf + 2, hdr, 2);
+	if (status) {
+		status = -EFAULT;
+		goto exit;
+	}
+	status = pktlen + 2;
+#endif
+exit:
+	return status;
+}
+
+
+/**
+ * Implementation of file open syscall.
+ *
+ * @inode: Inode concerned.
+ * @file: File concerned.
+ *
+ * @return 0 on success, <0 on failure.
+ */
+static int dvb_ca_en50221_io_open(struct inode *inode, struct file *file)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct dvb_ca_private *ca = dvbdev->priv;
+	int err;
+	int i;
+
+	dprintk("%s\n", __func__);
+
+	if (!try_module_get(ca->pub->owner))
+		return -EIO;
+
+	err = dvb_generic_open(inode, file);
+	if (err < 0) {
+		module_put(ca->pub->owner);
+		return err;
+	}
+
+	for (i = 0; i < ca->slot_count; i++) {
+
+		if (ca->slot_info[i].slot_state == DVB_CA_SLOTSTATE_RUNNING) {
+			if (ca->slot_info[i].rx_buffer.data != NULL) {
+				/* it is safe to call this here without locks because
+				 * ca->open == 0. Data is not read in this case */
+				dvb_ringbuffer_flush(&ca->slot_info[i].rx_buffer);
+			}
+		}
+	}
+
+	ca->open = 1;
+	dvb_ca_en50221_thread_update_delay(ca);
+	dvb_ca_en50221_thread_wakeup(ca);
+
+	dvb_ca_private_get(ca);
+
+	return 0;
+}
+
+
+/**
+ * Implementation of file close syscall.
+ *
+ * @inode: Inode concerned.
+ * @file: File concerned.
+ *
+ * @return 0 on success, <0 on failure.
+ */
+static int dvb_ca_en50221_io_release(struct inode *inode, struct file *file)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct dvb_ca_private *ca = dvbdev->priv;
+	int err;
+
+	dprintk("%s\n", __func__);
+
+	/* mark the CA device as closed */
+	ca->open = 0;
+	dvb_ca_en50221_thread_update_delay(ca);
+
+	err = dvb_generic_release(inode, file);
+
+	module_put(ca->pub->owner);
+
+	dvb_ca_private_put(ca);
+
+	return err;
+}
+
+
+/**
+ * Implementation of poll() syscall.
+ *
+ * @file: File concerned.
+ * @wait: poll wait table.
+ *
+ * @return Standard poll mask.
+ */
+static unsigned int dvb_ca_en50221_io_poll(struct file *file, poll_table * wait)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct dvb_ca_private *ca = dvbdev->priv;
+	unsigned int mask = 0;
+	int slot;
+	int result = 0;
+
+	dprintk("%s\n", __func__);
+
+	if (dvb_ca_en50221_io_read_condition(ca, &result, &slot) == 1) {
+		mask |= POLLIN;
+	}
+
+	/* if there is something, return now */
+	if (mask)
+		return mask;
+
+	/* wait for something to happen */
+	poll_wait(file, &ca->wait_queue, wait);
+
+	if (dvb_ca_en50221_io_read_condition(ca, &result, &slot) == 1) {
+		mask |= POLLIN;
+	}
+
+	return mask;
+}
+EXPORT_SYMBOL(dvb_ca_en50221_cimcu_init);
+
+#ifdef CONFIG_AMLOGIC_DVB_COMPAT
+static long dvb_ca_en50221_compat_ioctl(struct file *filp,
+			unsigned int cmd, unsigned long args)
+{
+	unsigned long ret;
+#ifdef CONFIG_COMPAT
+	args = (unsigned long)compat_ptr(args);
+#endif
+	ret = dvb_ca_en50221_io_ioctl(filp, cmd, args);
+	return ret;
+}
+#endif
+
+static const struct file_operations dvb_ca_fops = {
+	.owner = THIS_MODULE,
+	.read = dvb_ca_en50221_io_read,
+	.write = dvb_ca_en50221_io_write,
+	.unlocked_ioctl = dvb_ca_en50221_io_ioctl,
+	.open = dvb_ca_en50221_io_open,
+	.release = dvb_ca_en50221_io_release,
+	.poll = dvb_ca_en50221_io_poll,
+	.llseek = noop_llseek,
+#ifdef CONFIG_AMLOGIC_DVB_COMPAT
+	.compat_ioctl	= dvb_ca_en50221_compat_ioctl,
+#endif
+};
+
+static const struct dvb_device dvbdev_ca = {
+	.priv = NULL,
+	.users = 1,
+	.readers = 1,
+	.writers = 1,
+#if defined(CONFIG_MEDIA_CONTROLLER_DVB)
+	.name = "dvb-ca-en50221",
+#endif
+	.fops = &dvb_ca_fops,
+};
+
+/* ******************************************************************************** */
+/* Initialisation/shutdown functions */
+
+
+/**
+ * Initialise a new DVB CA EN50221 interface device.
+ *
+ * @dvb_adapter: DVB adapter to attach the new CA device to.
+ * @ca: The dvb_ca instance.
+ * @flags: Flags describing the CA device (DVB_CA_FLAG_*).
+ * @slot_count: Number of slots supported.
+ *
+ * @return 0 on success, nonzero on failure
+ */
+int dvb_ca_en50221_cimcu_init(struct dvb_adapter *dvb_adapter,
+			struct dvb_ca_en50221_cimcu *pubca, int flags, int slot_count)
+{
+	int ret;
+	struct dvb_ca_private *ca = NULL;
+	int i;
+
+	dprintk("%s\n", __func__);
+	printk("---%s\n", __func__);
+	if (slot_count < 1)
+		return -EINVAL;
+
+	/* initialise the system data */
+	if ((ca = kzalloc(sizeof(struct dvb_ca_private), GFP_KERNEL)) == NULL) {
+		ret = -ENOMEM;
+		goto exit;
+	}
+	kref_init(&ca->refcount);
+	ca->pub = pubca;
+	ca->flags = flags;
+	ca->slot_count = slot_count;
+	if ((ca->slot_info = kcalloc(slot_count, sizeof(struct dvb_ca_slot), GFP_KERNEL)) == NULL) {
+		ret = -ENOMEM;
+		goto free_ca;
+	}
+	init_waitqueue_head(&ca->wait_queue);
+	ca->open = 0;
+	ca->wakeup = 0;
+	ca->next_read_slot = 0;
+	pubca->private = ca;
+
+	/* register the DVB device */
+	ret = dvb_register_device(dvb_adapter, &ca->dvbdev, &dvbdev_ca, ca, DVB_DEVICE_CA, 0);
+	if (ret)
+		goto free_slot_info;
+
+	/* now initialise each slot */
+	for (i = 0; i < slot_count; i++) {
+		memset(&ca->slot_info[i], 0, sizeof(struct dvb_ca_slot));
+		ca->slot_info[i].slot_state = DVB_CA_SLOTSTATE_NONE;
+		atomic_set(&ca->slot_info[i].camchange_count, 0);
+		ca->slot_info[i].camchange_type = DVB_CA_EN50221_CAMCHANGE_REMOVED;
+		mutex_init(&ca->slot_info[i].slot_lock);
+	}
+
+	mutex_init(&ca->ioctl_mutex);
+
+	if (signal_pending(current)) {
+		ret = -EINTR;
+		goto unregister_device;
+	}
+	mb();
+
+	/* create a kthread for monitoring this CA device */
+	ca->thread = kthread_run(dvb_ca_en50221_thread, ca, "kdvb-ca-%i:%i",
+				 ca->dvbdev->adapter->num, ca->dvbdev->id);
+	if (IS_ERR(ca->thread)) {
+		ret = PTR_ERR(ca->thread);
+		printk("dvb_ca_init: failed to start kernel_thread (%d)\n",
+			ret);
+		goto unregister_device;
+	}
+	return 0;
+
+unregister_device:
+	dvb_unregister_device(ca->dvbdev);
+free_slot_info:
+	kfree(ca->slot_info);
+free_ca:
+	kfree(ca);
+exit:
+	pubca->private = NULL;
+	return ret;
+}
+EXPORT_SYMBOL(dvb_ca_en50221_cimcu_release);
+
+
+
+/**
+ * Release a DVB CA EN50221 interface device.
+ *
+ * @ca_dev: The dvb_device_t instance for the CA device.
+ * @ca: The associated dvb_ca instance.
+ */
+void dvb_ca_en50221_cimcu_release(struct dvb_ca_en50221_cimcu *pubca)
+{
+	struct dvb_ca_private *ca = pubca->private;
+	int i;
+
+	dprintk("%s\n", __func__);
+
+	/* shutdown the thread if there was one */
+	kthread_stop(ca->thread);
+
+	for (i = 0; i < ca->slot_count; i++) {
+		dvb_ca_en50221_slot_shutdown(ca, i);
+	}
+	dvb_ca_private_put(ca);
+	pubca->private = NULL;
+}
diff --git a/drivers/stream_input/parser/dvb_ci/cimcu/dvb_ca_en50221_cimcu.h b/drivers/stream_input/parser/dvb_ci/cimcu/dvb_ca_en50221_cimcu.h
new file mode 100644
index 0000000..7102b3c
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimcu/dvb_ca_en50221_cimcu.h
@@ -0,0 +1,135 @@
+/*
+ * dvb_ca.h: generic DVB functions for EN50221 CA interfaces
+ *
+ * Copyright (C) 2004 Andrew de Quincey
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DVB_CA_EN50221_CIMCU_H_
+#define _DVB_CA_EN50221_CIMCU_H_
+
+#include <linux/list.h>
+#include <linux/dvb/ca.h>
+
+#include "../cimax/dvbdev.h"
+
+#define DVB_CA_EN50221_POLL_CAM_PRESENT	1
+#define DVB_CA_EN50221_POLL_CAM_CHANGED	2
+#define DVB_CA_EN50221_POLL_CAM_READY		4
+
+#define DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE	1
+#define DVB_CA_EN50221_FLAG_IRQ_FR		2
+#define DVB_CA_EN50221_FLAG_IRQ_DA		4
+
+#define DVB_CA_EN50221_CAMCHANGE_REMOVED		0
+#define DVB_CA_EN50221_CAMCHANGE_INSERTED		1
+
+/**
+ * struct dvb_ca_en50221- Structure describing a CA interface
+ *
+ * @owner:		the module owning this structure
+ * @read_attribute_mem:	function for reading attribute memory on the CAM
+ * @write_attribute_mem: function for writing attribute memory on the CAM
+ * @read_cam_control:	function for reading the control interface on the CAM
+ * @write_cam_control:	function for reading the control interface on the CAM
+ * @slot_reset:		function to reset the CAM slot
+ * @slot_shutdown:	function to shutdown a CAM slot
+ * @slot_ts_enable:	function to enable the Transport Stream on a CAM slot
+ * @poll_slot_status:	function to poll slot status. Only necessary if
+ *			DVB_CA_FLAG_EN50221_IRQ_CAMCHANGE is not set.
+ * @data:		private data, used by caller.
+ * @private:		Opaque data used by the dvb_ca core. Do not modify!
+ *
+ * NOTE: the read_*, write_* and poll_slot_status functions will be
+ * called for different slots concurrently and need to use locks where
+ * and if appropriate. There will be no concurrent access to one slot.
+ */
+struct dvb_ca_en50221_cimcu {
+	struct module *owner;
+
+	int (*read_attribute_mem)(struct dvb_ca_en50221_cimcu *ca,
+				  int slot, int address);
+	int (*write_attribute_mem)(struct dvb_ca_en50221_cimcu *ca,
+				   int slot, int address, u8 value);
+
+	int (*read_cam_control)(struct dvb_ca_en50221_cimcu *ca,
+				int slot, u8 address);
+	int (*write_cam_control)(struct dvb_ca_en50221_cimcu *ca,
+				 int slot, u8 address, u8 value);
+
+	int (*slot_reset)(struct dvb_ca_en50221_cimcu *ca, int slot);
+	int (*slot_shutdown)(struct dvb_ca_en50221_cimcu *ca, int slot);
+	int (*slot_ts_enable)(struct dvb_ca_en50221_cimcu *ca, int slot);
+
+	int (*poll_slot_status)(struct dvb_ca_en50221_cimcu *ca, int slot, int open);
+
+	void *data;
+
+	void *private;
+};
+
+/*
+ * Functions for reporting IRQ events
+ */
+
+/**
+ * dvb_ca_en50221_camchange_irq - A CAMCHANGE IRQ has occurred.
+ *
+ * @pubca: CA instance.
+ * @slot: Slot concerned.
+ * @change_type: One of the DVB_CA_CAMCHANGE_* values
+ */
+void dvb_ca_en50221_cimcu_camchange_irq(struct dvb_ca_en50221_cimcu *pubca, int slot,
+				  int change_type);
+
+/**
+ * dvb_ca_en50221_camready_irq - A CAMREADY IRQ has occurred.
+ *
+ * @pubca: CA instance.
+ * @slot: Slot concerned.
+ */
+void dvb_ca_en50221_cimcu_camready_irq(struct dvb_ca_en50221_cimcu *pubca, int slot);
+
+/**
+ * dvb_ca_en50221_frda_irq - An FR or a DA IRQ has occurred.
+ *
+ * @ca: CA instance.
+ * @slot: Slot concerned.
+ */
+void dvb_ca_en50221_cimcu_frda_irq(struct dvb_ca_en50221_cimcu *ca, int slot);
+
+/*
+ * Initialisation/shutdown functions
+ */
+
+/**
+ * dvb_ca_en50221_init - Initialise a new DVB CA device.
+ *
+ * @dvb_adapter: DVB adapter to attach the new CA device to.
+ * @ca: The dvb_ca instance.
+ * @flags: Flags describing the CA device (DVB_CA_EN50221_FLAG_*).
+ * @slot_count: Number of slots supported.
+ *
+ * @return 0 on success, nonzero on failure
+ */
+extern int dvb_ca_en50221_cimcu_init(struct dvb_adapter *dvb_adapter,
+			       struct dvb_ca_en50221_cimcu *ca, int flags,
+			       int slot_count);
+
+/**
+ * dvb_ca_en50221_release - Release a DVB CA device.
+ *
+ * @ca: The associated dvb_ca instance.
+ */
+extern void dvb_ca_en50221_cimcu_release(struct dvb_ca_en50221_cimcu *ca);
+
+#endif
diff --git a/drivers/stream_input/parser/hw_demux/aml_dmx.c b/drivers/stream_input/parser/hw_demux/aml_dmx.c
index 7eb3a61..b82984f 100644
--- a/drivers/stream_input/parser/hw_demux/aml_dmx.c
+++ b/drivers/stream_input/parser/hw_demux/aml_dmx.c
@@ -1705,7 +1705,7 @@ static void stb_enable(struct aml_dvb *dvb)
 		hiu = 0;
 	/* invert ts out clk,add ci model need add this*/
 	if (dvb->ts_out_invert) {
-		/*printk("ts out invert ---\r\n");*/
+		printk("ts out invert ---\r\n");
 		data = READ_MPEG_REG(TS_TOP_CONFIG);
 		data |= 1 << TS_OUT_CLK_INVERT;
 		WRITE_MPEG_REG(TS_TOP_CONFIG, data);
@@ -2959,6 +2959,11 @@ static int dmx_enable(struct aml_dmx *dmx)
 		fec_ctrl = dvb->ts[2].control;
 		record = record ? 1 : 0;
 		break;
+	case AM_TS_SRC_TS3:
+		fec_sel = 3;
+		fec_ctrl = dvb->ts[3].control;
+		record = record ? 1 : 0;
+		break;
 	case AM_TS_SRC_S_TS0:
 	case AM_TS_SRC_S_TS1:
 	case AM_TS_SRC_S_TS2:
@@ -4882,7 +4887,7 @@ int aml_dmx_hw_set_source(struct dmx_demux *demux, dmx_source_t src)
 	case DMX_SOURCE_FRONT3:
 		hw_src =
 			(dvb->ts[3].mode ==
-			 AM_TS_SERIAL) ? (dvb->ts[3].s2p_id + AM_TS_SRC_S_TS0) : AM_TS_SRC_TS2;
+			 AM_TS_SERIAL) ? (dvb->ts[3].s2p_id + AM_TS_SRC_S_TS0) : AM_TS_SRC_TS3;
 		break;
 	case DMX_SOURCE_DVR0:
 		hw_src = AM_TS_SRC_HIU;
diff --git a/drivers/stream_input/parser/hw_demux/aml_dvb.c b/drivers/stream_input/parser/hw_demux/aml_dvb.c
index 67c11bb..2e44285 100644
--- a/drivers/stream_input/parser/hw_demux/aml_dvb.c
+++ b/drivers/stream_input/parser/hw_demux/aml_dvb.c
@@ -94,6 +94,8 @@ module_param(debug_dvb, int, 0644);
 
 #define CARD_NAME "amlogic-dvb"
 
+
+
 DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
 
 MODULE_PARM_DESC(dsc_max, "max number of dsc");
@@ -1134,6 +1136,9 @@ static ssize_t demux##i##_show_source(struct class *class,  \
 	CASE_PREFIX case AM_TS_SRC_S_TS2:\
 		src = "ts2";\
 	break;\
+	CASE_PREFIX case AM_TS_SRC_TS3:\
+		src = "ts3";\
+	break;\
 	CASE_PREFIX case AM_TS_SRC_DMX0:\
 		src = "dmx0";\
 	break;\
@@ -1167,6 +1172,8 @@ static ssize_t demux##i##_store_source(struct class *class,  \
 		src = DMX_SOURCE_FRONT1;\
 	} else if (!strncmp("ts2", buf, 3)) {\
 		src = DMX_SOURCE_FRONT2;\
+	} else if (!strncmp("ts3", buf, 3)) {\
+		src = DMX_SOURCE_FRONT3;\
 	} else if (!strncmp("hiu1", buf, 4)) {\
 		src = DMX_SOURCE_DVR1;\
 	} else if (!strncmp("hiu", buf, 3)) {\

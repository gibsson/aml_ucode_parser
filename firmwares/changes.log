commit bf10e95f9b5a0f2cbdec2a2d67cfb0a992060e7f
Author: Hui Zhang <hui.zhang@amlogic.com>
Date:   Mon Jun 3 13:09:30 2019 +0800

    media_module: fix put_timer_func crash issue [1/1]
    
    PD#OTT-4243
    
    Problem:
    backend transfer an invalid vf pointer to decoder.
    and make system crash
    
    Solution:
    add vf invalid check in vf_put to skip invalid vf pointer
    
    Verify:
    s805x
    
    Change-Id: Ie9ed298e6cee294946d9db568d5a48f7003e330c
    Signed-off-by: Hui Zhang <hui.zhang@amlogic.com>

diff --git a/drivers/frame_provider/decoder/h264/vh264.c b/drivers/frame_provider/decoder/h264/vh264.c
index fa008da..f1c5242 100644
--- a/drivers/frame_provider/decoder/h264/vh264.c
+++ b/drivers/frame_provider/decoder/h264/vh264.c
@@ -543,6 +543,18 @@ static struct vframe_s *vh264_vf_get(void *op_arg)
 
 	return NULL;
 }
+static bool vf_valid_check(struct vframe_s *vf) {
+	int i;
+	for (i = 0; i < VF_POOL_SIZE; i++) {
+		if (vf == &vfpool[i])
+			return true;
+	}
+	pr_info(" invalid vf been put, vf = %p\n", vf);
+	for (i = 0; i < VF_POOL_SIZE; i++) {
+		pr_info("www valid vf[%d]= %p \n", i, &vfpool[i]);
+	}
+	return false;
+}
 
 static void vh264_vf_put(struct vframe_s *vf, void *op_arg)
 {
@@ -550,9 +562,10 @@ static void vh264_vf_put(struct vframe_s *vf, void *op_arg)
 
 	spin_lock_irqsave(&recycle_lock, flags);
 
-	if ((vf != &fense_vf[0]) && (vf != &fense_vf[1]))
-		kfifo_put(&recycle_q, (const struct vframe_s *)vf);
-
+	if ((vf != &fense_vf[0]) && (vf != &fense_vf[1])) {
+		if (vf && (vf_valid_check(vf) == true))
+			kfifo_put(&recycle_q, (const struct vframe_s *)vf);
+	}
 	spin_unlock_irqrestore(&recycle_lock, flags);
 }
 
diff --git a/drivers/frame_provider/decoder/h265/vh265.c b/drivers/frame_provider/decoder/h265/vh265.c
index 5f25135..b6108ec 100644
--- a/drivers/frame_provider/decoder/h265/vh265.c
+++ b/drivers/frame_provider/decoder/h265/vh265.c
@@ -7783,6 +7783,18 @@ static struct vframe_s *vh265_vf_get(void *op_arg)
 
 	return NULL;
 }
+static bool vf_valid_check(struct vframe_s *vf, struct hevc_state_s *hevc) {
+	int i;
+	for (i = 0; i < VF_POOL_SIZE; i++) {
+		if (vf == &hevc->vfpool[i])
+			return true;
+	}
+	pr_info(" h265 invalid vf been put, vf = %p\n", vf);
+	for (i = 0; i < VF_POOL_SIZE; i++) {
+		pr_info("www valid vf[%d]= %p \n", i, &hevc->vfpool[i]);
+	}
+	return false;
+}
 
 static void vh265_vf_put(struct vframe_s *vf, void *op_arg)
 {
@@ -7793,10 +7805,15 @@ static void vh265_vf_put(struct vframe_s *vf, void *op_arg)
 #else
 	struct hevc_state_s *hevc = (struct hevc_state_s *)op_arg;
 #endif
-	unsigned char index_top = vf->index & 0xff;
-	unsigned char index_bot = (vf->index >> 8) & 0xff;
+	unsigned char index_top;
+	unsigned char index_bot;
+
+	if (vf && (vf_valid_check(vf, hevc) == false))
+		return;
 	if (vf == (&hevc->vframe_dummy))
 		return;
+	index_top = vf->index & 0xff;
+	index_bot = (vf->index >> 8) & 0xff;
 	if (get_dbg_flag(hevc) & H265_DEBUG_PIC_STRUCT)
 		hevc_print(hevc, 0,
 			"%s(type %d index 0x%x)\n",

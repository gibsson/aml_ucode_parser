commit 3004c81eac6b0603686c3a3ea0aed061b13bfcb5
Author: Zhao Yi <zhao.yi@amlogic.com>
Date:   Thu Apr 18 19:28:45 2019 +0800

    mh264: check I frame [1/1]
    
    PD#SWPL-7098
    
    Problem:
    frame's Slice type is not set
    
    Solution:
    set slice type while a frame is decoded finished.
    
    Verify:
    T962X_R311
    
    Change-Id: If024a3e49b6d5573a10f49e22e401f7d91399638
    Signed-off-by: Zhao Yi <zhao.yi@amlogic.com>

diff --git a/drivers/frame_provider/decoder/h264_multi/h264_dpb.c b/drivers/frame_provider/decoder/h264_multi/h264_dpb.c
index 2c90194..8008310 100644
--- a/drivers/frame_provider/decoder/h264_multi/h264_dpb.c
+++ b/drivers/frame_provider/decoder/h264_multi/h264_dpb.c
@@ -1509,6 +1509,7 @@ static void dpb_combine_field(struct h264_dpb_stru *p_H264_Dpb,
 	fs->frame->buf_spec_num = fs->top_field->buf_spec_num;
 	fs->frame->colocated_buf_index = fs->top_field->colocated_buf_index;
 	fs->frame->data_flag = fs->top_field->data_flag;
+	fs->frame->slice_type = fs->top_field->slice_type;
 	if (fs->bottom_field)
 		fs->frame->data_flag |= (fs->bottom_field->data_flag & 0xf0);
 #endif
@@ -1613,6 +1614,7 @@ static void insert_picture_in_dpb(struct h264_dpb_stru *p_H264_Dpb,
 	fs->buf_spec_num = p->buf_spec_num;
 	fs->colocated_buf_index = p->colocated_buf_index;
 #endif
+	p->slice_type = p_H264_Dpb->mSlice.slice_type;
 	switch (p->structure) {
 	case FRAME:
 		fs->frame = p;
diff --git a/drivers/frame_provider/decoder/h264_multi/vmh264.c b/drivers/frame_provider/decoder/h264_multi/vmh264.c
index 02c0489..4f04816 100644
--- a/drivers/frame_provider/decoder/h264_multi/vmh264.c
+++ b/drivers/frame_provider/decoder/h264_multi/vmh264.c
@@ -2426,6 +2426,17 @@ static void fill_frame_info(struct vdec_h264_hw_s *hw, struct FrameStore *frame)
 	if (hw->frameinfo_enable)
 		vdec_fill_frame_info(vframe_qos, 1);
 }
+
+static int is_iframe(struct FrameStore *frame) {
+
+	if (frame->frame && frame->frame->slice_type == I_SLICE) {
+		return 1;
+	}
+	return 0;
+}
+
+
+
 int prepare_display_buf(struct vdec_s *vdec, struct FrameStore *frame)
 {
 	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)vdec->private;
@@ -2464,6 +2475,14 @@ int prepare_display_buf(struct vdec_s *vdec, struct FrameStore *frame)
 			__func__, buffer_index,  frame->data_flag & ERROR_FLAG,
 			frame->poc, hw->data_flag & ERROR_FLAG,
 			error_proc_policy);
+	if (frame->frame == NULL &&
+			((frame->is_used == 1 && frame->top_field)
+			|| (frame->is_used == 2 && frame->bottom_field))) {
+			dpb_print(DECODE_ID(hw), PRINT_FLAG_ERRORFLAG_DBG,
+				"%s Error  frame_num %d  used %d\n",
+					frame->frame_num, frame->is_used);
+			frame->data_flag |= ERROR_FLAG;
+	}
 
 	if ((frame->data_flag & NODISP_FLAG) ||
 		(frame->data_flag & NULL_FLAG) ||
@@ -2511,7 +2530,7 @@ int prepare_display_buf(struct vdec_s *vdec, struct FrameStore *frame)
 			return -1;
 		}
 		vf->duration_pulldown = 0;
-		if (!(frame->frame->slice_type == I_SLICE) && hw->unstable_pts) {
+		if (!(is_iframe(frame)) && hw->unstable_pts) {
 			vf->pts = 0;
 			vf->pts_us64 = 0;
 			vf->timestamp = 0;

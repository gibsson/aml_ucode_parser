commit c8ed76ed9246256a3a3e0e4a39441f52ccf312d9
Author: shihong.zheng <shihong.zheng@amlogic.com>
Date:   Mon May 13 21:27:45 2019 +0800

    media_module: fix stress test mem crash issue. [1/1]
    
    PD#SWPL-8484
    
    Problem:
     memory crashed when play vmmpeg4, vmh264.
    
    Solution:
    1) set force exit and wait disconnected;
    2) change timeout to 1000ms in remove to make sure
       work be finished completely;
    3) disable vdec irq before vdec work complete;
    4) regulate the workqueue cancel order.
    
    Verify:
    x301
    
    Change-Id: Ie625d01818297b3912811f53d21abb2fb96966bc
    Signed-off-by: shihong.zheng <shihong.zheng@amlogic.com>

diff --git a/drivers/frame_provider/decoder/h264_multi/vmh264.c b/drivers/frame_provider/decoder/h264_multi/vmh264.c
index bdc16f1..1cc5df5 100644
--- a/drivers/frame_provider/decoder/h264_multi/vmh264.c
+++ b/drivers/frame_provider/decoder/h264_multi/vmh264.c
@@ -4713,7 +4713,7 @@ static void vui_config(struct vdec_h264_hw_s *hw)
 						FIX_FRAME_RATE_OFF;
 					hw->pts_duration = 0;
 					hw->frame_dur = frame_dur_es;
-					schedule_work(&hw->notify_work);
+					vdec_schedule_work(&hw->notify_work);
 					dpb_print(DECODE_ID(hw),
 						PRINT_FLAG_DEC_DETAIL,
 						"frame_dur %d from timing_info\n",
@@ -6888,12 +6888,13 @@ static int vh264_stop(struct vdec_h264_hw_s *hw)
 #ifdef VDEC_DW
 	WRITE_VREG(MDEC_DOUBLEW_CFG0, 0);
 #endif
-	cancel_work_sync(&hw->work);
-	cancel_work_sync(&hw->notify_work);
-	cancel_work_sync(&hw->timeout_work);
 #ifdef MH264_USERDATA_ENABLE
 	cancel_work_sync(&hw->user_data_ready_work);
 #endif
+	cancel_work_sync(&hw->notify_work);
+	cancel_work_sync(&hw->timeout_work);
+	cancel_work_sync(&hw->work);
+
 
 	if (hw->stat & STAT_MC_LOAD) {
 		if (hw->mc_cpu_addr != NULL) {
@@ -7372,7 +7373,7 @@ static void vmh264_udc_fill_vpts(struct vdec_h264_hw_s *hw,
 		p_H264_Dpb->mVideo.dec_picture->pic_struct << 12;
 
 	hw->wait_for_udr_send = 1;
-	schedule_work(&hw->user_data_ready_work);
+	vdec_schedule_work(&hw->user_data_ready_work);
 #endif
 }
 
@@ -7628,7 +7629,6 @@ static void vh264_work(struct work_struct *work)
 	struct vdec_h264_hw_s *hw = container_of(work,
 		struct vdec_h264_hw_s, work);
 	struct vdec_s *vdec = hw_to_vdec(hw);
-
 	/* finished decoding one frame or error,
 	 * notify vdec core to switch context
 	 */
@@ -7689,13 +7689,13 @@ static void vh264_work(struct work_struct *work)
 			int r;
 			int decode_size;
 			r = vdec_prepare_input(vdec, &hw->chunk);
-			if (r < 0) {
+			if (r < 0 && (hw_to_vdec(hw)->next_status !=
+						VDEC_STATUS_DISCONNECTED)) {
 				hw->dec_result = DEC_RESULT_GET_DATA_RETRY;
 
 				dpb_print(DECODE_ID(hw),
 					PRINT_FLAG_VDEC_DETAIL,
 					"vdec_prepare_input: Insufficient data\n");
-
 				vdec_schedule_work(&hw->work);
 				return;
 			}
@@ -7748,8 +7748,11 @@ static void vh264_work(struct work_struct *work)
 			WRITE_VREG(DPB_STATUS_REG, H264_ACTION_SEARCH_HEAD);
 			start_process_time(hw);
 		} else{
-			hw->dec_result = DEC_RESULT_GET_DATA_RETRY;
-			vdec_schedule_work(&hw->work);
+			if (hw_to_vdec(hw)->next_status
+				!=	VDEC_STATUS_DISCONNECTED) {
+				hw->dec_result = DEC_RESULT_GET_DATA_RETRY;
+				vdec_schedule_work(&hw->work);
+			}
 		}
 		return;
 	} else if (hw->dec_result == DEC_RESULT_DONE) {
@@ -7801,7 +7804,8 @@ result_done:
 			stream base: stream buf empty or timeout
 			frame base: vdec_prepare_input fail
 		*/
-		if (!vdec_has_more_input(vdec)) {
+		if (!vdec_has_more_input(vdec) && (hw_to_vdec(hw)->next_status !=
+			VDEC_STATUS_DISCONNECTED)) {
 			hw->dec_result = DEC_RESULT_EOS;
 			vdec_schedule_work(&hw->work);
 			return;
@@ -7832,12 +7836,11 @@ result_done:
 		if (hw->mmu_enable)
 			amhevc_stop();
 		if (hw->stat & STAT_ISR_REG) {
-			WRITE_VREG(ASSIST_MBOX1_MASK, 0);
 			vdec_free_irq(VDEC_IRQ_1, (void *)hw);
 			hw->stat &= ~STAT_ISR_REG;
 		}
 	}
-
+	WRITE_VREG(ASSIST_MBOX1_MASK, 0);
 	del_timer_sync(&hw->check_timer);
 	hw->stat &= ~STAT_TIMER_ARM;
 
@@ -8675,7 +8678,7 @@ static int ammvdec_h264_probe(struct platform_device *pdev)
 		   (u32)sei_data_buffer_remap); */
 	}
 #endif
-	pr_debug("ammvdec_h264 mem-addr=%lx,buff_offset=%x,buf_start=%lx\n",
+	dpb_print(DECODE_ID(hw), 0, "ammvdec_h264 mem-addr=%lx,buff_offset=%x,buf_start=%lx\n",
 		pdata->mem_start, hw->buf_offset, hw->cma_alloc_addr);
 
 	if (vdec_is_support_4k() ||
@@ -8730,12 +8733,13 @@ static int ammvdec_h264_remove(struct platform_device *pdev)
 
 	if (vdec->next_status == VDEC_STATUS_DISCONNECTED
 				&& (vdec->status == VDEC_STATUS_ACTIVE)) {
-			pr_info("%s  force exit %d\n", __func__, __LINE__);
+			dpb_print(DECODE_ID(hw), 0,
+				"%s  force exit %d\n", __func__, __LINE__);
 			hw->dec_result = DEC_RESULT_FORCE_EXIT;
 			vdec_schedule_work(&hw->work);
 			wait_event_interruptible_timeout(hw->wait_q,
 				(vdec->status == VDEC_STATUS_CONNECTED),
-				msecs_to_jiffies(50));  /* wait for work done */
+				msecs_to_jiffies(1000));  /* wait for work done */
 	}
 
 	for (i = 0; i < BUFSPEC_POOL_SIZE; i++)
diff --git a/drivers/frame_provider/decoder/h265/vh265.c b/drivers/frame_provider/decoder/h265/vh265.c
index fd4bcd7..48c55ed 100644
--- a/drivers/frame_provider/decoder/h265/vh265.c
+++ b/drivers/frame_provider/decoder/h265/vh265.c
@@ -9571,7 +9571,7 @@ pic_done:
 						vui_num_units_in_tick,
 						vui_time_scale);
 					if (hevc->get_frame_dur != true)
-						schedule_work(
+						vdec_schedule_work(
 						&hevc->notify_work);
 
 				hevc->get_frame_dur = true;
@@ -10086,7 +10086,7 @@ static void vh265_check_timer_func(unsigned long arg)
 		hevc->frame_dur > 0 && hevc->saved_resolution !=
 		hevc->frame_width * hevc->frame_height *
 			(96000 / hevc->frame_dur))
-		schedule_work(&hevc->set_clk_work);
+		vdec_schedule_work(&hevc->set_clk_work);
 
 	mod_timer(timer, jiffies + PUT_INTERVAL);
 }
@@ -10921,9 +10921,9 @@ static int vmh265_stop(struct hevc_state_s *hevc)
 	}
 	hevc->init_flag = 0;
 	hevc->first_sc_checked = 0;
-	cancel_work_sync(&hevc->work);
 	cancel_work_sync(&hevc->notify_work);
 	cancel_work_sync(&hevc->set_clk_work);
+	cancel_work_sync(&hevc->work);
 	uninit_mmu_buffers(hevc);
 
 	vfree(hevc->fw);
diff --git a/drivers/frame_provider/decoder/mjpeg/vmjpeg_multi.c b/drivers/frame_provider/decoder/mjpeg/vmjpeg_multi.c
index 82abf8e..cf7dac4 100644
--- a/drivers/frame_provider/decoder/mjpeg/vmjpeg_multi.c
+++ b/drivers/frame_provider/decoder/mjpeg/vmjpeg_multi.c
@@ -1055,8 +1055,6 @@ static void vmjpeg_work(struct work_struct *work)
 		pr_info("%s: force exit\n", __func__);
 		if (hw->stat & STAT_ISR_REG) {
 			amvdec_stop();
-			/*disable mbox interrupt */
-			WRITE_VREG(ASSIST_MBOX1_MASK, 0);
 			vdec_free_irq(VDEC_IRQ_1, (void *)hw);
 			hw->stat &= ~STAT_ISR_REG;
 		}
@@ -1075,6 +1073,8 @@ static void vmjpeg_work(struct work_struct *work)
 		amvdec_stop();
 		hw->stat &= ~STAT_VDEC_RUN;
 	}
+	/*disable mbox interrupt */
+	WRITE_VREG(ASSIST_MBOX1_MASK, 0);
 	wait_vmjpeg_search_done(hw);
 	/* mark itself has all HW resource released and input released */
 	if (vdec->parallel_dec == 1)
diff --git a/drivers/frame_provider/decoder/mpeg12/vmpeg12_multi.c b/drivers/frame_provider/decoder/mpeg12/vmpeg12_multi.c
index a8962dd..4de7edc 100644
--- a/drivers/frame_provider/decoder/mpeg12/vmpeg12_multi.c
+++ b/drivers/frame_provider/decoder/mpeg12/vmpeg12_multi.c
@@ -399,7 +399,7 @@ static void set_frame_info(struct vdec_mpeg12_hw_s *hw, struct vframe_s *vf)
 	else {
 		vf->duration = hw->frame_dur =
 		frame_rate_tab[(READ_VREG(MREG_SEQ_INFO) >> 4) & 0xf];
-		schedule_work(&hw->notify_work);
+		vdec_schedule_work(&hw->notify_work);
 	}
 
 	ar_bits = READ_VREG(MREG_SEQ_INFO) & 0xf;
@@ -1782,8 +1782,6 @@ static void vmpeg12_work(struct work_struct *work)
 		"%s: force exit\n", __func__);
 		if (hw->stat & STAT_ISR_REG) {
 			amvdec_stop();
-			/*disable mbox interrupt */
-			WRITE_VREG(ASSIST_MBOX1_MASK, 0);
 			vdec_free_irq(VDEC_IRQ_1, (void *)hw);
 			hw->stat &= ~STAT_ISR_REG;
 		}
@@ -1802,6 +1800,8 @@ static void vmpeg12_work(struct work_struct *work)
 		amvdec_stop();
 		hw->stat &= ~STAT_VDEC_RUN;
 	}
+	/*disable mbox interrupt */
+	WRITE_VREG(ASSIST_MBOX1_MASK, 0);
 	wait_vmmpeg12_search_done(hw);
 	if (vdec->parallel_dec == 1)
 		vdec_core_finish_run(hw_to_vdec(hw), CORE_MASK_VDEC_1);
@@ -2248,6 +2248,8 @@ static int vmpeg12_hw_ctx_restore(struct vdec_mpeg12_hw_s *hw)
 	WRITE_VREG(ASSIST_MBOX1_CLR_REG, 1);
 	/* clear buffer IN/OUT registers */
 	WRITE_VREG(MREG_BUFFEROUT, 0);
+	/* enable mailbox interrupt */
+	WRITE_VREG(ASSIST_MBOX1_MASK, 1);
 	/* set reference width and height */
 	if ((hw->frame_width != 0) && (hw->frame_height != 0))
 		WRITE_VREG(MREG_CMD,
@@ -2714,8 +2716,8 @@ static int ammvdec_mpeg12_remove(struct platform_device *pdev)
 		hw->stat &= ~STAT_TIMER_ARM;
 	}
 	cancel_work_sync(&hw->userdata_push_work);
-	cancel_work_sync(&hw->work);
 	cancel_work_sync(&hw->notify_work);
+	cancel_work_sync(&hw->work);
 
 	if (hw->mm_blk_handle) {
 		decoder_bmmu_box_free(hw->mm_blk_handle);
diff --git a/drivers/frame_provider/decoder/mpeg4/vmpeg4_multi.c b/drivers/frame_provider/decoder/mpeg4/vmpeg4_multi.c
index a1b29d0..44df052 100644
--- a/drivers/frame_provider/decoder/mpeg4/vmpeg4_multi.c
+++ b/drivers/frame_provider/decoder/mpeg4/vmpeg4_multi.c
@@ -59,7 +59,7 @@
 #define I_PICTURE   0
 #define P_PICTURE   1
 #define B_PICTURE   2
-#define GET_PIC_TYPE(type) ("IPB########"[type])
+#define GET_PIC_TYPE(type) ("IPB####"[type&0x3])
 
 #define ORI_BUFFER_START_ADDR   0x01000000
 #define DEFAULT_MEM_SIZE	(32*SZ_1M)
@@ -279,6 +279,7 @@ struct vdec_mpeg4_hw_s {
 
 	struct firmware_s *fw;
 	u32 blkmode;
+	wait_queue_head_t wait_q;
 };
 static void vmpeg4_local_init(struct vdec_mpeg4_hw_s *hw);
 static int vmpeg4_hw_ctx_restore(struct vdec_mpeg4_hw_s *hw);
@@ -683,7 +684,7 @@ static irqreturn_t vmpeg4_isr_thread_fn(struct vdec_s *vdec, int irq)
 		} else {
 			reset_process_time(hw);
 			hw->dec_result = DEC_RESULT_AGAIN;
-			schedule_work(&hw->work);
+			vdec_schedule_work(&hw->work);
 		}
 		return IRQ_HANDLED;
 	} else {
@@ -697,7 +698,7 @@ static irqreturn_t vmpeg4_isr_thread_fn(struct vdec_s *vdec, int irq)
 			mmpeg4_debug_print(DECODE_ID(hw), 0,
 				"invalid buffer index.");
 			hw->dec_result = DEC_RESULT_ERROR;
-			schedule_work(&hw->work);
+			vdec_schedule_work(&hw->work);
 			return IRQ_HANDLED;
 		}
 		hw->dec_result = DEC_RESULT_DONE;
@@ -813,7 +814,7 @@ static irqreturn_t vmpeg4_isr_thread_fn(struct vdec_s *vdec, int irq)
 		}
 		vmpeg4_save_hw_context(hw);
 		if (index < 0) {
-			schedule_work(&hw->work);
+			vdec_schedule_work(&hw->work);
 			return IRQ_HANDLED;
 		}
 		disp_pic = &hw->pic[index];
@@ -907,7 +908,7 @@ static irqreturn_t vmpeg4_isr_thread_fn(struct vdec_s *vdec, int irq)
 
 		hw->total_frame += repeat_cnt + 1;
 		hw->last_vop_time_inc = vop_time_inc;
-		schedule_work(&hw->work);
+		vdec_schedule_work(&hw->work);
 	}
 	mmpeg4_debug_print(DECODE_ID(hw), PRINT_FRAME_NUM,
 		"%s: frame num:%d\n", __func__, hw->frame_num);
@@ -975,8 +976,6 @@ static void vmpeg4_work(struct work_struct *work)
 			"%s: force exit\n", __func__);
 		if (hw->stat & STAT_ISR_REG) {
 			amvdec_stop();
-			/*disable mbox interrupt */
-			WRITE_VREG(ASSIST_MBOX1_MASK, 0);
 			vdec_free_irq(VDEC_IRQ_1, (void *)hw);
 			hw->stat &= ~STAT_ISR_REG;
 		}
@@ -999,6 +998,8 @@ static void vmpeg4_work(struct work_struct *work)
 		amvdec_stop();
 		hw->stat &= ~STAT_VDEC_RUN;
 	}
+	/*disable mbox interrupt */
+	WRITE_VREG(ASSIST_MBOX1_MASK, 0);
 	del_timer_sync(&hw->check_timer);
 	hw->stat &= ~STAT_TIMER_ARM;
 
@@ -1008,6 +1009,7 @@ static void vmpeg4_work(struct work_struct *work)
 	else
 		vdec_core_finish_run(vdec, CORE_MASK_VDEC_1 | CORE_MASK_HEVC);
 
+	wake_up_interruptible(&hw->wait_q);
 	if (hw->vdec_cb)
 		hw->vdec_cb(vdec, hw->vdec_cb_arg);
 }
@@ -1565,6 +1567,8 @@ static void vmpeg4_local_init(struct vdec_mpeg4_hw_s *hw)
 			CODEC_MM_FLAGS_CMA_CLEAR |
 			CODEC_MM_FLAGS_FOR_VDECODER);
 	INIT_WORK(&hw->work, vmpeg4_work);
+
+	init_waitqueue_head(&hw->wait_q);
 }
 
 static s32 vmmpeg4_init(struct vdec_mpeg4_hw_s *hw)
@@ -1692,7 +1696,7 @@ static void run(struct vdec_s *vdec, unsigned long mask,
 	if (size < 4) { /*less than start code size 00 00 01 xx*/
 		hw->input_empty++;
 		hw->dec_result = DEC_RESULT_AGAIN;
-		schedule_work(&hw->work);
+		vdec_schedule_work(&hw->work);
 		return;
 	}
 
@@ -1768,7 +1772,7 @@ static void run(struct vdec_s *vdec, unsigned long mask,
 			pr_err("[%d] %s: the %s fw loading failed, err: %x\n", vdec->id,
 				hw->fw->name, tee_enabled() ? "TEE" : "local", ret);
 			hw->dec_result = DEC_RESULT_FORCE_EXIT;
-			schedule_work(&hw->work);
+			vdec_schedule_work(&hw->work);
 			return;
 		}
 		vdec->mc_loaded = 1;
@@ -1778,7 +1782,7 @@ static void run(struct vdec_s *vdec, unsigned long mask,
 		hw->dec_result = DEC_RESULT_ERROR;
 		mmpeg4_debug_print(DECODE_ID(hw), 0,
 			"amvdec_mpeg4: error HW context restore\n");
-		schedule_work(&hw->work);
+		vdec_schedule_work(&hw->work);
 		return;
 	}
 	hw->input_empty = 0;
@@ -1830,8 +1834,6 @@ static int ammvdec_mpeg4_probe(struct platform_device *pdev)
 	struct vdec_s *pdata = *(struct vdec_s **)pdev->dev.platform_data;
 	struct vdec_mpeg4_hw_s *hw = NULL;
 
-	pr_info("%s [%d] probe start.\n", __func__, pdev->id);
-
 	if (pdata == NULL) {
 		pr_err("%s memory resource undefined.\n", __func__);
 		return -EFAULT;
@@ -1874,26 +1876,7 @@ static int ammvdec_mpeg4_probe(struct platform_device *pdev)
 	hw->platform_dev = pdev;
 	hw->blkmode = pdata->canvas_mode;
 
-/*
-	hw->cma_dev = pdata->cma_dev;
-	hw->cma_alloc_count = PAGE_ALIGN(DEFAULT_MEM_SIZE) / PAGE_SIZE;
-	hw->cma_alloc_addr = codec_mm_alloc_for_dma(MEM_NAME,
-				hw->cma_alloc_count,
-				4, CODEC_MM_FLAGS_FOR_VDECODER);
-
-	if (!hw->cma_alloc_addr) {
-		pr_err("codec_mm alloc failed, request buf size 0x%lx\n",
-			hw->cma_alloc_count * PAGE_SIZE);
-		hw->cma_alloc_count = 0;
-		if (hw) {
-			vfree((void *)hw);
-			hw = NULL;
-		}
-		return -ENOMEM;
-	}
-	hw->buf_start = hw->cma_alloc_addr;
-	hw->buf_size = DEFAULT_MEM_SIZE;
-*/
+
 	if (pdata->sys_info) {
 		hw->vmpeg4_amstream_dec_info = *pdata->sys_info;
 		if ((hw->vmpeg4_amstream_dec_info.height != 0) &&
@@ -1910,20 +1893,15 @@ static int ammvdec_mpeg4_probe(struct platform_device *pdev)
 	}
 	mmpeg4_debug_print(DECODE_ID(hw), PRINT_FLAG_ERROR,
 		"W:%d,H:%d,rate=%d\n",
-	hw->vmpeg4_amstream_dec_info.width,
-	hw->vmpeg4_amstream_dec_info.height,
-	hw->vmpeg4_amstream_dec_info.rate);
-	hw->vmpeg4_amstream_dec_info.height = 0;
-	hw->vmpeg4_amstream_dec_info.width = 0;
+		hw->vmpeg4_amstream_dec_info.width,
+		hw->vmpeg4_amstream_dec_info.height,
+		hw->vmpeg4_amstream_dec_info.rate);
+		hw->vmpeg4_amstream_dec_info.height = 0;
+		hw->vmpeg4_amstream_dec_info.width = 0;
 
 	if (vmmpeg4_init(hw) < 0) {
 		pr_err("%s init failed.\n", __func__);
-/*
-		if (hw->cma_alloc_addr) {
-			codec_mm_free_for_dma(MEM_NAME, hw->cma_alloc_addr);
-			hw->cma_alloc_count = 0;
-		}
-*/
+
 		if (hw) {
 			vfree((void *)hw);
 			hw = NULL;
@@ -1938,6 +1916,9 @@ static int ammvdec_mpeg4_probe(struct platform_device *pdev)
 				| CORE_MASK_COMBINE);
 	}
 
+	mmpeg4_debug_print(DECODE_ID(hw), 0,
+		"%s end.\n", __func__);
+
 	return 0;
 }
 
@@ -1949,14 +1930,19 @@ static int ammvdec_mpeg4_remove(struct platform_device *pdev)
 	struct vdec_s *vdec = hw_to_vdec(hw);
 	int i;
 
-	vmpeg4_stop(hw);
-	/*
-	if (hw->cma_alloc_addr) {
-		pr_info("codec_mm release buffer 0x%lx\n", hw->cma_alloc_addr);
-		codec_mm_free_for_dma(MEM_NAME, hw->cma_alloc_addr);
-		hw->cma_alloc_count = 0;
+	if (vdec->next_status == VDEC_STATUS_DISCONNECTED
+				&& (vdec->status == VDEC_STATUS_ACTIVE)) {
+			mmpeg4_debug_print(DECODE_ID(hw), 0,
+				"%s  force exit %d\n", __func__, __LINE__);
+			hw->dec_result = DEC_RESULT_FORCE_EXIT;
+			vdec_schedule_work(&hw->work);
+			wait_event_interruptible_timeout(hw->wait_q,
+				(vdec->status == VDEC_STATUS_CONNECTED),
+				msecs_to_jiffies(1000));  /* wait for work done */
 	}
-	*/
+
+	vmpeg4_stop(hw);
+
 	if (vdec->parallel_dec == 1)
 		vdec_core_release(hw_to_vdec(hw), CORE_MASK_VDEC_1);
 	else
@@ -1970,10 +1956,7 @@ static int ammvdec_mpeg4_remove(struct platform_device *pdev)
 		}
 	}
 
-	pr_info("pts hit %d, pts missed %d, i hit %d, missed %d\n", hw->pts_hit,
-		   hw->pts_missed, hw->pts_i_hit, hw->pts_i_missed);
-	pr_info("total frame %d, rate %d\n", hw->total_frame,
-		   hw->vmpeg4_amstream_dec_info.rate);
+	mmpeg4_debug_print(DECODE_ID(hw), 0, "%s\n", __func__);
 	vfree((void *)hw);
 	hw = NULL;
 
diff --git a/drivers/frame_provider/decoder/vp9/vvp9.c b/drivers/frame_provider/decoder/vp9/vvp9.c
index fab34a5..3952333 100644
--- a/drivers/frame_provider/decoder/vp9/vvp9.c
+++ b/drivers/frame_provider/decoder/vp9/vvp9.c
@@ -7763,7 +7763,7 @@ static void vvp9_put_timer_func(unsigned long arg)
 		pbi->frame_dur > 0 && pbi->saved_resolution !=
 		frame_width * frame_height *
 			(96000 / pbi->frame_dur))
-		schedule_work(&pbi->set_clk_work);
+		vdec_schedule_work(&pbi->set_clk_work);
 
 	timer->expires = jiffies + PUT_INTERVAL;
 	add_timer(timer);
@@ -8222,19 +8222,19 @@ static int vvp9_stop(struct VP9Decoder_s *pbi)
 	}
 	vp9_local_uninit(pbi);
 
+	cancel_work_sync(&pbi->set_clk_work);
 #ifdef MULTI_INSTANCE_SUPPORT
 	if (pbi->m_ins_flag) {
-		cancel_work_sync(&pbi->work);
 #ifdef SUPPORT_FB_DECODING
 		if (pbi->used_stage_buf_num > 0)
 			cancel_work_sync(&pbi->s1_work);
 #endif
+		cancel_work_sync(&pbi->work);
 	} else
 		amhevc_disable();
 #else
 	amhevc_disable();
 #endif
-	cancel_work_sync(&pbi->set_clk_work);
 	uninit_mmu_buffers(pbi);
 
 	vfree(pbi->fw);

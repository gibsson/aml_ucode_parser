commit 33d1149b1003e6f56e54c7f94f33215f0c47ac01
Author: apollo.ling <apollo.ling@amlogic.com>
Date:   Wed Jul 3 10:54:37 2019 +0800

    media_module: Decoder add scaling down config for 1080p(dw mode 0x300) [1/1]
    
    PD#SWPL-10642
    
    Problem:
    Add dw mode 0x300
    
    Solution:
    resolution>720p,vdec ratio 1/2,others vdec ratio 1/1
    
    Verify:
    franklin
    
    Change-Id: Ibeb06fcea18f8fd61fa67153af9e8c4862b5bc27
    Signed-off-by: apollo.ling <apollo.ling@amlogic.com>

diff --git a/drivers/frame_provider/decoder/avs2/vavs2.c b/drivers/frame_provider/decoder/avs2/vavs2.c
index f662f91..e958825 100644
--- a/drivers/frame_provider/decoder/avs2/vavs2.c
+++ b/drivers/frame_provider/decoder/avs2/vavs2.c
@@ -254,12 +254,17 @@ static u32 again_threshold = 0x40;
 
 
 /* DOUBLE_WRITE_MODE is enabled only when NV21 8 bit output is needed */
-/* double_write_mode: 0, no double write
-					  1, 1:1 ratio
-					  2, (1/4):(1/4) ratio
-					  4, (1/2):(1/2) ratio
-					0x10, double write only
-*/
+/* double_write_mode:
+ *	0, no double write;
+ *	1, 1:1 ratio;
+ *	2, (1/4):(1/4) ratio;
+ *	3, (1/4):(1/4) ratio, with both compressed frame included
+ *	4, (1/2):(1/2) ratio;
+ *	0x10, double write only
+ *	0x100, if > 1080p,use mode 4,else use mode 1;
+ *	0x200, if > 1080p,use mode 2,else use mode 1;
+ *	0x300, if > 720p, use mode 4, else use mode 1;
+ */
 static u32 double_write_mode;
 
 #define DRIVER_NAME "amvdec_avs2"
@@ -870,37 +875,56 @@ static u32 get_valid_double_write_mode(struct AVS2Decoder_s *dec)
 static int get_double_write_mode(struct AVS2Decoder_s *dec)
 {
 	u32 valid_dw_mode = get_valid_double_write_mode(dec);
-	u32 dw;
-	if (valid_dw_mode == 0x100) {
-		int w = dec->avs2_dec.img.width;
-		int h = dec->avs2_dec.img.height;
+	int w = dec->avs2_dec.img.width;
+	int h = dec->avs2_dec.img.height;
+	u32 dw = 0x1; /*1:1*/
+	switch (valid_dw_mode) {
+	case 0x100:
 		if (w > 1920 && h > 1088)
 			dw = 0x4; /*1:2*/
-		else
-			dw = 0x1; /*1:1*/
-
-		return dw;
+		break;
+	case 0x200:
+		if (w > 1920 && h > 1088)
+			dw = 0x2; /*1:4*/
+		break;
+	case 0x300:
+		if (w > 1280 && h > 720)
+			dw = 0x4; /*1:2*/
+		break;
+	default:
+		dw = valid_dw_mode;
+		break;
 	}
-
-	return valid_dw_mode;
+	return dw;
 }
 
 /* for double write buf alloc */
 static int get_double_write_mode_init(struct AVS2Decoder_s *dec)
 {
 	u32 valid_dw_mode = get_valid_double_write_mode(dec);
-	if (valid_dw_mode == 0x100) {
-		u32 dw;
-		int w = dec->init_pic_w;
-		int h = dec->init_pic_h;
+	u32 dw;
+	int w = dec->init_pic_w;
+	int h = dec->init_pic_h;
+
+	dw = 0x1; /*1:1*/
+	switch (valid_dw_mode) {
+	case 0x100:
 		if (w > 1920 && h > 1088)
 			dw = 0x4; /*1:2*/
-		else
-			dw = 0x1; /*1:1*/
-
-		return dw;
+		break;
+	case 0x200:
+		if (w > 1920 && h > 1088)
+			dw = 0x2; /*1:4*/
+		break;
+	case 0x300:
+		if (w > 1280 && h > 720)
+			dw = 0x4; /*1:2*/
+		break;
+	default:
+		dw = valid_dw_mode;
+		break;
 	}
-	return valid_dw_mode;
+	return dw;
 }
 
 static int get_double_write_ratio(struct AVS2Decoder_s *dec,
diff --git a/drivers/frame_provider/decoder/h265/vh265.c b/drivers/frame_provider/decoder/h265/vh265.c
index 34b198c..f21cf63 100644
--- a/drivers/frame_provider/decoder/h265/vh265.c
+++ b/drivers/frame_provider/decoder/h265/vh265.c
@@ -222,12 +222,16 @@ static const char * const matrix_coeffs_names[] = {
 #define HEVC_SAO_CTRL9                             0x362d
 #define LOSLESS_COMPRESS_MODE
 /* DOUBLE_WRITE_MODE is enabled only when NV21 8 bit output is needed */
-/* hevc->double_write_mode:
+/* double_write_mode:
  *	0, no double write;
  *	1, 1:1 ratio;
  *	2, (1/4):(1/4) ratio;
  *	3, (1/4):(1/4) ratio, with both compressed frame included
+ *	4, (1/2):(1/2) ratio;
  *	0x10, double write only
+ *	0x100, if > 1080p,use mode 4,else use mode 1;
+ *	0x200, if > 1080p,use mode 2,else use mode 1;
+ *	0x300, if > 720p, use mode 4, else use mode 1;
  */
 static u32 double_write_mode;
 
@@ -1909,17 +1913,26 @@ static int get_dynamic_buf_num_margin(struct hevc_state_s *hevc)
 static int get_double_write_mode(struct hevc_state_s *hevc)
 {
 	u32 valid_dw_mode = get_valid_double_write_mode(hevc);
-	u32 dw = hevc->double_write_mode;
-	if (valid_dw_mode == 0x100) {
-		int w = hevc->pic_w;
-		int h = hevc->pic_h;
+	int w = hevc->pic_w;
+	int h = hevc->pic_h;
+	u32 dw = 0x1; /*1:1*/
+	switch (valid_dw_mode) {
+	case 0x100:
 		if (w > 1920 && h > 1088)
 			dw = 0x4; /*1:2*/
-		else
-			dw = 0x1; /*1:1*/
-
-	} else
+		break;
+	case 0x200:
+		if (w > 1920 && h > 1088)
+			dw = 0x2; /*1:4*/
+		break;
+	case 0x300:
+		if (w > 1280 && h > 720)
+			dw = 0x4; /*1:2*/
+		break;
+	default:
 		dw = valid_dw_mode;
+		break;
+	}
 	return dw;
 }
 
diff --git a/drivers/frame_provider/decoder/vp9/vvp9.c b/drivers/frame_provider/decoder/vp9/vvp9.c
index aeb7e6b..e2fb8fb 100644
--- a/drivers/frame_provider/decoder/vp9/vvp9.c
+++ b/drivers/frame_provider/decoder/vp9/vvp9.c
@@ -166,12 +166,17 @@ static u32 work_buf_size;
 static u32 mv_buf_margin;
 
 /* DOUBLE_WRITE_MODE is enabled only when NV21 8 bit output is needed */
-/* double_write_mode: 0, no double write
-					  1, 1:1 ratio
-					  2, (1/4):(1/4) ratio
-					  4, (1/2):(1/2) ratio
-					0x10, double write only
-*/
+/* double_write_mode:
+ *	0, no double write;
+ *	1, 1:1 ratio;
+ *	2, (1/4):(1/4) ratio;
+ *	3, (1/4):(1/4) ratio, with both compressed frame included
+ *	4, (1/2):(1/2) ratio;
+ *	0x10, double write only
+ *	0x100, if > 1080p,use mode 4,else use mode 1;
+ *	0x200, if > 1080p,use mode 2,else use mode 1;
+ *	0x300, if > 720p, use mode 4, else use mode 1;
+ */
 static u32 double_write_mode;
 
 #define DRIVER_NAME "amvdec_vp9"
@@ -1570,43 +1575,64 @@ static int get_double_write_mode(struct VP9Decoder_s *pbi)
 {
 	u32 valid_dw_mode = get_valid_double_write_mode(pbi);
 	u32 dw;
-	if (valid_dw_mode == 0x100) {
-		struct VP9_Common_s *cm = &pbi->common;
-		struct PIC_BUFFER_CONFIG_s *cur_pic_config;
-		int w, h;
-
-		if (!cm->cur_frame)
-			return 1;/*no valid frame,*/
-		cur_pic_config = &cm->cur_frame->buf;
-		w = cur_pic_config->y_crop_width;
-		h = cur_pic_config->y_crop_width;
+	int w, h;
+	struct VP9_Common_s *cm = &pbi->common;
+	struct PIC_BUFFER_CONFIG_s *cur_pic_config;
+
+	if (!cm->cur_frame)
+		return 1;/*no valid frame,*/
+	cur_pic_config = &cm->cur_frame->buf;
+	w = cur_pic_config->y_crop_width;
+	h = cur_pic_config->y_crop_height;
+
+	dw = 0x1; /*1:1*/
+	switch (valid_dw_mode) {
+	case 0x100:
 		if (w > 1920 && h > 1088)
 			dw = 0x4; /*1:2*/
-		else
-			dw = 0x1; /*1:1*/
-
-		return dw;
+		break;
+	case 0x200:
+		if (w > 1920 && h > 1088)
+			dw = 0x2; /*1:4*/
+		break;
+	case 0x300:
+		if (w > 1280 && h > 720)
+			dw = 0x4; /*1:2*/
+		break;
+	default:
+		dw = valid_dw_mode;
+		break;
 	}
-
-	return valid_dw_mode;
+	return dw;
 }
 
 /* for double write buf alloc */
 static int get_double_write_mode_init(struct VP9Decoder_s *pbi)
 {
 	u32 valid_dw_mode = get_valid_double_write_mode(pbi);
-	if (valid_dw_mode == 0x100) {
-		u32 dw;
-		int w = pbi->init_pic_w;
-		int h = pbi->init_pic_h;
+	u32 dw;
+	int w = pbi->init_pic_w;
+	int h = pbi->init_pic_h;
+
+	dw = 0x1; /*1:1*/
+	switch (valid_dw_mode) {
+	case 0x100:
 		if (w > 1920 && h > 1088)
 			dw = 0x4; /*1:2*/
-		else
-			dw = 0x1; /*1:1*/
-
-		return dw;
+		break;
+	case 0x200:
+		if (w > 1920 && h > 1088)
+			dw = 0x2; /*1:4*/
+		break;
+	case 0x300:
+		if (w > 1280 && h > 720)
+			dw = 0x4; /*1:2*/
+		break;
+	default:
+		dw = valid_dw_mode;
+		break;
 	}
-	return valid_dw_mode;
+	return dw;
 }
 #endif
 

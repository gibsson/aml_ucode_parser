commit 0ed0f5720837533c6e40ef12db9aa3f7225842d0
Author: Peng Yixin <yixin.peng@amlogic.com>
Date:   Thu May 2 17:13:28 2019 +0800

    media: Optimizing multi-instance decoding scheduling time [1/1]
    
    PD#SWPL-8067
    
    Problem:
    When no data can be decoded, the decoding scheduler sleeps for 1-2 milliseconds,
    and when the decode's data arrived during sleep, it must wait for the sleep to
    end before can begin to decode, it will reduces overall performance.
    
    Solution:
    The optimized decoding scheduling code solves this issue
    
    Verify:
    X301
    
    Change-Id: I9d20927b2881babf484b8a509be556b486ea92bb
    Signed-off-by: Peng Yixin <yixin.peng@amlogic.com>

diff --git a/drivers/frame_provider/decoder/utils/vdec.c b/drivers/frame_provider/decoder/utils/vdec.c
index 9d9168b..4831169 100644
--- a/drivers/frame_provider/decoder/utils/vdec.c
+++ b/drivers/frame_provider/decoder/utils/vdec.c
@@ -148,6 +148,7 @@ struct vdec_core_s {
 	spinlock_t lock;
 	spinlock_t canvas_lock;
 	spinlock_t fps_lock;
+	spinlock_t input_lock;
 	struct ida ida;
 	atomic_t vdec_nr;
 	struct vdec_s *vfm_vdec;
@@ -168,6 +169,8 @@ struct vdec_core_s {
 	unsigned long power_ref_mask;
 	int vdec_combine_flag;
 	struct decode_fps_s decode_fps[MAX_INSTANCE_MUN];
+	unsigned long buff_flag;
+	unsigned long stream_buff_flag;
 };
 
 struct canvas_status_s {
@@ -265,6 +268,43 @@ void vdec_core_unlock(struct vdec_core_s *core, unsigned long flags)
 	spin_unlock_irqrestore(&core->lock, flags);
 }
 
+unsigned long vdec_inputbuff_lock(struct vdec_core_s *core)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&core->input_lock, flags);
+
+	return flags;
+}
+
+void vdec_inputbuff_unlock(struct vdec_core_s *core, unsigned long flags)
+{
+	spin_unlock_irqrestore(&core->input_lock, flags);
+}
+
+
+static bool vdec_is_input_frame_empty(struct vdec_s *vdec) {
+	struct vdec_core_s *core = vdec_core;
+	bool ret;
+	unsigned long flags;
+
+	flags = vdec_inputbuff_lock(core);
+	ret = !(vdec->core_mask && core->buff_flag);
+	vdec_inputbuff_unlock(core, flags);
+
+	return ret;
+}
+
+static void vdec_up(struct vdec_s *vdec)
+{
+	struct vdec_core_s *core = vdec_core;
+
+	if (debug & 8)
+		pr_info("vdec_up, id:%d\n", vdec->id);
+	up(&core->sem);
+}
+
+
 static u64 vdec_get_us_time_system(void)
 {
 	struct timeval tv;
@@ -514,6 +554,62 @@ static void vdec_save_active_hw(struct vdec_s *vdec)
 	}
 }
 
+static void vdec_update_buff_status(void)
+{
+	struct vdec_core_s *core = vdec_core;
+	unsigned long flags;
+	struct vdec_s *vdec;
+
+	flags = vdec_inputbuff_lock(core);
+	core->buff_flag = 0;
+	core->stream_buff_flag = 0;
+	list_for_each_entry(vdec, &core->connected_vdec_list, list) {
+		struct vdec_input_s *input = &vdec->input;
+		if (input_frame_based(input)) {
+			if (input->have_frame_num)
+				core->buff_flag |= vdec->core_mask;
+		} else if (input_stream_based(input)) {
+			if (!(vdec->need_more_data & VDEC_NEED_MORE_DATA))
+				core->stream_buff_flag |= vdec->core_mask;
+		}
+	}
+	vdec_inputbuff_unlock(core, flags);
+}
+
+
+void vdec_update_streambuff_status(void)
+{
+	struct vdec_core_s *core = vdec_core;
+	struct vdec_s *vdec;
+
+	/* check streaming prepare level threshold if not EOS */
+	list_for_each_entry(vdec, &core->connected_vdec_list, list) {
+		struct vdec_input_s *input = &vdec->input;
+		if (input && input_stream_based(input) && !input->eos &&
+			(vdec->need_more_data & VDEC_NEED_MORE_DATA)) {
+			u32 rp, wp, level;
+
+			rp = READ_PARSER_REG(PARSER_VIDEO_RP);
+			wp = READ_PARSER_REG(PARSER_VIDEO_WP);
+			if (wp < rp)
+				level = input->size + wp - rp;
+			else
+				level = wp - rp;
+			if ((level < input->prepare_level) &&
+				(pts_get_rec_num(PTS_TYPE_VIDEO,
+					vdec->input.total_rd_count) < 2)) {
+				break;
+			} else if (level > input->prepare_level) {
+				vdec->need_more_data &= ~VDEC_NEED_MORE_DATA;
+				if (debug & 8)
+					pr_info("vdec_flush_streambuff_status up\n");
+				vdec_up(vdec);
+			}
+			break;
+		}
+	}
+}
+EXPORT_SYMBOL(vdec_update_streambuff_status);
 
 int vdec_status(struct vdec_s *vdec, struct vdec_info *vstatus)
 {
@@ -784,6 +880,8 @@ struct vdec_s *vdec_create(struct stream_port_s *port,
 		atomic_inc(&vdec_core->vdec_nr);
 		vdec->id = id;
 		vdec_input_init(&vdec->input, vdec);
+		vdec->input.vdec_is_input_frame_empty = vdec_is_input_frame_empty;
+		vdec->input.vdec_up = vdec_up;
 		if (master) {
 			vdec->master = master;
 			master->slave = vdec;
@@ -2384,6 +2482,7 @@ thread_isr_done:
 
 unsigned long vdec_ready_to_run(struct vdec_s *vdec, unsigned long mask)
 {
+	struct vdec_core_s *core = vdec_core;
 	unsigned long ready_mask;
 	struct vdec_input_s *input = &vdec->input;
 	if ((vdec->status != VDEC_STATUS_CONNECTED) &&
@@ -2426,7 +2525,10 @@ unsigned long vdec_ready_to_run(struct vdec_s *vdec, unsigned long mask)
 			if ((level < input->prepare_level) &&
 				(pts_get_rec_num(PTS_TYPE_VIDEO,
 					vdec->input.total_rd_count) < 2)) {
+				if (debug & 8)
+					pr_info("ready to run VDEC_NEED_MORE_DATA\n");
 				vdec->need_more_data |= VDEC_NEED_MORE_DATA;
+				core->stream_buff_flag &= ~vdec->core_mask;
 #ifdef VDEC_DEBUG_SUPPORT
 				inc_profi_count(mask, vdec->input_underrun_count);
 				if (step_mode & 0x200) {
@@ -2437,8 +2539,7 @@ unsigned long vdec_ready_to_run(struct vdec_s *vdec, unsigned long mask)
 				}
 #endif
 				return false;
-			} else if (level > input->prepare_level)
-				vdec->need_more_data &= ~VDEC_NEED_MORE_DATA;
+			}
 		}
 	}
 
@@ -2529,6 +2630,7 @@ void vdec_prepare_run(struct vdec_s *vdec, unsigned long mask)
 	vdec->need_more_data &= ~VDEC_NEED_MORE_DATA_DIRTY;
 }
 
+
 /* struct vdec_core_shread manages all decoder instance in active list. When
  * a vdec is added into the active list, it can onlt be in two status:
  * VDEC_STATUS_CONNECTED(the decoder does not own HW resource and ready to run)
@@ -2599,7 +2701,7 @@ static int vdec_core_thread(void *data)
 			vdec->sched_mask &= ~mask;
 			core->sched_mask &= ~mask;
 		}
-
+		vdec_update_buff_status();
 		/*
 		 *todo:
 		 * this is the case when the decoder is in active mode and
@@ -2755,12 +2857,16 @@ static int vdec_core_thread(void *data)
 			if (vdec_core->vdec_combine_flag == 0) {
 				if ((!worker) &&
 					((core->sched_mask != core->power_ref_mask)) &&
-					(atomic_read(&vdec_core->vdec_nr) > 0)) {
+					(atomic_read(&vdec_core->vdec_nr) > 0) &&
+					((core->buff_flag | core->stream_buff_flag) &
+					(core->sched_mask ^ core->power_ref_mask))) {
 						usleep_range(1000, 2000);
 						up(&core->sem);
 				}
 			} else {
-				if ((!worker) && (!core->sched_mask) && (atomic_read(&vdec_core->vdec_nr) > 0)) {
+				if ((!worker) && (!core->sched_mask) &&
+					(atomic_read(&vdec_core->vdec_nr) > 0) &&
+					(core->buff_flag | core->stream_buff_flag)) {
 					usleep_range(1000, 2000);
 					up(&core->sem);
 				}
@@ -4598,6 +4704,7 @@ static int vdec_probe(struct platform_device *pdev)
 	spin_lock_init(&vdec_core->lock);
 	spin_lock_init(&vdec_core->canvas_lock);
 	spin_lock_init(&vdec_core->fps_lock);
+	spin_lock_init(&vdec_core->input_lock);
 	ida_init(&vdec_core->ida);
 	vdec_core->thread = kthread_run(vdec_core_thread, vdec_core,
 					"vdec-core");
diff --git a/drivers/frame_provider/decoder/utils/vdec.h b/drivers/frame_provider/decoder/utils/vdec.h
index cf44967..0ca9560 100644
--- a/drivers/frame_provider/decoder/utils/vdec.h
+++ b/drivers/frame_provider/decoder/utils/vdec.h
@@ -448,4 +448,6 @@ extern struct vframe_qos_s *vdec_get_qos_info(void);
 
 int vdec_get_frame_num(struct vdec_s *vdec);
 
+extern void vdec_update_streambuff_status(void);
+
 #endif				/* VDEC_H */
diff --git a/drivers/frame_provider/decoder/utils/vdec_input.c b/drivers/frame_provider/decoder/utils/vdec_input.c
index 98760e1..a5dfeba 100644
--- a/drivers/frame_provider/decoder/utils/vdec_input.c
+++ b/drivers/frame_provider/decoder/utils/vdec_input.c
@@ -948,6 +948,7 @@ int vdec_input_add_frame(struct vdec_input_s *input, const char *buf,
 	struct drm_info drm;
 	struct vdec_s *vdec = input->vdec;
 	unsigned long phy_buf;
+	unsigned long flags;
 
 	if (vdec_secure(vdec)) {
 		while (count > 0) {
@@ -971,6 +972,11 @@ int vdec_input_add_frame(struct vdec_input_s *input, const char *buf,
 	} else {
 		ret = vdec_input_add_chunk(input, buf, count, 0);
 	}
+	flags = vdec_input_lock(input);
+	if ((input->have_frame_num == 1) &&
+		input->vdec_is_input_frame_empty(vdec))
+		input->vdec_up(vdec);
+	vdec_input_unlock(input, flags);
 	return ret;
 }
 EXPORT_SYMBOL(vdec_input_add_frame);
diff --git a/drivers/frame_provider/decoder/utils/vdec_input.h b/drivers/frame_provider/decoder/utils/vdec_input.h
index d2304f6..7ddfc71 100644
--- a/drivers/frame_provider/decoder/utils/vdec_input.h
+++ b/drivers/frame_provider/decoder/utils/vdec_input.h
@@ -105,6 +105,8 @@ struct vdec_input_s {
 	int have_frame_num;
 	int stream_cookie; /* wrap count for vld_mem and
 			      HEVC_SHIFT_BYTE_COUNT for hevc */
+	bool (*vdec_is_input_frame_empty)(struct vdec_s *);
+	void (*vdec_up)(struct vdec_s *);
 };
 
 struct vdec_input_status_s {
diff --git a/drivers/stream_input/amports/amstream.c b/drivers/stream_input/amports/amstream.c
index 765502c..93eaad5 100644
--- a/drivers/stream_input/amports/amstream.c
+++ b/drivers/stream_input/amports/amstream.c
@@ -1118,6 +1118,7 @@ static ssize_t amstream_vbuf_write(struct file *file, const char *buf,
 #ifdef DATA_DEBUG
 	debug_file_write(buf, r);
 #endif
+	vdec_update_streambuff_status();
 
 	return r;
 }

commit 0996b97f6bef3930beb3106eaa1ef60dbfd19559
Author: shihong.zheng <shihong.zheng@amlogic.com>
Date:   Tue Jun 11 11:35:04 2019 +0800

    vmpeg12: add tvp support for vmpeg12. [1/1]
    
    PD#SWPL-6302
    
    Problem:
    vmpeg12 is not support tvp.
    
    Solution:
    add tvp_flag init for vmpeg12.
    
    Verify:
    u212
    
    Change-Id: I032659e5954b8447030d0ec9e317b257082cd4d4
    Signed-off-by: shihong.zheng <shihong.zheng@amlogic.com>

diff --git a/drivers/frame_provider/decoder/mpeg12/vmpeg12.c b/drivers/frame_provider/decoder/mpeg12/vmpeg12.c
index c2eca07..4b48612 100644
--- a/drivers/frame_provider/decoder/mpeg12/vmpeg12.c
+++ b/drivers/frame_provider/decoder/mpeg12/vmpeg12.c
@@ -145,6 +145,7 @@ static const struct vframe_operations_s vmpeg_vf_provider = {
 };
 static void *mm_blk_handle;
 static struct vframe_provider_s vmpeg_vf_prov;
+static int tvp_flag;
 
 static DECLARE_KFIFO(newframe_q, struct vframe_s *, VF_POOL_SIZE);
 static DECLARE_KFIFO(display_q, struct vframe_s *, VF_POOL_SIZE);
@@ -1928,7 +1929,8 @@ static void vmpeg12_local_init(void)
 			MAX_BMMU_BUFFER_NUM,
 			4 + PAGE_SHIFT,
 			CODEC_MM_FLAGS_CMA_CLEAR |
-			CODEC_MM_FLAGS_FOR_VDECODER);
+			CODEC_MM_FLAGS_FOR_VDECODER |
+			tvp_flag);
 
 
 	frame_width = frame_height = frame_dur = frame_prog = 0;
@@ -2050,6 +2052,7 @@ static int amvdec_mpeg12_probe(struct platform_device *pdev)
 		return -EFAULT;
 	}
 
+	tvp_flag = vdec_secure(pdata) ? CODEC_MM_FLAGS_TVP : 0;
 	if (pdata->sys_info)
 		vmpeg12_amstream_dec_info = *pdata->sys_info;
 
diff --git a/drivers/frame_provider/decoder/mpeg12/vmpeg12_multi.c b/drivers/frame_provider/decoder/mpeg12/vmpeg12_multi.c
index f5f5f3a..aff4f1a 100644
--- a/drivers/frame_provider/decoder/mpeg12/vmpeg12_multi.c
+++ b/drivers/frame_provider/decoder/mpeg12/vmpeg12_multi.c
@@ -289,6 +289,7 @@ struct vdec_mpeg12_hw_s {
 	int n_userdata_id;
 	u32 reference[MAX_UD_RECORDS];
 #endif
+	int tvp_flag;
 };
 static void vmpeg12_local_init(struct vdec_mpeg12_hw_s *hw);
 static int vmpeg12_hw_ctx_restore(struct vdec_mpeg12_hw_s *hw);
@@ -2219,7 +2220,8 @@ static void vmpeg12_local_init(struct vdec_mpeg12_hw_s *hw)
 			MAX_BMMU_BUFFER_NUM,
 			4 + PAGE_SHIFT,
 			CODEC_MM_FLAGS_CMA_CLEAR |
-			CODEC_MM_FLAGS_FOR_VDECODER);
+			CODEC_MM_FLAGS_FOR_VDECODER |
+			hw->tvp_flag);
 	hw->eos = 0;
 	hw->frame_width = hw->frame_height = 0;
 	hw->frame_dur = hw->frame_prog = 0;
@@ -2563,9 +2565,17 @@ static int ammvdec_mpeg12_probe(struct platform_device *pdev)
 	hw->canvas_mode = pdata->canvas_mode;
 	hw->platform_dev = pdev;
 
+	hw->tvp_flag = vdec_secure(pdata) ? CODEC_MM_FLAGS_TVP : 0;
 	if (pdata->sys_info)
 		hw->vmpeg12_amstream_dec_info = *pdata->sys_info;
 
+	debug_print(DECODE_ID(hw), 0,
+		"%s, sysinfo: %dx%d, tvp_flag = 0x%x\n",
+		__func__,
+		hw->vmpeg12_amstream_dec_info.width,
+		hw->vmpeg12_amstream_dec_info.height,
+		hw->tvp_flag);
+
 	if (vmpeg12_init(hw) < 0) {
 		pr_info("ammvdec_mpeg12 init failed.\n");
 		if (hw) {
diff --git a/drivers/stream_input/amports/amstream.c b/drivers/stream_input/amports/amstream.c
index 8b39c7f..e2e4498 100644
--- a/drivers/stream_input/amports/amstream.c
+++ b/drivers/stream_input/amports/amstream.c
@@ -3285,11 +3285,18 @@ static long amstream_do_ioctl_old(struct port_priv_s *priv,
 	}
 	case AMSTREAM_IOC_SET_DRMMODE:
 		if ((u32) arg == 1) {
-			pr_err("set drmmode\n");
+			pr_err("set drmmode, input must be secure buffer\n");
 			this->flag |= PORT_FLAG_DRM;
 			if ((this->type & PORT_TYPE_VIDEO) &&
 				(priv->vdec))
 				priv->vdec->port_flag |= PORT_FLAG_DRM;
+		} else if ((u32)arg == 2) {
+			pr_err("set drmmode, input must be normal buffer\n");
+			if ((this->type & PORT_TYPE_VIDEO) &&
+				(priv->vdec)) {
+				pr_err("vdec port_flag with drmmode\n");
+				priv->vdec->port_flag |= PORT_FLAG_DRM;
+			}
 		} else {
 			this->flag &= (~PORT_FLAG_DRM);
 			pr_err("no drmmode\n");
diff --git a/drivers/stream_input/parser/esparser.c b/drivers/stream_input/parser/esparser.c
index 3d0eb2b..1e45893 100644
--- a/drivers/stream_input/parser/esparser.c
+++ b/drivers/stream_input/parser/esparser.c
@@ -736,7 +736,6 @@ ssize_t drm_write(struct file *file, struct stream_buf_s *stbuf,
 	s32 r;
 	u32 len;
 	u32 realcount, totalcount;
-	u32 re_count = count;
 	u32 havewritebytes = 0;
 	u32 leftcount = 0;
 
@@ -845,7 +844,7 @@ ssize_t drm_write(struct file *file, struct stream_buf_s *stbuf,
 		mutex_unlock(&esparser_mutex);
 	}
 
-	return re_count;
+	return havewritebytes;
 }
 EXPORT_SYMBOL(drm_write);
 

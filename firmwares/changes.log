commit 9790d4c7e5bc50e2c5a27d69ee86c87bc5c31ee2
Author: shihong.zheng <shihong.zheng@amlogic.com>
Date:   Thu Apr 25 11:00:29 2019 +0800

    vmpeg4: flush output when mpeg4 eos. [1/1]
    
    PD#SWPL-7101
    
    Problem:
    1. last frame is not output.
    2. previous video frame display in current video start.
    
    Solution:
    flush refs1 output and filter the too small input chunk.
    
    Verify:
    x301
    
    Change-Id: I32491b69c066a5d0667766e6ac562e6f77641d46
    Signed-off-by: shihong.zheng <shihong.zheng@amlogic.com>

diff --git a/drivers/frame_provider/decoder/mpeg4/vmpeg4_multi.c b/drivers/frame_provider/decoder/mpeg4/vmpeg4_multi.c
index 84a8d38..fe8b12e 100644
--- a/drivers/frame_provider/decoder/mpeg4/vmpeg4_multi.c
+++ b/drivers/frame_provider/decoder/mpeg4/vmpeg4_multi.c
@@ -60,6 +60,7 @@
 #define I_PICTURE   0
 #define P_PICTURE   1
 #define B_PICTURE   2
+#define GET_PIC_TYPE(type) ("IPB########"[type])
 
 #define ORI_BUFFER_START_ADDR   0x01000000
 #define DEFAULT_MEM_SIZE	(32*SZ_1M)
@@ -177,6 +178,17 @@ int mmpeg4_debug_print(int index, int debug_flag, const char *fmt, ...)
 	return 0;
 }
 
+struct pic_info_t {
+	int index;
+	u32 pic_type;
+	u32 pic_info;
+	u32 pts;
+	u64 pts64;
+	bool pts_valid;
+	u32 duration;
+	u32 repeat_cnt;
+};
+
 struct vdec_mpeg4_hw_s {
 	spinlock_t lock;
 	struct platform_device *platform_dev;
@@ -236,11 +248,7 @@ struct vdec_mpeg4_hw_s {
 	u32 pts_missed;
 	u32 pts_i_hit;
 	u32 pts_i_missed;
-	u32 decoded_type[DECODE_BUFFER_NUM_MAX];
-	u32 buffer_info[DECODE_BUFFER_NUM_MAX];
-	u32 pts[DECODE_BUFFER_NUM_MAX];
-	u64 pts64[DECODE_BUFFER_NUM_MAX];
-	bool pts_valid[DECODE_BUFFER_NUM_MAX];
+	struct pic_info_t pic[DECODE_BUFFER_NUM_MAX];
 	u32 canvas_spec[DECODE_BUFFER_NUM_MAX];
 #ifdef NV21
 	struct canvas_config_s canvas_config[DECODE_BUFFER_NUM_MAX][2];
@@ -266,9 +274,9 @@ struct vdec_mpeg4_hw_s {
 	u32 get_num;
 	u32 first_i_frame_ready;
 	u32 drop_frame_count;
-	u32 timeout_flag;
 
 	struct firmware_s *fw;
+	u32 blkmode;
 };
 static void vmpeg4_local_init(struct vdec_mpeg4_hw_s *hw);
 static int vmpeg4_hw_ctx_restore(struct vdec_mpeg4_hw_s *hw);
@@ -429,19 +437,195 @@ static inline void vmpeg4_save_hw_context(struct vdec_mpeg4_hw_s *hw)
 	hw->reg_rv_ai_mb_count = READ_VREG(RV_AI_MB_COUNT);
 }
 
+static int update_ref(struct vdec_mpeg4_hw_s *hw, int index)
+{
+	hw->vfbuf_use[index]++;
+
+	if (hw->refs[1] == -1) {
+		hw->refs[1] = index;
+		index = -1;
+	} else if (hw->refs[0] == -1) {
+		hw->refs[0] = hw->refs[1];
+		hw->refs[1] = index;
+		index = hw->refs[0];
+	} else {
+		hw->vfbuf_use[hw->refs[0]]--;
+		hw->refs[0] = hw->refs[1];
+		hw->refs[1] = index;
+		index = hw->refs[0];
+	}
+
+	return index;
+}
+
+
+static int prepare_display_buf(struct vdec_mpeg4_hw_s * hw,
+	struct pic_info_t *pic)
+{
+	struct vframe_s *vf = NULL;
+	struct vdec_s *vdec = hw_to_vdec(hw);
+	int index = pic->index;
+
+	if (pic->pic_info & INTERLACE_FLAG) {
+		if (kfifo_get(&hw->newframe_q, &vf) == 0) {
+			mmpeg4_debug_print(DECODE_ID(hw), 0,
+				"fatal error, no available buffer slot.");
+			return -1;
+		}
+
+		vf->index = pic->index;
+		vf->width = hw->vmpeg4_amstream_dec_info.width;
+		vf->height = hw->vmpeg4_amstream_dec_info.height;
+		vf->bufWidth = 1920;
+		vf->flag = 0;
+		vf->orientation = hw->vmpeg4_rotation;
+		vf->pts = pic->pts;
+		vf->pts_us64 = pic->pts64;
+		vf->duration = pic->duration >> 1;
+		vf->duration_pulldown = 0;
+		vf->type = (pic->pic_info & TOP_FIELD_FIRST_FLAG) ?
+			VIDTYPE_INTERLACE_TOP : VIDTYPE_INTERLACE_BOTTOM;
+#ifdef NV21
+		vf->type |= VIDTYPE_VIU_NV21;
+#endif
+		set_frame_info(hw, vf, pic->index);
+
+		hw->vfbuf_use[pic->index]++;
+		mmpeg4_debug_print(DECODE_ID(hw), PRINT_FLAG_TIMEINFO,
+			"pts0=%d,pts64=%lld,w%d,h%d,dur:%d\n", vf->pts,
+			vf->pts_us64, vf->width, vf->height, vf->duration);
+
+		if ((hw->first_i_frame_ready == 0)
+			 && (pic->pic_type != I_PICTURE)) {
+			hw->drop_frame_count++;
+			hw->vfbuf_use[index]--;
+			kfifo_put(&hw->newframe_q,
+				(const struct vframe_s *)vf);
+			return 0;
+		} else {
+			kfifo_put(&hw->display_q,
+				(const struct vframe_s *)vf);
+			ATRACE_COUNTER(MODULE_NAME, vf->pts);
+			vdec->vdec_fps_detec(vdec->id);
+			hw->frame_num++;
+			vf_notify_receiver(vdec->vf_provider_name,
+				VFRAME_EVENT_PROVIDER_VFRAME_READY, NULL);
+		}
+
+		if (kfifo_get(&hw->newframe_q, &vf) == 0) {
+			mmpeg4_debug_print(DECODE_ID(hw), 0,
+				"error, no available buf.\n");
+			hw->dec_result = DEC_RESULT_ERROR;
+			return -1;
+		}
+
+		vf->index = pic->index;
+		vf->width = hw->vmpeg4_amstream_dec_info.width;
+		vf->height = hw->vmpeg4_amstream_dec_info.height;
+		vf->bufWidth = 1920;
+		vf->flag = 0;
+		vf->orientation = hw->vmpeg4_rotation;
+		vf->pts = 0;
+		vf->pts_us64 = 0;
+		vf->duration = pic->duration >> 1;
+		vf->duration_pulldown = 0;
+		vf->type = (pic->pic_info & TOP_FIELD_FIRST_FLAG) ?
+			VIDTYPE_INTERLACE_BOTTOM : VIDTYPE_INTERLACE_TOP;
+#ifdef NV21
+		vf->type |= VIDTYPE_VIU_NV21;
+#endif
+		set_frame_info(hw, vf, pic->index);
+
+		hw->vfbuf_use[pic->index]++;
+		mmpeg4_debug_print(DECODE_ID(hw), PRINT_FLAG_TIMEINFO,
+			"pts1=%d,pts64=%lld,w%d,h%d,dur:%d\n", vf->pts,
+			vf->pts_us64, vf->width, vf->height, vf->duration);
+		if ((hw->first_i_frame_ready == 0) &&
+			(pic->pic_type != I_PICTURE)) {
+			hw->drop_frame_count++;
+			hw->vfbuf_use[index]--;
+			kfifo_put(&hw->newframe_q,
+				(const struct vframe_s *)vf);
+		} else {
+			kfifo_put(&hw->display_q,
+				(const struct vframe_s *)vf);
+			ATRACE_COUNTER(MODULE_NAME, vf->pts);
+			vdec->vdec_fps_detec(vdec->id);
+			decoder_do_frame_check(vdec, vf);
+			hw->frame_num++;
+			vf_notify_receiver(vdec->vf_provider_name,
+				VFRAME_EVENT_PROVIDER_VFRAME_READY, NULL);
+		}
+	} else {
+		/* progressive */
+		if (kfifo_get(&hw->newframe_q, &vf) == 0) {
+			mmpeg4_debug_print(DECODE_ID(hw), 0,
+				"error, no available buf\n");
+			hw->dec_result = DEC_RESULT_ERROR;
+			return -1;
+		}
+
+		vf->index = index;
+		vf->width = hw->vmpeg4_amstream_dec_info.width;
+		vf->height = hw->vmpeg4_amstream_dec_info.height;
+		vf->bufWidth = 1920;
+		vf->flag = 0;
+		vf->orientation = hw->vmpeg4_rotation;
+		vf->pts = pic->pts;
+		vf->pts_us64 = pic->pts64;
+		vf->duration = pic->duration;
+		vf->duration_pulldown = pic->repeat_cnt *
+			pic->duration;
+#ifdef NV21
+		vf->type = VIDTYPE_PROGRESSIVE |
+			VIDTYPE_VIU_FIELD | VIDTYPE_VIU_NV21;
+#else
+		vf->type = VIDTYPE_PROGRESSIVE |
+			VIDTYPE_VIU_FIELD;
+#endif
+		set_frame_info(hw, vf, index);
+
+		hw->vfbuf_use[index]++;
+		mmpeg4_debug_print(DECODE_ID(hw), PRINT_FLAG_TIMEINFO,
+			"pts=%d, pts64=%lld, w%d,h%d, dur:%d\n", vf->pts,
+			vf->pts_us64, vf->width, vf->height, vf->duration);
+
+		if ((hw->first_i_frame_ready == 0) &&
+			(pic->pic_type != I_PICTURE)) {
+			hw->drop_frame_count++;
+			hw->vfbuf_use[index]--;
+			kfifo_put(&hw->newframe_q,
+				(const struct vframe_s *)vf);
+		} else {
+			kfifo_put(&hw->display_q,
+				(const struct vframe_s *)vf);
+			ATRACE_COUNTER(MODULE_NAME, vf->pts);
+			vdec->vdec_fps_detec(vdec->id);
+			decoder_do_frame_check(vdec, vf);
+			hw->frame_num++;
+			vf_notify_receiver(vdec->vf_provider_name,
+				VFRAME_EVENT_PROVIDER_VFRAME_READY, NULL);
+		}
+
+	}
+	return 0;
+}
+
+
+
 static irqreturn_t vmpeg4_isr_thread_fn(struct vdec_s *vdec, int irq)
 {
 	u32 reg;
-	struct vframe_s *vf = NULL;
 	u32 picture_type;
 	int index;
 	u32 pts, offset = 0;
-	bool pts_valid = false;
 	u64 pts_us64 = 0;
 	u32 frame_size;
 	u32 time_increment_resolution, fixed_vop_rate, vop_time_inc;
 	u32 repeat_cnt, duration = 3200;
+	struct pic_info_t *dec_pic, *disp_pic;
 	struct vdec_mpeg4_hw_s *hw = (struct vdec_mpeg4_hw_s *)(vdec->private);
+
 	if (hw->eos)
 		return IRQ_HANDLED;
 
@@ -475,9 +659,9 @@ static irqreturn_t vmpeg4_isr_thread_fn(struct vdec_s *vdec, int irq)
 			time_increment_resolution = hw->sys_mp4_rate;
 	}
 	mmpeg4_debug_print(DECODE_ID(hw), PRINT_FLAG_DEC_DETAIL,
-	"resolution=%d,fvop=%d,rate=%d\n",
-	time_increment_resolution, fixed_vop_rate,
-	hw->vmpeg4_amstream_dec_info.rate);
+		"resolution=%d,fvop=%d,rate=%d\n",
+		time_increment_resolution, fixed_vop_rate,
+		hw->vmpeg4_amstream_dec_info.rate);
 
 	if (reg == 2) {
 		/* timeout when decoding next frame */
@@ -487,19 +671,17 @@ static irqreturn_t vmpeg4_isr_thread_fn(struct vdec_s *vdec, int irq)
 		 * HW context also, such as for the QTable from VCOP register
 		 */
 		mmpeg4_debug_print(DECODE_ID(hw), PRINT_FLAG_VLD_DETAIL,
-		"ammvdec_mpeg4: timeout\n");
-		mmpeg4_debug_print(DECODE_ID(hw), PRINT_FLAG_VLD_DETAIL,
-		"level=%x, vtl=%x,bcnt=%d\n",
-		READ_VREG(VLD_MEM_VIFIFO_LEVEL),
-		READ_VREG(VLD_MEM_VIFIFO_CONTROL),
-		READ_VREG(VIFF_BIT_CNT));
-		if (input_frame_based(vdec)) {
+			"mmpeg4: wait timeout. level=%x, ctrl=%x, bitcnt=%d\n",
+			READ_VREG(VLD_MEM_VIFIFO_LEVEL),
+			READ_VREG(VLD_MEM_VIFIFO_CONTROL),
+			READ_VREG(VIFF_BIT_CNT));
+
+		if (vdec_frame_based(vdec)) {
 			vmpeg4_save_hw_context(hw);
-			hw->timeout_flag++;
 		} else {
-		hw->dec_result = DEC_RESULT_AGAIN;
-
-		schedule_work(&hw->work);
+			reset_process_time(hw);
+			hw->dec_result = DEC_RESULT_AGAIN;
+			schedule_work(&hw->work);
 		}
 		return IRQ_HANDLED;
 	} else {
@@ -509,32 +691,27 @@ static irqreturn_t vmpeg4_isr_thread_fn(struct vdec_s *vdec, int irq)
 		vop_time_inc = READ_VREG(MP4_VOP_TIME_INC);
 
 		index = spec_to_index(hw, READ_VREG(REC_CANVAS_ADDR));
-
 		if (index < 0) {
 			mmpeg4_debug_print(DECODE_ID(hw), 0,
-			"invalid buffer index.");
+				"invalid buffer index.");
 			hw->dec_result = DEC_RESULT_ERROR;
-
 			schedule_work(&hw->work);
-
 			return IRQ_HANDLED;
 		}
-		mmpeg4_debug_print(DECODE_ID(hw), PRINT_FLAG_BUFFER_DETAIL,
-		"index=%d, used=%d cnt=%d, vopinc=%d\n",
-		index, hw->vfbuf_use[index], repeat_cnt, vop_time_inc);
-
 		hw->dec_result = DEC_RESULT_DONE;
+		dec_pic = &hw->pic[index];
+		mmpeg4_debug_print(DECODE_ID(hw), PRINT_FLAG_BUFFER_DETAIL,
+			"new pic: index=%d, used=%d, repeat=%d, time_inc=%d\n",
+			index, hw->vfbuf_use[index], repeat_cnt, vop_time_inc);
 
 		if (hw->vmpeg4_amstream_dec_info.width == 0) {
 			hw->vmpeg4_amstream_dec_info.width =
 				READ_VREG(MP4_PIC_WH) >> 16;
 		}
-
 		if (hw->vmpeg4_amstream_dec_info.height == 0) {
 			hw->vmpeg4_amstream_dec_info.height =
 				READ_VREG(MP4_PIC_WH) & 0xffff;
 		}
-
 		if (hw->vmpeg4_amstream_dec_info.rate == 0) {
 			if (vop_time_inc < hw->last_vop_time_inc) {
 				duration = vop_time_inc +
@@ -550,10 +727,10 @@ static irqreturn_t vmpeg4_isr_thread_fn(struct vdec_s *vdec, int irq)
 				if ((hw->rate_detect >= RATE_DETECT_COUNT) &&
 					(time_increment_resolution != 0)) {
 					hw->vmpeg4_amstream_dec_info.rate =
-					duration * DURATION_UNIT /
-					time_increment_resolution;
+						duration * DURATION_UNIT /
+						time_increment_resolution;
 					duration =
-					hw->vmpeg4_amstream_dec_info.rate;
+						hw->vmpeg4_amstream_dec_info.rate;
 				}
 			} else {
 				hw->rate_detect = 0;
@@ -572,100 +749,72 @@ static irqreturn_t vmpeg4_isr_thread_fn(struct vdec_s *vdec, int irq)
 			(P_PICTURE == picture_type)) {
 			offset = READ_VREG(MP4_OFFSET_REG);
 			if (hw->chunk) {
-				hw->pts_valid[index] = hw->chunk->pts_valid;
-				hw->pts[index] = hw->chunk->pts;
-				hw->pts64[index] = hw->chunk->pts64;
+				dec_pic->pts_valid = hw->chunk->pts_valid;
+				dec_pic->pts = hw->chunk->pts;
+				dec_pic->pts64 = hw->chunk->pts64;
 			} else {
-				if (pts_lookup_offset_us64
-					(PTS_TYPE_VIDEO, offset, &pts,
-					&frame_size, 3000,
-					&pts_us64) == 0) {
-					hw->pts_valid[index] = true;
-					hw->pts[index] = pts;
-					hw->pts64[index] = pts_us64;
+				if (pts_lookup_offset_us64(PTS_TYPE_VIDEO, offset,
+					&pts, &frame_size, 3000, &pts_us64) == 0) {
+					dec_pic->pts_valid = true;
+					dec_pic->pts = pts;
+					dec_pic->pts64 = pts_us64;
 					hw->pts_hit++;
 				} else {
-					hw->pts_valid[index] = false;
+					dec_pic->pts_valid = false;
 					hw->pts_missed++;
 				}
 			}
 			mmpeg4_debug_print(DECODE_ID(hw), PRINT_FLAG_TIMEINFO,
-			"I/P offset 0x%x, pts_valid %d pts=0x%x,index=%d,used=%d\n",
-					offset, hw->pts_valid[index],
-			hw->pts[index], index, hw->vfbuf_use[index]);
-		} else {
-			hw->pts_valid[index] = false;
-			hw->pts[index] = 0;
-			hw->pts64[index] = 0;
+				"%c, offset=0x%x, pts=0x%x(%d), index=%d, used=%d\n",
+				GET_PIC_TYPE(picture_type), offset, dec_pic->pts,
+				dec_pic->pts_valid, index, hw->vfbuf_use[index]);
 		}
 
-		hw->buffer_info[index] = reg;
+		dec_pic->index = index;
+		dec_pic->pic_info = reg;
+		dec_pic->pic_type = picture_type;
+		dec_pic->duration = duration;
 		hw->vfbuf_use[index] = 0;
-		hw->decoded_type[index] = picture_type;
 		mmpeg4_debug_print(DECODE_ID(hw), PRINT_FLAG_RUN_FLOW,
-		"amvdec_mpeg4: decoded buffer %d, frame_type %s,pts=%x\n",
-			index,
-			(picture_type == I_PICTURE) ? "I" :
-		(picture_type == P_PICTURE) ? "P" : "B",
-		hw->pts[index]);
-
-		/* Buffer management
-		 * todo: add sequence-end flush
-		 */
+		"mmpeg4: num: %d, index %d, frame_type %c, pts %x\n",
+			hw->frame_num, index, GET_PIC_TYPE(picture_type), dec_pic->pts);
+
+		/* buffer management */
 		if ((picture_type == I_PICTURE) ||
 			(picture_type == P_PICTURE)) {
-			hw->vfbuf_use[index]++;
-
-			if (hw->refs[1] == -1) {
-				hw->refs[1] = index;
-				index = -1;
-			} else if (hw->refs[0] == -1) {
-				hw->refs[0] = hw->refs[1];
-				hw->refs[1] = index;
-				index = hw->refs[0];
-			} else {
-				hw->vfbuf_use[hw->refs[0]]--;
-				hw->refs[0] = hw->refs[1];
-				hw->refs[1] = index;
-				index = hw->refs[0];
-			}
+			index = update_ref(hw, index);
 		} else {
-			/* if this is a B frame, then drop (depending on if
-			 * there are two reference frames) or display
-			 * immediately
+			/* drop B frame or disp immediately.
+			 * depend on if there are two ref frames
 			 */
 			if (hw->refs[1] == -1)
 				index = -1;
 		}
-
 		vmpeg4_save_hw_context(hw);
-
 		if (index < 0) {
 			schedule_work(&hw->work);
 			return IRQ_HANDLED;
 		}
-
-		reg = hw->buffer_info[index];
-		pts_valid = hw->pts_valid[index];
-		pts = hw->pts[index];
-		pts_us64 = hw->pts64[index];
+		disp_pic = &hw->pic[index];
 
 		if ((hw->first_i_frame_ready == 0) &&
-			(I_PICTURE == hw->decoded_type[index]))
+			(I_PICTURE == disp_pic->pic_type))
 			hw->first_i_frame_ready = 1;
 		mmpeg4_debug_print(DECODE_ID(hw), PRINT_FLAG_TIMEINFO,
-		"queued %d, pts = 0x%x, pts_valid=%d,index=%d,used=%d,type=%d,decode_type=%d\n",
-		index, pts, pts_valid, index, hw->vfbuf_use[index],
-		picture_type, hw->decoded_type[index]);
-
-		if (pts_valid) {
-			hw->last_anch_pts = pts;
-			hw->last_anch_pts_us64 = pts_us64;
+			"picdisp: index=%d, pts=%x(%d), used=%d, pic=%c(%c)\n",
+			index, disp_pic->pts, disp_pic->pts_valid,
+			hw->vfbuf_use[index],
+			GET_PIC_TYPE(disp_pic->pic_type),
+			GET_PIC_TYPE(picture_type));
+
+		if (disp_pic->pts_valid) {
+			hw->last_anch_pts = disp_pic->pts;
+			hw->last_anch_pts_us64 = disp_pic->pts64;
 			hw->frame_num_since_last_anch = 0;
 			hw->vop_time_inc_since_last_anch = 0;
-		} else if (input_stream_based(vdec)) {
-			pts = hw->last_anch_pts;
-			pts_us64 = hw->last_anch_pts_us64;
+		} else if (vdec_stream_based(vdec)) {
+			disp_pic->pts = hw->last_anch_pts;
+			disp_pic->pts64 = hw->last_anch_pts_us64;
 
 			if ((time_increment_resolution != 0) &&
 				(fixed_vop_rate == 0) &&
@@ -686,233 +835,70 @@ static irqreturn_t vmpeg4_isr_thread_fn(struct vdec_s *vdec, int irq)
 
 				hw->vop_time_inc_since_last_anch += duration;
 
-				pts += hw->vop_time_inc_since_last_anch *
+				disp_pic->pts += hw->vop_time_inc_since_last_anch *
 					PTS_UNIT / time_increment_resolution;
-				pts_us64 += (hw->vop_time_inc_since_last_anch *
+				disp_pic->pts64 += (hw->vop_time_inc_since_last_anch *
 					PTS_UNIT / time_increment_resolution) *
 					100 / 9;
 
 				if (hw->vop_time_inc_since_last_anch >
 					(1 << 14)) {
 					/* avoid overflow */
-					hw->last_anch_pts = pts;
-					hw->last_anch_pts_us64 = pts_us64;
+					hw->last_anch_pts = disp_pic->pts;
+					hw->last_anch_pts_us64 = disp_pic->pts64;
 					hw->vop_time_inc_since_last_anch = 0;
 				}
 			} else {
 				/* fixed VOP rate */
 				hw->frame_num_since_last_anch++;
-				pts += DUR2PTS(hw->frame_num_since_last_anch *
+				disp_pic->pts += DUR2PTS(hw->frame_num_since_last_anch *
 					hw->vmpeg4_amstream_dec_info.rate);
-				pts_us64 += DUR2PTS(
+				disp_pic->pts64 += DUR2PTS(
 					hw->frame_num_since_last_anch *
-					hw->vmpeg4_amstream_dec_info.rate) *
-					100 / 9;
+					hw->vmpeg4_amstream_dec_info.rate) * 100 / 9;
 
 				if (hw->frame_num_since_last_anch > (1 << 15)) {
 					/* avoid overflow */
-					hw->last_anch_pts = pts;
-					hw->last_anch_pts_us64 = pts_us64;
+					hw->last_anch_pts = disp_pic->pts;
+					hw->last_anch_pts_us64 = disp_pic->pts64;
 					hw->frame_num_since_last_anch = 0;
 				}
 			}
 		}
-
-		if (reg & INTERLACE_FLAG) {	/* interlace */
-			if (kfifo_get(&hw->newframe_q, &vf) == 0) {
-				mmpeg4_debug_print(DECODE_ID(hw), 0,
-				"fatal error, no available buffer slot.");
-				return IRQ_HANDLED;
-			}
-
-			vf->index = index;
-			vf->width = hw->vmpeg4_amstream_dec_info.width;
-			vf->height = hw->vmpeg4_amstream_dec_info.height;
-			vf->bufWidth = 1920;
-			vf->flag = 0;
-			vf->orientation = hw->vmpeg4_rotation;
-			vf->pts = pts;
-			vf->pts_us64 = pts_us64;
-			vf->duration = duration >> 1;
-			vf->duration_pulldown = 0;
-			vf->type = (reg & TOP_FIELD_FIRST_FLAG) ?
-				VIDTYPE_INTERLACE_TOP :
-				VIDTYPE_INTERLACE_BOTTOM;
-#ifdef NV21
-			vf->type |= VIDTYPE_VIU_NV21;
-#endif
-			set_frame_info(hw, vf, index);
-
-			hw->vfbuf_use[index]++;
-			mmpeg4_debug_print(DECODE_ID(hw), PRINT_FLAG_TIMEINFO,
-			"pts0=%d,pts64=%lld,w%d,h%d,dur:%d\n",
-				vf->pts, vf->pts_us64,
-				vf->width, vf->height,
-				vf->duration);
-			if ((hw->first_i_frame_ready == 0)
-				 && (picture_type != I_PICTURE)) {
-				hw->drop_frame_count++;
-				hw->vfbuf_use[index]--;
-
-				kfifo_put(&hw->newframe_q,
-				(const struct vframe_s *)vf);
-			} else {
-				kfifo_put(&hw->display_q,
-				(const struct vframe_s *)vf);
-				ATRACE_COUNTER(MODULE_NAME, vf->pts);
-				hw->frame_num++;
-			vdec->vdec_fps_detec(vdec->id);
-			vf_notify_receiver(vdec->vf_provider_name,
-					VFRAME_EVENT_PROVIDER_VFRAME_READY,
-					NULL);
-			}
-			if (kfifo_get(&hw->newframe_q, &vf) == 0) {
-				mmpeg4_debug_print(DECODE_ID(hw), 0,
-				"fatal error, no available buffer slot.");
-				hw->dec_result = DEC_RESULT_ERROR;
-				schedule_work(&hw->work);
-				return IRQ_HANDLED;
-			}
-
-			vf->index = index;
-			vf->width = hw->vmpeg4_amstream_dec_info.width;
-			vf->height = hw->vmpeg4_amstream_dec_info.height;
-			vf->bufWidth = 1920;
-			vf->flag = 0;
-			vf->orientation = hw->vmpeg4_rotation;
-
-			vf->pts = 0;
-			vf->pts_us64 = 0;
-			vf->duration = duration >> 1;
-
-			vf->duration_pulldown = 0;
-			vf->type = (reg & TOP_FIELD_FIRST_FLAG) ?
-			VIDTYPE_INTERLACE_BOTTOM : VIDTYPE_INTERLACE_TOP;
-#ifdef NV21
-			vf->type |= VIDTYPE_VIU_NV21;
-#endif
-			set_frame_info(hw, vf, index);
-
-			hw->vfbuf_use[index]++;
-			mmpeg4_debug_print(DECODE_ID(hw), PRINT_FLAG_TIMEINFO,
-			"pts1=%d,pts64=%lld,w%d,h%d,dur:%d\n",
-				vf->pts, vf->pts_us64,
-				vf->width, vf->height,
-				vf->duration);
-			if ((hw->first_i_frame_ready == 0)
-				 && (picture_type != I_PICTURE)) {
-				hw->drop_frame_count++;
-				hw->vfbuf_use[index]--;
-
-				kfifo_put(&hw->newframe_q,
-				(const struct vframe_s *)vf);
-			} else {
-				kfifo_put(&hw->display_q,
-				(const struct vframe_s *)vf);
-				ATRACE_COUNTER(MODULE_NAME, vf->pts);
-				hw->frame_num++;
-			vdec->vdec_fps_detec(vdec->id);
-			vf_notify_receiver(vdec->vf_provider_name,
-				VFRAME_EVENT_PROVIDER_VFRAME_READY,
-				NULL);
-			}
-		} else {	/* progressive */
-			if (kfifo_get(&hw->newframe_q, &vf) == 0) {
-				mmpeg4_debug_print(DECODE_ID(hw), 0,
-				"fatal error, no available buffer slot.");
-				return IRQ_HANDLED;
-			}
-
-			vf->index = index;
-			vf->width = hw->vmpeg4_amstream_dec_info.width;
-			vf->height = hw->vmpeg4_amstream_dec_info.height;
-			vf->bufWidth = 1920;
-			vf->flag = 0;
-			vf->orientation = hw->vmpeg4_rotation;
-			vf->pts = pts;
-			vf->pts_us64 = pts_us64;
-			vf->duration = duration;
-			vf->duration_pulldown = repeat_cnt * duration;
-#ifdef NV21
-			vf->type =
-				VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD |
-				VIDTYPE_VIU_NV21;
-#else
-			vf->type =
-				VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD;
-#endif
-			set_frame_info(hw, vf, index);
-
-			hw->vfbuf_use[index]++;
-			mmpeg4_debug_print(DECODE_ID(hw), PRINT_FLAG_TIMEINFO,
-			"pts=%d,pts64=%lld,w%d,h%d,index=%d,used=%d,dur:%d, flag=%d, type=%d\n",
-				vf->pts, vf->pts_us64,
-				vf->width, vf->height,
-				index, hw->vfbuf_use[index],
-				vf->duration,
-				hw->timeout_flag, picture_type);
-			if ((hw->first_i_frame_ready == 0)
-				 && (picture_type != I_PICTURE)) {
-				hw->drop_frame_count++;
-				hw->vfbuf_use[index]--;
-				hw->timeout_flag++;
-				kfifo_put(&hw->newframe_q,
-					(const struct vframe_s *)vf);
-			} else {
-				if (hw->timeout_flag > 2)
-					hw->timeout_flag = 2;
-				if (hw->timeout_flag && input_frame_based(vdec))
-					vf->duration = duration * (hw->timeout_flag + 1);
-				kfifo_put(&hw->display_q,
-					(const struct vframe_s *)vf);
-				ATRACE_COUNTER(MODULE_NAME, vf->pts);
-				hw->frame_num++;
-				hw->timeout_flag = 0;
-				vdec->vdec_fps_detec(vdec->id);
-				vf_notify_receiver(vdec->vf_provider_name,
-					VFRAME_EVENT_PROVIDER_VFRAME_READY, NULL);
-			}
-		}
+		disp_pic->duration = duration;
+		disp_pic->repeat_cnt = repeat_cnt;
+		prepare_display_buf(hw, disp_pic);
 
 		hw->total_frame += repeat_cnt + 1;
 		hw->last_vop_time_inc = vop_time_inc;
-
 		schedule_work(&hw->work);
 	}
 	mmpeg4_debug_print(DECODE_ID(hw), PRINT_FRAME_NUM,
-		"%s:frame num:%d\n", __func__, hw->frame_num);
+		"%s: frame num:%d\n", __func__, hw->frame_num);
 
 	return IRQ_HANDLED;
 }
 
 static irqreturn_t vmpeg4_isr(struct vdec_s *vdec, int irq)
 {
-	u32 time_increment_resolution, fixed_vop_rate;
 	struct vdec_mpeg4_hw_s *hw = (struct vdec_mpeg4_hw_s *)(vdec->private);
 
 	if (hw->eos)
 		return IRQ_HANDLED;
-	WRITE_VREG(ASSIST_MBOX1_CLR_REG, 1);
-	time_increment_resolution = READ_VREG(MP4_RATE);
-	fixed_vop_rate = time_increment_resolution >> 16;
-	time_increment_resolution &= 0xffff;
-	if (time_increment_resolution > 0 && fixed_vop_rate == 0)
-		hw->sys_mp4_rate = time_increment_resolution;
-	if (hw->vmpeg4_amstream_dec_info.rate == 0) {
-		if ((fixed_vop_rate != 0) && (time_increment_resolution != 0)) {
-			hw->vmpeg4_amstream_dec_info.rate = fixed_vop_rate *
-					DURATION_UNIT /
-					time_increment_resolution;
-		} else if (time_increment_resolution == 0
-		&& hw->sys_mp4_rate > 0)
-			time_increment_resolution = hw->sys_mp4_rate;
-	}
-	mmpeg4_debug_print(DECODE_ID(hw), PRINT_FLAG_DEC_DETAIL,
-	"resolution=%d,fvop=%d,rate=%d\n",
-	time_increment_resolution, fixed_vop_rate,
-	hw->vmpeg4_amstream_dec_info.rate);
+
 	return IRQ_WAKE_THREAD;
 }
+
+static void flush_output(struct vdec_mpeg4_hw_s * hw)
+{
+	struct pic_info_t *pic;
+
+	if (hw->vfbuf_use[hw->refs[1]] > 0) {
+		pic = &hw->pic[hw->refs[1]];
+		prepare_display_buf(hw, pic);
+	}
+}
+
 static void vmpeg4_work(struct work_struct *work)
 {
 	struct vdec_mpeg4_hw_s *hw =
@@ -923,26 +909,25 @@ static void vmpeg4_work(struct work_struct *work)
 	 * notify vdec core to switch context
 	 */
 	if (hw->dec_result != DEC_RESULT_DONE)
-			mmpeg4_debug_print(DECODE_ID(hw), PRINT_FLAG_RUN_FLOW,
-		"mmpeg4: vmpeg_work,result=%d,status=%d\n",
-		hw->dec_result, hw_to_vdec(hw)->next_status);
+		mmpeg4_debug_print(DECODE_ID(hw), PRINT_FLAG_RUN_FLOW,
+			"mmpeg4: vmpeg_work,result=%d,status=%d\n",
+			hw->dec_result, hw_to_vdec(hw)->next_status);
 
 	if ((hw->dec_result == DEC_RESULT_DONE) ||
-		((hw->chunk) &&
-		(input_frame_based(&(hw_to_vdec(hw))->input)))) {
+		((input_frame_based(&vdec->input)) && hw->chunk)) {
 		if (!hw->ctx_valid)
 			hw->ctx_valid = 1;
 
-		vdec_vframe_dirty(hw_to_vdec(hw), hw->chunk);
+		vdec_vframe_dirty(vdec, hw->chunk);
 		hw->chunk = NULL;
 	} else if (hw->dec_result == DEC_RESULT_AGAIN
-	&& (hw_to_vdec(hw)->next_status !=
+	&& (vdec->next_status !=
 		VDEC_STATUS_DISCONNECTED)) {
 		/*
 			stream base: stream buf empty or timeout
 			frame base: vdec_prepare_input fail
 		*/
-		if (!vdec_has_more_input(hw_to_vdec(hw))) {
+		if (!vdec_has_more_input(vdec)) {
 			hw->dec_result = DEC_RESULT_EOS;
 			vdec_schedule_work(&hw->work);
 			/*pr_info("%s: return\n",
@@ -960,17 +945,20 @@ static void vmpeg4_work(struct work_struct *work)
 			hw->stat &= ~STAT_ISR_REG;
 		}
 	} else if (hw->dec_result == DEC_RESULT_EOS) {
-		/*pr_info("%s: end of stream\n",
-			__func__);*/
 		hw->eos = 1;
 		if (hw->stat & STAT_VDEC_RUN) {
 			amvdec_stop();
 			hw->stat &= ~STAT_VDEC_RUN;
 		}
-		vdec_vframe_dirty(hw_to_vdec(hw), hw->chunk);
+		vdec_vframe_dirty(vdec, hw->chunk);
 		hw->chunk = NULL;
-		vdec_clean_input(hw_to_vdec(hw));
+		vdec_clean_input(vdec);
+		flush_output(hw);
+		mmpeg4_debug_print(DECODE_ID(hw), PRINT_FRAME_NUM,
+			"%s: eos flushed, frame_num %d\n",
+			__func__, hw->frame_num);
 	}
+
 	if (hw->stat & STAT_VDEC_RUN) {
 		amvdec_stop();
 		hw->stat &= ~STAT_VDEC_RUN;
@@ -980,12 +968,12 @@ static void vmpeg4_work(struct work_struct *work)
 
 	/* mark itself has all HW resource released and input released */
 	if (vdec->parallel_dec == 1)
-		vdec_core_finish_run(hw_to_vdec(hw), CORE_MASK_VDEC_1);
+		vdec_core_finish_run(vdec, CORE_MASK_VDEC_1);
 	else
-		vdec_core_finish_run(hw_to_vdec(hw), CORE_MASK_VDEC_1 | CORE_MASK_HEVC);
+		vdec_core_finish_run(vdec, CORE_MASK_VDEC_1 | CORE_MASK_HEVC);
 
 	if (hw->vdec_cb)
-		hw->vdec_cb(hw_to_vdec(hw), hw->vdec_cb_arg);
+		hw->vdec_cb(vdec, hw->vdec_cb_arg);
 }
 
 static struct vframe_s *vmpeg_vf_peek(void *op_arg)
@@ -1023,11 +1011,9 @@ static void vmpeg_vf_put(struct vframe_s *vf, void *op_arg)
 	hw->vfbuf_use[vf->index]--;
 	hw->put_num++;
 	mmpeg4_debug_print(DECODE_ID(hw), PRINT_FRAME_NUM,
-	"%s:put num:%d\n",
-	__func__, hw->put_num);
+		"%s: put num:%d\n",__func__, hw->put_num);
 	mmpeg4_debug_print(DECODE_ID(hw), PRINT_FLAG_BUFFER_DETAIL,
-	"index=%d, used=%d\n",
-	vf->index, hw->vfbuf_use[vf->index]);
+		"index=%d, used=%d\n", vf->index, hw->vfbuf_use[vf->index]);
 	kfifo_put(&hw->newframe_q, (const struct vframe_s *)vf);
 }
 
@@ -1115,9 +1101,9 @@ static int vmpeg4_canvas_init(struct vdec_mpeg4_hw_s *hw)
 				canvas_width = align_w;
 				canvas_height = align_h;
 				decbuf_y_size =
-				ALIGN(align_w * align_h, SZ_64K);
+					ALIGN(align_w * align_h, SZ_64K);
 				decbuf_size =
-				ALIGN(align_w * align_h * 3/2, SZ_64K);
+					ALIGN(align_w * align_h * 3/2, SZ_64K);
 			} else { /*1080p*/
 				if (h > w) {
 					canvas_width = 1088;
@@ -1149,6 +1135,12 @@ static int vmpeg4_canvas_init(struct vdec_mpeg4_hw_s *hw)
 		} else {
 			if (vdec->parallel_dec == 1) {
 				unsigned tmp;
+				if (canvas_y(hw->canvas_spec[i]) == 0xff) {
+					tmp =
+						vdec->get_canvas_ex(CORE_MASK_VDEC_1, vdec->id);
+					hw->canvas_spec[i] &= ~0xff;
+					hw->canvas_spec[i] |= tmp;
+				}
 				if (canvas_u(hw->canvas_spec[i]) == 0xff) {
 					tmp =
 						vdec->get_canvas_ex(CORE_MASK_VDEC_1, vdec->id);
@@ -1156,40 +1148,33 @@ static int vmpeg4_canvas_init(struct vdec_mpeg4_hw_s *hw)
 					hw->canvas_spec[i] |= tmp << 8;
 					hw->canvas_spec[i] |= tmp << 16;
 				}
-				if (canvas_y(hw->canvas_spec[i]) == 0xff) {
-					tmp =
-						vdec->get_canvas_ex(CORE_MASK_VDEC_1, vdec->id);
-					hw->canvas_spec[i] &= ~0xff;
-					hw->canvas_spec[i] |= tmp;
-				}
 				canvas = hw->canvas_spec[i];
 			} else {
 				canvas = vdec->get_canvas(i, 2);
 				hw->canvas_spec[i] = canvas;
 			}
 
-			hw->canvas_config[i][0].phy_addr =
-			decbuf_start;
-			hw->canvas_config[i][0].width =
-			canvas_width;
-			hw->canvas_config[i][0].height =
-			canvas_height;
-			hw->canvas_config[i][0].block_mode =
-			CANVAS_BLKMODE_32X32;
-
-		canvas_config_config(canvas_y(canvas),
+			hw->canvas_config[i][0].phy_addr = decbuf_start;
+			hw->canvas_config[i][0].width = canvas_width;
+			hw->canvas_config[i][0].height = canvas_height;
+			hw->canvas_config[i][0].block_mode = hw->blkmode;
+			if (hw->blkmode == CANVAS_BLKMODE_LINEAR)
+				hw->canvas_config[i][0].endian = 7;
+			else
+				hw->canvas_config[i][0].endian = 0;
+			canvas_config_config(canvas_y(canvas),
 					&hw->canvas_config[i][0]);
 
 			hw->canvas_config[i][1].phy_addr =
-			decbuf_start + decbuf_y_size;
-			hw->canvas_config[i][1].width =
-			canvas_width;
-			hw->canvas_config[i][1].height =
-			canvas_height / 2;
-			hw->canvas_config[i][1].block_mode =
-			CANVAS_BLKMODE_32X32;
-
-		canvas_config_config(canvas_u(canvas),
+				decbuf_start + decbuf_y_size;
+			hw->canvas_config[i][1].width = canvas_width;
+			hw->canvas_config[i][1].height = (canvas_height >> 1);
+			hw->canvas_config[i][1].block_mode = hw->blkmode;
+			if (hw->blkmode == CANVAS_BLKMODE_LINEAR)
+				hw->canvas_config[i][1].endian = 7;
+			else
+				hw->canvas_config[i][1].endian = 0;
+			canvas_config_config(canvas_u(canvas),
 					&hw->canvas_config[i][1]);
 		}
 	}
@@ -1217,7 +1202,7 @@ static void vmpeg4_dump_state(struct vdec_s *vdec)
 
 	mmpeg4_debug_print(DECODE_ID(hw), 0,
 		"is_framebase(%d), eos %d, state 0x%x, dec_result 0x%x dec_frm %d\n",
-		input_frame_based(vdec),
+		vdec_frame_based(vdec),
 		hw->eos,
 		hw->stat,
 		hw->dec_result,
@@ -1225,7 +1210,7 @@ static void vmpeg4_dump_state(struct vdec_s *vdec)
 		);
 	mmpeg4_debug_print(DECODE_ID(hw), 0,
 		"is_framebase(%d),  put_frm %d run %d not_run_ready %d input_empty %d,drop %d\n",
-		input_frame_based(vdec),
+		vdec_frame_based(vdec),
 		hw->put_num,
 		hw->run_count,
 		hw->not_run_ready,
@@ -1244,15 +1229,11 @@ static void vmpeg4_dump_state(struct vdec_s *vdec)
 			state);
 	}
 	mmpeg4_debug_print(DECODE_ID(hw), 0,
-	"%s, newq(%d/%d), dispq(%d/%d) vf peek/get/put (%d/%d/%d)\n",
-	__func__,
-	kfifo_len(&hw->newframe_q),
-	VF_POOL_SIZE,
-	kfifo_len(&hw->display_q),
-	VF_POOL_SIZE,
-	hw->peek_num,
-	hw->get_num,
-	hw->put_num
+		"%s, newq(%d/%d), dispq(%d/%d) vf peek/get/put (%d/%d/%d)\n",
+		__func__,
+		kfifo_len(&hw->newframe_q), VF_POOL_SIZE,
+		kfifo_len(&hw->display_q), VF_POOL_SIZE,
+		hw->peek_num, hw->get_num, hw->put_num
 	);
 	mmpeg4_debug_print(DECODE_ID(hw), 0,
 		"VIFF_BIT_CNT=0x%x\n",
@@ -1272,9 +1253,8 @@ static void vmpeg4_dump_state(struct vdec_s *vdec)
 	mmpeg4_debug_print(DECODE_ID(hw), 0,
 		"PARSER_VIDEO_WP=0x%x\n",
 		READ_PARSER_REG(PARSER_VIDEO_WP));
-	if (input_frame_based(vdec) &&
-		debug_enable & PRINT_FRAMEBASE_DATA
-		) {
+	if (vdec_frame_based(vdec) &&
+		debug_enable & PRINT_FRAMEBASE_DATA) {
 		int jj;
 		if (hw->chunk && hw->chunk->block &&
 			hw->chunk->size > 0) {
@@ -1358,7 +1338,7 @@ static void check_timer_func(unsigned long arg)
 	}
 
 	if (debug_enable == 0 &&
-		(input_frame_based(vdec) ||
+		(vdec_frame_based(vdec) ||
 		(READ_VREG(VLD_MEM_VIFIFO_LEVEL) > 0x100)) &&
 		(timeout_val > 0) &&
 		(hw->start_process_time > 0) &&
@@ -1388,12 +1368,10 @@ static int vmpeg4_hw_ctx_restore(struct vdec_mpeg4_hw_s *hw)
 {
 	int index;
 
-
 	index = find_buffer(hw);
 	if (index < 0)
 		return -1;
 
-
 	if (vmpeg4_canvas_init(hw) < 0)
 		return -1;
 
@@ -1411,11 +1389,12 @@ static int vmpeg4_hw_ctx_restore(struct vdec_mpeg4_hw_s *hw)
 	}
 	WRITE_VREG(MREG_REF1, (hw->refs[1] == -1) ? 0xffffffff :
 				hw->canvas_spec[hw->refs[1]]);
-
+	/*
 	WRITE_VREG(MREG_REF0, (hw->refs[0] == -1) ? 0xffffffff :
 				hw->canvas_spec[hw->refs[0]]);
 	WRITE_VREG(MREG_REF1, (hw->refs[1] == -1) ? 0xffffffff :
 				hw->canvas_spec[hw->refs[1]]);
+	*/
 	WRITE_VREG(REC_CANVAS_ADDR, hw->canvas_spec[index]);
 	WRITE_VREG(ANC2_CANVAS_ADDR, hw->canvas_spec[index]);
 
@@ -1469,7 +1448,7 @@ static int vmpeg4_hw_ctx_restore(struct vdec_mpeg4_hw_s *hw)
 	WRITE_VREG(SLICE_QP, hw->reg_slice_qp);
 	WRITE_VREG(MB_INFO, hw->reg_mb_info);
 
-	if (hw->chunk) {
+	if (vdec_frame_based(hw_to_vdec(hw)) && hw->chunk) {
 		/* frame based input */
 		WRITE_VREG(MREG_INPUT, (hw->chunk->offset & 7) | (1<<7) |
 							(hw->ctx_valid<<6));
@@ -1490,8 +1469,7 @@ static void vmpeg4_local_init(struct vdec_mpeg4_hw_s *hw)
 	hw->vmpeg4_ratio64 = hw->vmpeg4_amstream_dec_info.ratio64;
 
 	hw->vmpeg4_rotation =
-		(((unsigned long) hw->vmpeg4_amstream_dec_info.param)
-			>> 16) & 0xffff;
+		(((unsigned long)hw->vmpeg4_amstream_dec_info.param) >> 16) & 0xffff;
 	hw->sys_mp4_rate = hw->vmpeg4_amstream_dec_info.rate;
 	hw->frame_width = hw->frame_height = hw->frame_dur = hw->frame_prog = 0;
 
@@ -1520,7 +1498,6 @@ static void vmpeg4_local_init(struct vdec_mpeg4_hw_s *hw)
 	hw->first_i_frame_ready = 0;
 	hw->drop_frame_count = 0;
 	hw->buffer_not_ready = 0;
-	hw->timeout_flag = 0;
 
 	for (i = 0; i < DECODE_BUFFER_NUM_MAX; i++)
 		hw->vfbuf_use[i] = 0;
@@ -1603,6 +1580,7 @@ static unsigned long run_ready(struct vdec_s *vdec, unsigned long mask)
 {
 	int index;
 	struct vdec_mpeg4_hw_s *hw = (struct vdec_mpeg4_hw_s *)vdec->private;
+
 	if (hw->eos)
 		return 0;
 	if (vdec_stream_based(vdec) && (hw->init_flag == 0)
@@ -1673,14 +1651,15 @@ static void run(struct vdec_s *vdec, unsigned long mask,
 	hw->vdec_cb = callback;
 	vdec_reset_core(vdec);
 	size = vdec_prepare_input(vdec, &hw->chunk);
-	if (size < 0) {
+	if (size < 4) { /*less than start code size 00 00 01 xx*/
 		hw->input_empty++;
 		hw->dec_result = DEC_RESULT_AGAIN;
 		schedule_work(&hw->work);
 		return;
 	}
 
-	if (input_frame_based(vdec)) {
+	if (vdec_frame_based(vdec) &&
+		(debug_enable & 0xc00)) {
 		u8 *data = NULL;
 
 		if (!hw->chunk->block->is_mapped)
@@ -1690,18 +1669,15 @@ static void run(struct vdec_s *vdec, unsigned long mask,
 			data = ((u8 *)hw->chunk->block->start_virt) +
 				hw->chunk->offset;
 
-		if (debug_enable & PRINT_FLAG_VDEC_STATUS
-			) {
-			mmpeg4_debug_print(DECODE_ID(hw), 0,
+		mmpeg4_debug_print(DECODE_ID(hw), PRINT_FLAG_VDEC_STATUS,
 			"%s: size 0x%x sum 0x%x %02x %02x %02x %02x %02x %02x .. %02x %02x %02x %02x\n",
 			__func__, size, get_data_check_sum(hw, size),
 			data[0], data[1], data[2], data[3],
 			data[4], data[5], data[size - 4],
 			data[size - 3],	data[size - 2],
 			data[size - 1]);
-		}
-		if (debug_enable & PRINT_FRAMEBASE_DATA
-			) {
+
+		if (debug_enable & PRINT_FRAMEBASE_DATA) {
 			int jj;
 
 			for (jj = 0; jj < size; jj++) {
@@ -1733,13 +1709,13 @@ static void run(struct vdec_s *vdec, unsigned long mask,
 			size);
 
 	mmpeg4_debug_print(DECODE_ID(hw), PRINT_FLAG_RUN_FLOW,
-	"%s,%d, size=%d, %x %x %x %x %x\n",
-	__func__, __LINE__, size,
-	READ_VREG(VLD_MEM_VIFIFO_LEVEL),
-	READ_VREG(VLD_MEM_VIFIFO_WP),
-	READ_VREG(VLD_MEM_VIFIFO_RP),
-	READ_PARSER_REG(PARSER_VIDEO_RP),
-	READ_PARSER_REG(PARSER_VIDEO_WP));
+		"%s,%d, size=%d, %x %x %x %x %x\n",
+		__func__, __LINE__, size,
+		READ_VREG(VLD_MEM_VIFIFO_LEVEL),
+		READ_VREG(VLD_MEM_VIFIFO_WP),
+		READ_VREG(VLD_MEM_VIFIFO_RP),
+		READ_PARSER_REG(PARSER_VIDEO_RP),
+		READ_PARSER_REG(PARSER_VIDEO_WP));
 
 	hw->dec_result = DEC_RESULT_NONE;
 	if (vdec->mc_loaded) {
@@ -1807,7 +1783,7 @@ static void reset(struct vdec_s *vdec)
 
 	vmpeg4_local_init(hw);
 
-	hw->ctx_valid = false;
+	hw->ctx_valid = 0;
 }
 
 static int ammvdec_mpeg4_probe(struct platform_device *pdev)
@@ -1857,6 +1833,7 @@ static int ammvdec_mpeg4_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, pdata);
 	hw->platform_dev = pdev;
+	hw->blkmode = pdata->canvas_mode;
 
 /*
 	hw->cma_dev = pdata->cma_dev;
@@ -1948,7 +1925,7 @@ static int ammvdec_mpeg4_remove(struct platform_device *pdev)
 	vdec_set_status(hw_to_vdec(hw), VDEC_STATUS_DISCONNECTED);
 
 	if (vdec->parallel_dec == 1) {
-		for (i = 0; i < DECODE_BUFFER_NUM_MAX; i++) {
+		for (i = 0; i < DECODE_BUFFER_NUM_MAX - 1; i++) {
 			vdec->free_canvas_ex(canvas_y(hw->canvas_spec[i]), vdec->id);
 			vdec->free_canvas_ex(canvas_u(hw->canvas_spec[i]), vdec->id);
 		}

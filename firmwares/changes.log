commit e9d06fa5b68a075375926cf4a84ab9e094cd043b
Author: Nanxin Qin <nanxin.qin@amlogic.com>
Date:   Thu Feb 21 16:20:39 2019 +0800

    decoder: optimized flushing cache for lowmem & highmem. [2/2]
    
    PD#SWPL-3593
    
    Problem:
    the memory data might be discordant.
    
    Solution:
    modified the way of flush mem which from lowmem or highmem.
    
    Verify:
    x301
    
    Change-Id: Id5c21322a6cd4bf11639bc4981b6c2995a42f2dd
    Signed-off-by: Nanxin Qin <nanxin.qin@amlogic.com>

diff --git a/drivers/frame_provider/decoder/h264_multi/vmh264.c b/drivers/frame_provider/decoder/h264_multi/vmh264.c
index 0f7dfee..fb8d62a 100644
--- a/drivers/frame_provider/decoder/h264_multi/vmh264.c
+++ b/drivers/frame_provider/decoder/h264_multi/vmh264.c
@@ -7892,17 +7892,15 @@ static int ammvdec_h264_probe(struct platform_device *pdev)
 		tmpbuf = (char *)codec_mm_phys_to_virt(hw->cma_alloc_addr);
 		if (tmpbuf) {
 			memset(tmpbuf, 0, V_BUF_ADDR_OFFSET);
-			dma_sync_single_for_device(amports_get_dma_device(),
-				hw->cma_alloc_addr,
-				V_BUF_ADDR_OFFSET, DMA_TO_DEVICE);
+			codec_mm_dma_flush(tmpbuf,
+				V_BUF_ADDR_OFFSET,
+				DMA_TO_DEVICE);
 		} else {
 			tmpbuf = codec_mm_vmap(hw->cma_alloc_addr,
 				V_BUF_ADDR_OFFSET);
 			if (tmpbuf) {
 				memset(tmpbuf, 0, V_BUF_ADDR_OFFSET);
-				dma_sync_single_for_device(
-					amports_get_dma_device(),
-					hw->cma_alloc_addr,
+				codec_mm_dma_flush(tmpbuf,
 					V_BUF_ADDR_OFFSET,
 					DMA_TO_DEVICE);
 				codec_mm_unmap_phyaddr(tmpbuf);
diff --git a/drivers/frame_provider/decoder/utils/vdec_input.c b/drivers/frame_provider/decoder/utils/vdec_input.c
index 9b4f01e..3b04ca9 100644
--- a/drivers/frame_provider/decoder/utils/vdec_input.c
+++ b/drivers/frame_provider/decoder/utils/vdec_input.c
@@ -75,8 +75,7 @@ static int copy_from_user_to_phyaddr(void *virts, const char __user *buf,
 			memset(p, 0, pading);
 		}
 
-		dma_sync_single_for_device(get_vdec_device(),
-			addr, size + pading, DMA_TO_DEVICE);
+		codec_mm_dma_flush(p, size + pading, DMA_TO_DEVICE);
 
 		return 0;
 	}
@@ -92,10 +91,8 @@ static int copy_from_user_to_phyaddr(void *virts, const char __user *buf,
 			return -EFAULT;
 		}
 
+		codec_mm_dma_flush(p, span, DMA_TO_DEVICE);
 		codec_mm_unmap_phyaddr(p);
-
-		dma_sync_single_for_device(get_vdec_device(),
-			addr, span, DMA_TO_DEVICE);
 	}
 
 	if (!remain)
@@ -115,11 +112,9 @@ static int copy_from_user_to_phyaddr(void *virts, const char __user *buf,
 	if (pading)
 		memset(p + remain, 0, pading);
 
+	codec_mm_dma_flush(p, remain + pading, DMA_TO_DEVICE);
 	codec_mm_unmap_phyaddr(p);
 
-	dma_sync_single_for_device(get_vdec_device(),
-		addr, remain + pading, DMA_TO_DEVICE);
-
 	return 0;
 }
 
@@ -160,27 +155,30 @@ static int vframe_chunk_fill(struct vdec_input_s *input,
 		if (!block->is_mapped) {
 			p = codec_mm_vmap(block->start + wp, len);
 			memset(p, 0, len);
+			codec_mm_dma_flush(p, len, DMA_TO_DEVICE);
 			codec_mm_unmap_phyaddr(p);
-		} else
+		} else {
 			memset(p, 0, len);
-
-		dma_sync_single_for_device(get_vdec_device(),
-			block->start + wp,
-			len, DMA_TO_DEVICE);
+			codec_mm_dma_flush(p, len, DMA_TO_DEVICE);
+		}
 
 		if (chunk->pading_size > len) {
 			p = (u8 *)block->start_virt;
 
 			if (!block->is_mapped) {
-				p = codec_mm_vmap(block->start, count - len);
-				memset(p, 0, count - len);
+				p = codec_mm_vmap(block->start,
+					chunk->pading_size - len);
+				memset(p, 0, chunk->pading_size - len);
+				codec_mm_dma_flush(p,
+					chunk->pading_size - len,
+					DMA_TO_DEVICE);
 				codec_mm_unmap_phyaddr(p);
-			} else
-				memset(p, 0, count - len);
-
-			dma_sync_single_for_device(get_vdec_device(),
-					block->start,
-				chunk->pading_size - len, DMA_TO_DEVICE);
+			} else {
+				memset(p, 0, chunk->pading_size - len);
+				codec_mm_dma_flush(p,
+					chunk->pading_size - len,
+					DMA_TO_DEVICE);
+			}
 		}
 	}
 

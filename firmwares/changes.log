commit 144f5ee8996bf727dbfdb0ee9b9950dda8a3c95d
Author: Hui Zhang <hui.zhang@amlogic.com>
Date:   Thu May 16 10:15:06 2019 +0800

    media_module: fix hevc back mmu dmc warnning [1/2]
    
    PD#TV-5832
    
    Problem:
    when mmu scatter tail is freed. sometimes sao mmu is not
    stopped or in idle. there is potential memory pollution
    
    Solution:
    before free unused scatter, to check hw statu idle and
    diable sao mmu to avoid hevc back overwrite system memory
    
    Verify:
    X301
    
    Change-Id: Idc040751d56757118d1591f8f20cd18be294588a
    Signed-off-by: Hui Zhang <hui.zhang@amlogic.com>

diff --git a/drivers/frame_provider/decoder/avs/avs.c b/drivers/frame_provider/decoder/avs/avs.c
index b434fae..cf0c436 100644
--- a/drivers/frame_provider/decoder/avs/avs.c
+++ b/drivers/frame_provider/decoder/avs/avs.c
@@ -1548,9 +1548,6 @@ static s32 vavs_init(void)
 	stat |= STAT_TIMER_INIT;
 
 	amvdec_enable();
-
-	vdec_enable_DMC(NULL);
-
 	vavs_local_init();
 
 	if (get_cpu_major_id() >= AM_MESON_CPU_MAJOR_ID_GXM)
@@ -1803,8 +1800,6 @@ static int amvdec_avs_remove(struct platform_device *pdev)
 
 
 	amvdec_disable();
-	vdec_disable_DMC(NULL);
-
 	pic_type = 0;
 	if (mm_blk_handle) {
 		decoder_bmmu_box_free(mm_blk_handle);
diff --git a/drivers/frame_provider/decoder/avs2/vavs2.c b/drivers/frame_provider/decoder/avs2/vavs2.c
index 37b9224..dd7247b 100644
--- a/drivers/frame_provider/decoder/avs2/vavs2.c
+++ b/drivers/frame_provider/decoder/avs2/vavs2.c
@@ -74,7 +74,6 @@
 #define HEVCD_MPP_ANC2AXI_TBL_DATA                 0x3464
 #define HEVC_SAO_MMU_VH1_ADDR                      0x363b
 #define HEVC_SAO_MMU_VH0_ADDR                      0x363a
-#define HEVC_SAO_MMU_STATUS                        0x3639
 
 
 /*
@@ -4605,12 +4604,14 @@ static void debug_buffer_mgr_more(struct AVS2Decoder_s *dec)
 static void avs2_recycle_mmu_buf_tail(struct AVS2Decoder_s *dec)
 {
 	if (dec->cur_fb_idx_mmu != INVALID_IDX) {
-		if (dec->used_4k_num == -1)
+		if (dec->used_4k_num == -1) {
 			dec->used_4k_num =
 			(READ_VREG(HEVC_SAO_MMU_STATUS) >> 16);
-		decoder_mmu_box_free_idx_tail(dec->mmu_box,
+			if (dec->m_ins_flag)
+				hevc_mmu_dma_check(hw_to_vdec(dec));
+			decoder_mmu_box_free_idx_tail(dec->mmu_box,
 			dec->cur_fb_idx_mmu, dec->used_4k_num);
-
+		}
 		dec->cur_fb_idx_mmu = INVALID_IDX;
 		dec->used_4k_num = -1;
 	}
@@ -6290,9 +6291,7 @@ static s32 vavs2_init(struct vdec_s *vdec)
 
 		return 0;
 	}
-	hevc_enable_DMC(hw_to_vdec(dec));
 	amhevc_enable();
-
 	ret = amhevc_loadmc_ex(VFORMAT_AVS2, NULL, fw->data);
 	if (ret < 0) {
 		amhevc_disable();
diff --git a/drivers/frame_provider/decoder/h264_multi/vmh264.c b/drivers/frame_provider/decoder/h264_multi/vmh264.c
index e249586..ebace1a 100644
--- a/drivers/frame_provider/decoder/h264_multi/vmh264.c
+++ b/drivers/frame_provider/decoder/h264_multi/vmh264.c
@@ -861,7 +861,6 @@ static void h264_clear_dpb(struct vdec_h264_hw_s *hw);
 #define		H265_CHECK_AXI_INFO_BASE	HEVC_ASSIST_SCRATCH_8
 #define		H265_SAO_4K_SET_BASE	HEVC_ASSIST_SCRATCH_9
 #define		H265_SAO_4K_SET_COUNT	HEVC_ASSIST_SCRATCH_A
-#define		HEVC_SAO_MMU_STATUS			0x3639
 #define		HEVCD_MPP_ANC2AXI_TBL_DATA		0x3464
 
 
@@ -874,7 +873,6 @@ static void h264_clear_dpb(struct vdec_h264_hw_s *hw);
 #define		HEVCD_MPP_DECOMP_CTL3			0x34c4
 #define		HEVCD_MPP_VDEC_MCR_CTL			0x34c8
 #define           HEVC_DBLK_CFGB                             0x350b
-#define           HEVC_CM_CORE_STATUS                      0x3640
 #define		HEVC_ASSIST_MMU_MAP_ADDR	0x3009
 
 #define H265_DW_NO_SCALE
@@ -7792,7 +7790,7 @@ result_done:
 					PRINT_FLAG_MMU_DETAIL,
 					"release unused buf , used_4k_num %ld index %d\n",
 					used_4k_num, hw->hevc_cur_buf_idx);
-
+				hevc_mmu_dma_check(hw_to_vdec(hw));
 				decoder_mmu_box_free_idx_tail(
 					hw->mmu_box,
 					hw->hevc_cur_buf_idx,
diff --git a/drivers/frame_provider/decoder/h265/vh265.c b/drivers/frame_provider/decoder/h265/vh265.c
index 2cf7257..c34ab90 100644
--- a/drivers/frame_provider/decoder/h265/vh265.c
+++ b/drivers/frame_provider/decoder/h265/vh265.c
@@ -80,7 +80,6 @@
 #define HEVC_CM_HEADER_START_ADDR                  0x3628
 #define HEVC_SAO_MMU_VH1_ADDR                      0x363b
 #define HEVC_SAO_MMU_VH0_ADDR                      0x363a
-#define HEVC_SAO_MMU_STATUS                        0x3639
 
 #define HEVC_DBLK_CFGB                             0x350b
 #define HEVCD_MPP_DECOMP_AXIURG_CTL                0x34c7
@@ -5679,6 +5678,7 @@ static inline void hevc_pre_pic(struct hevc_state_s *hevc,
 						hevc->cur_pic->index,
 						hevc->cur_pic->scatter_alloc,
 						hevc->used_4k_num);
+						hevc_mmu_dma_check(hw_to_vdec(hevc));
 						decoder_mmu_box_free_idx_tail(
 						hevc->mmu_box,
 						hevc->cur_pic->index,
@@ -10632,7 +10632,6 @@ static s32 vh265_init(struct hevc_state_s *hevc)
 		return 0;
 	}
 #endif
-	hevc_enable_DMC(hw_to_vdec(hevc));
 	amhevc_enable();
 
 	if (hevc->mmu_enable)
@@ -11283,6 +11282,8 @@ static void vh265_work(struct work_struct *work)
 				hevc->cur_pic->index,
 				hevc->cur_pic->scatter_alloc,
 				hevc->used_4k_num);
+				if (hevc->m_ins_flag)
+					hevc_mmu_dma_check(hw_to_vdec(hevc));
 				decoder_mmu_box_free_idx_tail(
 				hevc->mmu_box,
 				hevc->cur_pic->index,
diff --git a/drivers/frame_provider/decoder/utils/vdec.c b/drivers/frame_provider/decoder/utils/vdec.c
index 67736bf..25c5b6f 100644
--- a/drivers/frame_provider/decoder/utils/vdec.c
+++ b/drivers/frame_provider/decoder/utils/vdec.c
@@ -502,6 +502,55 @@ static void free_canvas_ex(int index, int id)
 
 }
 
+static void vdec_disable_DMC(struct vdec_s *vdec)
+{
+	/*close first,then wait pedding end,timing suggestion from vlsi*/
+	struct vdec_input_s *input = &vdec->input;
+	unsigned long flags;
+	unsigned int mask = 0;
+
+	if (input->target == VDEC_INPUT_TARGET_VLD) {
+		mask = (1 << 13);
+		if (get_cpu_major_id() >= AM_MESON_CPU_MAJOR_ID_G12A)
+			mask = (1 << 21);
+	} else if (input->target == VDEC_INPUT_TARGET_HEVC) {
+		mask = (1 << 4); /*hevc*/
+		if (get_cpu_major_id() >= AM_MESON_CPU_MAJOR_ID_G12A)
+			mask |= (1 << 8); /*hevcb */
+	}
+	spin_lock_irqsave(&vdec_spin_lock, flags);
+	codec_dmcbus_write(DMC_REQ_CTRL,
+	codec_dmcbus_read(DMC_REQ_CTRL) & ~mask);
+	spin_unlock_irqrestore(&vdec_spin_lock, flags);
+
+	while (!(codec_dmcbus_read(DMC_CHAN_STS)
+			& mask))
+			;
+
+	pr_debug("%s input->target= 0x%x\n", __func__,  input->target);
+}
+
+static void vdec_enable_DMC(struct vdec_s *vdec)
+{
+	struct vdec_input_s *input = &vdec->input;
+	unsigned long flags;
+	unsigned int mask = 0;
+
+	if (input->target == VDEC_INPUT_TARGET_VLD) {
+		mask = (1 << 13);
+		if (get_cpu_major_id() >= AM_MESON_CPU_MAJOR_ID_G12A)
+			mask = (1 << 21);
+	} else if (input->target == VDEC_INPUT_TARGET_HEVC) {
+		mask = (1 << 4); /*hevc*/
+		if (get_cpu_major_id() >= AM_MESON_CPU_MAJOR_ID_G12A)
+			mask |= (1 << 8); /*hevcb */
+	}
+	spin_lock_irqsave(&vdec_spin_lock, flags);
+	codec_dmcbus_write(DMC_REQ_CTRL,
+	codec_dmcbus_read(DMC_REQ_CTRL) | mask);
+	spin_unlock_irqrestore(&vdec_spin_lock, flags);
+	pr_debug("%s input->target= 0x%x\n", __func__,  input->target);
+}
 
 
 
@@ -1531,13 +1580,19 @@ EXPORT_SYMBOL(vdec_need_more_data);
 void hevc_wait_ddr(void)
 {
 	unsigned long flags;
+	unsigned int mask = 0;
+
+	mask = 1 << 4; /* hevc */
+	if (get_cpu_major_id() >= AM_MESON_CPU_MAJOR_ID_G12A)
+		mask |= (1 << 8); /* hevcb */
+
 	spin_lock_irqsave(&vdec_spin_lock, flags);
 	codec_dmcbus_write(DMC_REQ_CTRL,
-		codec_dmcbus_read(DMC_REQ_CTRL) & (~(1 << 4)));
+		codec_dmcbus_read(DMC_REQ_CTRL) & ~mask);
 	spin_unlock_irqrestore(&vdec_spin_lock, flags);
 
 	while (!(codec_dmcbus_read(DMC_CHAN_STS)
-		& (1 << 4)))
+		& mask))
 		;
 }
 
@@ -1935,7 +1990,8 @@ s32 vdec_init(struct vdec_s *vdec, int is_4k)
 			vdec->format == VFORMAT_VP9) ?
 				VDEC_INPUT_TARGET_HEVC :
 				VDEC_INPUT_TARGET_VLD);
-
+	if (vdec_single(vdec))
+		vdec_enable_DMC(vdec);
 	p->cma_dev = vdec_core->cma_dev;
 	p->get_canvas = get_canvas;
 	p->get_canvas_ex = get_canvas_ex;
@@ -2218,7 +2274,8 @@ void vdec_release(struct vdec_s *vdec)
 	vdec_frame_check_exit(vdec);
 #endif
 	vdec_fps_clear(vdec->id);
-
+	if (atomic_read(&vdec_core->vdec_nr) == 1)
+		vdec_disable_DMC(vdec);
 	platform_device_unregister(vdec->dev);
 	pr_debug("vdec_release instance %p, total %d\n", vdec,
 		atomic_read(&vdec_core->vdec_nr));
@@ -3088,10 +3145,15 @@ void vdec_poweron(enum vdec_type_e core)
 			 *enable VDEC_1 DMC request
 			 */
 			unsigned long flags;
+			unsigned int mask = 0;
+
+			mask = 1 << 13;
+			if (get_cpu_major_id() >= AM_MESON_CPU_MAJOR_ID_G12A)
+				mask = 1 << 21;
 
 			spin_lock_irqsave(&vdec_spin_lock, flags);
 			codec_dmcbus_write(DMC_REQ_CTRL,
-				codec_dmcbus_read(DMC_REQ_CTRL) | (1 << 13));
+				codec_dmcbus_read(DMC_REQ_CTRL) | mask);
 			spin_unlock_irqrestore(&vdec_spin_lock, flags);
 		}
 	} else if (core == VDEC_2) {
@@ -3293,10 +3355,15 @@ void vdec_poweroff(enum vdec_type_e core)
 			AM_MESON_CPU_MAJOR_ID_GXBB) {
 			/* disable VDEC_1 DMC REQ*/
 			unsigned long flags;
+			unsigned int mask = 0;
+
+			mask = 1 << 13;
+			if (get_cpu_major_id() >= AM_MESON_CPU_MAJOR_ID_G12A)
+				mask = 1 << 21;
 
 			spin_lock_irqsave(&vdec_spin_lock, flags);
 			codec_dmcbus_write(DMC_REQ_CTRL,
-				codec_dmcbus_read(DMC_REQ_CTRL) & (~(1 << 13)));
+				codec_dmcbus_read(DMC_REQ_CTRL) & ~mask);
 			spin_unlock_irqrestore(&vdec_spin_lock, flags);
 			udelay(10);
 		}
@@ -3586,43 +3653,22 @@ int vdec_source_changed(int format, int width, int height, int fps)
 
 }
 EXPORT_SYMBOL(vdec_source_changed);
-
-void vdec_disable_DMC(struct vdec_s *vdec)
+void vdec_reset_core(struct vdec_s *vdec)
 {
-	/*close first,then wait pedding end,timing suggestion from vlsi*/
 	unsigned long flags;
-	spin_lock_irqsave(&vdec_spin_lock, flags);
-	codec_dmcbus_write(DMC_REQ_CTRL,
-		codec_dmcbus_read(DMC_REQ_CTRL) & (~(1 << 13)));
-	spin_unlock_irqrestore(&vdec_spin_lock, flags);
+	unsigned int mask = 0;
 
-	while (!(codec_dmcbus_read(DMC_CHAN_STS)
-		& (1 << 13)))
-		;
-}
-EXPORT_SYMBOL(vdec_disable_DMC);
+	mask = 1 << 13; /*bit13: DOS VDEC interface*/
+	if (get_cpu_major_id() >= AM_MESON_CPU_MAJOR_ID_G12A)
+		mask = 1 << 21; /*bit21: DOS VDEC interface*/
 
-void vdec_enable_DMC(struct vdec_s *vdec)
-{
-	unsigned long flags;
 	spin_lock_irqsave(&vdec_spin_lock, flags);
 	codec_dmcbus_write(DMC_REQ_CTRL,
-	codec_dmcbus_read(DMC_REQ_CTRL) | (1 << 13));
-	spin_unlock_irqrestore(&vdec_spin_lock, flags);
-}
-
-EXPORT_SYMBOL(vdec_enable_DMC);
-
-void vdec_reset_core(struct vdec_s *vdec)
-{
-	unsigned long flags;
-	spin_lock_irqsave(&vdec_spin_lock, flags);
-	codec_dmcbus_write(DMC_REQ_CTRL,
-		codec_dmcbus_read(DMC_REQ_CTRL) & (~(1 << 13)));
+		codec_dmcbus_read(DMC_REQ_CTRL) & ~mask);
 	spin_unlock_irqrestore(&vdec_spin_lock, flags);
 
 	while (!(codec_dmcbus_read(DMC_CHAN_STS)
-		& (1 << 13)))
+		& mask))
 		;
 	/*
 	 * 2: assist
@@ -3647,33 +3693,62 @@ void vdec_reset_core(struct vdec_s *vdec)
 
 	spin_lock_irqsave(&vdec_spin_lock, flags);
 	codec_dmcbus_write(DMC_REQ_CTRL,
-		codec_dmcbus_read(DMC_REQ_CTRL) | (1 << 13));
+		codec_dmcbus_read(DMC_REQ_CTRL) | mask);
 	spin_unlock_irqrestore(&vdec_spin_lock, flags);
 }
 EXPORT_SYMBOL(vdec_reset_core);
 
-void hevc_enable_DMC(struct vdec_s *vdec)
+void hevc_mmu_dma_check(struct vdec_s *vdec)
 {
-	unsigned long flags;
-	spin_lock_irqsave(&vdec_spin_lock, flags);
-	codec_dmcbus_write(DMC_REQ_CTRL,
-	codec_dmcbus_read(DMC_REQ_CTRL) | (1 << 4));
-	spin_unlock_irqrestore(&vdec_spin_lock, flags);
+	ulong timeout;
+	u32 data;
+	if (get_cpu_major_id() < AM_MESON_CPU_MAJOR_ID_G12A)
+		return;
+	timeout = jiffies + HZ/100;
+	while (1) {
+		data  = READ_VREG(HEVC_CM_CORE_STATUS);
+		if ((data & 0x1) == 0)
+			break;
+		if (time_after(jiffies, timeout)) {
+			if (debug & 0x10)
+				pr_info(" %s sao mmu dma idle\n", __func__);
+			break;
+		}
+	}
+	/*disable sao mmu dma */
+	CLEAR_VREG_MASK(HEVC_SAO_MMU_DMA_CTRL, 1 << 0);
+	timeout = jiffies + HZ/100;
+	while (1) {
+		data  = READ_VREG(HEVC_SAO_MMU_DMA_STATUS);
+		if ((data & 0x1))
+			break;
+		if (time_after(jiffies, timeout)) {
+			if (debug & 0x10)
+				pr_err("%s sao mmu dma timeout, num_buf_used = 0x%x\n",
+				__func__, (READ_VREG(HEVC_SAO_MMU_STATUS) >> 16));
+			break;
+		}
+	}
 }
-
-EXPORT_SYMBOL(hevc_enable_DMC);
+EXPORT_SYMBOL(hevc_mmu_dma_check);
 
 void hevc_reset_core(struct vdec_s *vdec)
 {
 	unsigned long flags;
+	unsigned int mask = 0;
+
+	mask = 1 << 4; /*bit4: hevc*/
+	if (get_cpu_major_id() >= AM_MESON_CPU_MAJOR_ID_G12A)
+		mask |= 1 << 8; /*bit8: hevcb*/
+
 	WRITE_VREG(HEVC_STREAM_CONTROL, 0);
 	spin_lock_irqsave(&vdec_spin_lock, flags);
 	codec_dmcbus_write(DMC_REQ_CTRL,
-		codec_dmcbus_read(DMC_REQ_CTRL) & (~(1 << 4)));
+		codec_dmcbus_read(DMC_REQ_CTRL) & ~mask);
 	spin_unlock_irqrestore(&vdec_spin_lock, flags);
 
 	while (!(codec_dmcbus_read(DMC_CHAN_STS)
-		& (1 << 4)))
+		& mask))
 		;
 
 	if (vdec == NULL || input_frame_based(vdec))
@@ -3704,7 +3779,7 @@ void hevc_reset_core(struct vdec_s *vdec)
 
 	spin_lock_irqsave(&vdec_spin_lock, flags);
 	codec_dmcbus_write(DMC_REQ_CTRL,
-		codec_dmcbus_read(DMC_REQ_CTRL) | (1 << 4));
+		codec_dmcbus_read(DMC_REQ_CTRL) | mask);
 	spin_unlock_irqrestore(&vdec_spin_lock, flags);
 
 }
diff --git a/drivers/frame_provider/decoder/utils/vdec.h b/drivers/frame_provider/decoder/utils/vdec.h
index cf44967..18d7cd1 100644
--- a/drivers/frame_provider/decoder/utils/vdec.h
+++ b/drivers/frame_provider/decoder/utils/vdec.h
@@ -419,11 +419,7 @@ extern void vdec_core_finish_run(struct vdec_s *vdec, unsigned long mask);
 #ifdef VDEC_DEBUG_SUPPORT
 extern void vdec_set_step_mode(void);
 #endif
-
-extern void vdec_disable_DMC(struct vdec_s *vdec);
-extern void vdec_enable_DMC(struct vdec_s *vdec);
-extern void hevc_enable_DMC(struct vdec_s *vdec);
-
+extern void hevc_mmu_dma_check(struct vdec_s *vdec);
 int vdec_read_user_data(struct vdec_s *vdec,
 				struct userdata_param_t *p_userdata_param);
 
diff --git a/drivers/frame_provider/decoder/vp9/vvp9.c b/drivers/frame_provider/decoder/vp9/vvp9.c
index 264a422..f71a740 100644
--- a/drivers/frame_provider/decoder/vp9/vvp9.c
+++ b/drivers/frame_provider/decoder/vp9/vvp9.c
@@ -82,7 +82,6 @@
 #define HEVCD_MPP_ANC2AXI_TBL_DATA                 0x3464
 #define HEVC_SAO_MMU_VH1_ADDR                      0x363b
 #define HEVC_SAO_MMU_VH0_ADDR                      0x363a
-#define HEVC_SAO_MMU_STATUS                        0x3639
 
 #define HEVC_MV_INFO                               0x310d
 #define HEVC_QP_INFO                               0x3137
@@ -7073,12 +7072,14 @@ static void vp9_recycle_mmu_buf_tail(struct VP9Decoder_s *pbi)
 	if (pbi->double_write_mode & 0x10)
 		return;
 	if (cm->cur_fb_idx_mmu != INVALID_IDX) {
-		if (pbi->used_4k_num == -1)
+		if (pbi->used_4k_num == -1) {
 			pbi->used_4k_num =
 			(READ_VREG(HEVC_SAO_MMU_STATUS) >> 16);
+			if (pbi->m_ins_flag)
+				hevc_mmu_dma_check(hw_to_vdec(pbi));
+		}
 		decoder_mmu_box_free_idx_tail(pbi->mmu_box,
 			cm->cur_fb_idx_mmu, pbi->used_4k_num);
-
 		cm->cur_fb_idx_mmu = INVALID_IDX;
 		pbi->used_4k_num = -1;
 	}
@@ -8646,7 +8647,6 @@ static s32 vvp9_init(struct VP9Decoder_s *pbi)
 		return 0;
 	}
 #endif
-	hevc_enable_DMC(hw_to_vdec(pbi));
 	amhevc_enable();
 
 	init_pic_list(pbi);

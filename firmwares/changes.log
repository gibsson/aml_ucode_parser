commit a991d7d62876df4800af74cd2d9f56f2dadca1b6
Author: Conglin Guo <conglin.guo@amlogic.com>
Date:   Thu May 30 20:11:22 2019 +0800

    media_modules: ref list err  cast frames [3/3]
    
    PD#SWPL-8660
    
    Problem:
    ref list err  cast frames.
    
    Solution:
    1 one GOP group I frame Followed  is B frame,
    ref err Should not be flush_dpb.
    2  ref list err flush_dpb and clear ref map.just keep
      current colocated_buf_index.
    3 if config_decode_buf fail will reset bufmgr.
    
    Verify:
    T962X2-X301
    
    Change-Id: I884138f33396f7c124523cbdc86e9f4ebe3d3af7
    Signed-off-by: Conglin Guo <conglin.guo@amlogic.com>

diff --git a/drivers/frame_provider/decoder/h264_multi/vmh264.c b/drivers/frame_provider/decoder/h264_multi/vmh264.c
index 2ea0d1b..42f57f7 100644
--- a/drivers/frame_provider/decoder/h264_multi/vmh264.c
+++ b/drivers/frame_provider/decoder/h264_multi/vmh264.c
@@ -836,6 +836,8 @@ struct vdec_h264_hw_s {
 	bool first_head_check_flag;
 	unsigned int height_aspect_ratio;
 	unsigned int width_aspect_ratio;
+	bool new_iframe_flag;
+	bool ref_err_flush_dpb_flag;
 };
 
 static u32 again_threshold = 0x40;
@@ -5574,6 +5576,19 @@ static irqreturn_t vh264_isr_thread_fn(struct vdec_s *vdec, int irq)
 					}
 				}
 
+			if (p_H264_Dpb->mVideo.dec_picture->slice_type == I_SLICE) {
+				hw->new_iframe_flag = 1;
+			}
+			if (hw->new_iframe_flag) {
+				if (p_H264_Dpb->mVideo.dec_picture->slice_type == P_SLICE) {
+					hw->new_iframe_flag = 0;
+					hw->ref_err_flush_dpb_flag = 1;
+				}else  if (p_H264_Dpb->mVideo.dec_picture->slice_type == B_SLICE) {
+							hw->new_iframe_flag = 0;
+							hw->ref_err_flush_dpb_flag = 0;
+						}
+			}
+
 			if (error_proc_policy & 0x400) {
 				int ret = dpb_check_ref_list_error(p_H264_Dpb);
 				if (ret != 0) {
@@ -5582,7 +5597,16 @@ static irqreturn_t vh264_isr_thread_fn(struct vdec_s *vdec, int irq)
 						ret,
 						hw->decode_pic_count+1,
 						hw->skip_frame_count);
-					flush_dpb(p_H264_Dpb);
+
+					if (hw->ref_err_flush_dpb_flag) {
+						flush_dpb(p_H264_Dpb);
+						p_H264_Dpb->colocated_buf_map = 0;
+						if (p_H264_Dpb->mVideo.dec_picture->colocated_buf_index >= 0) {
+							p_H264_Dpb->colocated_buf_map |= 1 <<
+								p_H264_Dpb->mVideo.dec_picture->colocated_buf_index;
+						}
+					}
+
 					hw->data_flag |= ERROR_FLAG;
 					p_H264_Dpb->mVideo.dec_picture->data_flag |= ERROR_FLAG;
 					if ((error_proc_policy & 0x80)
@@ -5623,6 +5647,7 @@ static irqreturn_t vh264_isr_thread_fn(struct vdec_s *vdec, int irq)
 				if (error_proc_policy & 0x2) {
 					release_cur_decoding_buf(hw);
 					/*hw->data_flag |= ERROR_FLAG;*/
+					hw->reset_bufmgr_flag = 1;
 					hw->dec_result = DEC_RESULT_DONE;
 					vdec_schedule_work(&hw->work);
 					return IRQ_HANDLED;
@@ -8542,6 +8567,8 @@ static int ammvdec_h264_probe(struct platform_device *pdev)
 
 	hw->mmu_enable = 0;
 	hw->first_head_check_flag = 0;
+	hw->new_iframe_flag = 0;
+	hw->ref_err_flush_dpb_flag = 0;
 	if (force_enable_mmu && pdata->sys_info &&
 		    (get_cpu_major_id() >= AM_MESON_CPU_MAJOR_ID_TXLX) &&
 		    (get_cpu_major_id() != AM_MESON_CPU_MAJOR_ID_GXLX) &&

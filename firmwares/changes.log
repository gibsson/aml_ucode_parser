commit 7020d2fab46d95bdc3e1617119de8fc3e5225b52
Author: Conglin Guo <conglin.guo@amlogic.com>
Date:   Wed May 1 17:14:10 2019 +0800

    media_modules: Filter error frames [3/3]
    
    PD#SWPL-7189
    
    Problem:
    1 error frames  default display, cause Mosaic.
    2 mark error according to last pic.1: ignore mark error.
    3 interlaced stream,decoder later lost field is_used != 3,Can't
      field combine  frame,Can't remove FrameStore from dpb,cause
      FrameStore leak.
    
    Solution:
    1 default set send_error_frame_flag to 0 , Filter error frames.
    2 last_pic is  reference and marked error,  current decoder pic
      slice_type != I_SLICE, current pic will marked error.
    3 Modify output_frames calculate dpb queue none_displayed_num
      and get_smallest_poc conditions, make lost field FrameStore
      remove from dpb.prepare_display_buf will deal This error frames.
    
    Verify:
    S905X2
    
    Change-Id: I9c23015af806a43a33a6f3fe14c96648599e5948
    Signed-off-by: Conglin Guo <conglin.guo@amlogic.com>

diff --git a/drivers/frame_provider/decoder/h264_multi/h264_dpb.c b/drivers/frame_provider/decoder/h264_multi/h264_dpb.c
index 8008310..cf0df90 100644
--- a/drivers/frame_provider/decoder/h264_multi/h264_dpb.c
+++ b/drivers/frame_provider/decoder/h264_multi/h264_dpb.c
@@ -2196,8 +2196,7 @@ static void get_smallest_poc(struct DecodedPictureBuffer *p_Dpb, int *poc,
 		/* rain */
 		if ((*poc > p_Dpb->fs[i]->poc) &&
 			(!p_Dpb->fs[i]->is_output) &&
-			(!p_Dpb->fs[i]->pre_output) &&
-			(p_Dpb->fs[i]->is_used == 3)) {
+			(!p_Dpb->fs[i]->pre_output)) {
 #else
 		if ((*poc > p_Dpb->fs[i]->poc) && (!p_Dpb->fs[i]->is_output)) {
 #endif
@@ -2217,7 +2216,8 @@ int output_frames(struct h264_dpb_stru *p_H264_Dpb, unsigned char flush_flag)
 	if (!flush_flag) {
 		for (i = 0; i < p_Dpb->used_size; i++) {
 			if ((!p_Dpb->fs[i]->is_output) &&
-				(!p_Dpb->fs[i]->pre_output) && (p_Dpb->fs[i]->is_used == 3)) {
+				(!p_Dpb->fs[i]->pre_output) &&((p_Dpb->fs[i]->is_used == 3
+				||p_Dpb->fs[i]->data_flag & ERROR_FLAG )))  {
 				none_displayed_num++;
 				if ((p_H264_Dpb->first_insert_frame == FirstInsertFrm_IDLE)
 					&&  (p_Dpb->fs[i]->is_used == 3)
diff --git a/drivers/frame_provider/decoder/h264_multi/vmh264.c b/drivers/frame_provider/decoder/h264_multi/vmh264.c
index 1f4ae56..504fa92 100644
--- a/drivers/frame_provider/decoder/h264_multi/vmh264.c
+++ b/drivers/frame_provider/decoder/h264_multi/vmh264.c
@@ -257,8 +257,8 @@ static unsigned int i_only_flag;
 	bit[9] check ERROR_STATUS_REG
 	bit[10] check reference list
 	bit[11] mark error if dpb error
-
 	bit[12] i_only when error happen
+	bit[13] 0: mark error according to last pic, 1: ignore mark error
 */
 static unsigned int error_proc_policy = 0xf36; /*0x1f14*/
 
@@ -3034,6 +3034,7 @@ int config_decode_buf(struct vdec_h264_hw_s *hw, struct StorablePicture *pic)
 	struct Slice *pSlice = &(p_H264_Dpb->mSlice);
 	unsigned int colocate_adr_offset;
 	unsigned int val;
+	struct StorablePicture *last_pic = hw->last_dec_picture;
 
 #ifdef ONE_COLOCATE_BUF_PER_DECODE_BUF
 	int colocate_buf_index;
@@ -3163,6 +3164,20 @@ int config_decode_buf(struct vdec_h264_hw_s *hw, struct StorablePicture *pic)
 	j = 0;
 	h264_buffer_info_data_write_count = 0;
 
+	if (last_pic)
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_ERRORFLAG_DBG,
+				"last_pic->data_flag %x   slice_type %x last_pic->slice_type %x\n",
+				last_pic->data_flag, pSlice->slice_type, last_pic->slice_type);
+	if (!hw->i_only && !(error_proc_policy & 0x2000) &&
+		last_pic && (last_pic->data_flag & ERROR_FLAG)
+		&& (!(last_pic->slice_type == B_SLICE))
+		&& (!(pSlice->slice_type == I_SLICE))) {
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_ERRORFLAG_DBG,
+				  "no i/idr error mark\n");
+		hw->data_flag |= ERROR_FLAG;
+		pic->data_flag |= ERROR_FLAG;
+	}
+
 	for (i = 0; i < (unsigned int)(pSlice->listXsize[0]); i++) {
 		/*ref list 0 */
 		struct StorablePicture *ref = pSlice->listX[0][i];
@@ -6613,7 +6628,7 @@ static void vh264_local_init(struct vdec_h264_hw_s *hw)
 	if (error_proc_policy & 0x80000000)
 		hw->send_error_frame_flag = error_proc_policy & 0x1;
 	else if ((unsigned long) hw->vh264_amstream_dec_info.param & 0x20)
-		hw->send_error_frame_flag = 1;
+		hw->send_error_frame_flag = 0; /*Don't display mark err frames*/
 
 	INIT_KFIFO(hw->display_q);
 	INIT_KFIFO(hw->newframe_q);
@@ -8382,17 +8397,8 @@ static void h264_reset_bufmgr(struct vdec_s *vdec)
 		hw->vfpool[hw->cur_pool][i].index = -1; /* VF_BUF_NUM; */
 
 
-	if (hw->collocate_cma_alloc_addr) {
-		decoder_bmmu_box_free_idx(
-			hw->bmmu_box,
-			BMMU_REF_IDX);
-		hw->collocate_cma_alloc_addr = 0;
-		hw->dpb.colocated_mv_addr_start = 0;
-		hw->dpb.colocated_mv_addr_end = 0;
-	}
 	vf_notify_receiver(vdec->vf_provider_name, VFRAME_EVENT_PROVIDER_RESET, NULL);
 
-	dealloc_buf_specs(hw, 1);
 	buf_spec_init(hw);
 
 	vh264_local_init(hw);

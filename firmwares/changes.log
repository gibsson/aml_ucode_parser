commit 21d9caac4288acf3eb395b22c92ba33857b4d06d
Author: shihong.zheng <shihong.zheng@amlogic.com>
Date:   Fri Jul 26 17:34:29 2019 +0800

    vp9: fix vp9 display abnormal when double write 0x10. [1/1]
    
    PD#SWPL-11767
    
    Problem:
    1. vp9 display abnormal when double write 0x10, function
       get_double_write_mode return 1 before frame valid;
    2. some h264 video can not play in single mode.
    
    Solution:
    1. return valid double write mode when it mask by 0x300;
    2. clear AV_STRATCH_J to end the userdata wait loop.
    
    Verify:
    u212
    
    Change-Id: Ib7ae2c164393bdd1c665cbb1e298ebd38b23b705
    Signed-off-by: shihong.zheng <shihong.zheng@amlogic.com>

diff --git a/drivers/frame_provider/decoder/h264/vh264.c b/drivers/frame_provider/decoder/h264/vh264.c
index f1c5242..a6acc03 100644
--- a/drivers/frame_provider/decoder/h264/vh264.c
+++ b/drivers/frame_provider/decoder/h264/vh264.c
@@ -253,6 +253,14 @@ static u32 bad_block_scale;
 #endif
 static u32 enable_userdata_debug;
 
+/* if not define, must clear AV_SCRATCH_J in isr when
+ * ITU_T35 code enabled in ucode, otherwise may fatal
+ * error repeatly.
+ */
+//#define ENABLE_SEI_ITU_T35
+
+
+
 static unsigned int enable_switch_fense = 1;
 #define EN_SWITCH_FENCE() (enable_switch_fense && !is_4k)
 static struct vframe_qos_s s_vframe_qos;
@@ -2576,9 +2584,8 @@ static void vh264_isr(void)
 	unsigned int  framesize;
 	u64 pts_us64;
 	bool force_interlaced_frame = false;
-#ifdef ENABLE_SEI_ITU_T35
 	unsigned int sei_itu35_flags;
-#endif
+
 	static const unsigned int idr_num =
 		FIX_FRAME_RATE_CHECK_IDRFRAME_NUM;
 	static const unsigned int flg_1080_itl =
@@ -3281,12 +3288,17 @@ static void vh264_isr(void)
 	} else if ((cpu_cmd & 0xff) == 0xB) {
 		schedule_work(&qos_work);
 	}
-#ifdef ENABLE_SEI_ITU_T35
+
 	sei_itu35_flags = READ_VREG(AV_SCRATCH_J);
 	if (sei_itu35_flags & (1 << 15)) {	/* data ready */
+#ifdef ENABLE_SEI_ITU_T35
 		schedule_work(&userdata_push_work);
-	}
+#else
+		/* necessary if enabled itu_t35 in ucode*/
+		WRITE_VREG(AV_SCRATCH_J, 0);
 #endif
+	}
+
 #ifdef HANDLE_H264_IRQ
 	return IRQ_HANDLED;
 #else
diff --git a/drivers/frame_provider/decoder/vp9/vvp9.c b/drivers/frame_provider/decoder/vp9/vvp9.c
index 6228950..b0dd586 100644
--- a/drivers/frame_provider/decoder/vp9/vvp9.c
+++ b/drivers/frame_provider/decoder/vp9/vvp9.c
@@ -1579,31 +1579,35 @@ static int get_double_write_mode(struct VP9Decoder_s *pbi)
 	struct VP9_Common_s *cm = &pbi->common;
 	struct PIC_BUFFER_CONFIG_s *cur_pic_config;
 
-	if (!cm->cur_frame)
-		return 1;/*no valid frame,*/
-	cur_pic_config = &cm->cur_frame->buf;
-	w = cur_pic_config->y_crop_width;
-	h = cur_pic_config->y_crop_height;
-
-	dw = 0x1; /*1:1*/
-	switch (valid_dw_mode) {
-	case 0x100:
-		if (w > 1920 && h > 1088)
-			dw = 0x4; /*1:2*/
-		break;
-	case 0x200:
-		if (w > 1920 && h > 1088)
-			dw = 0x2; /*1:4*/
-		break;
-	case 0x300:
-		if (w > 1280 && h > 720)
-			dw = 0x4; /*1:2*/
-		break;
-	default:
-		dw = valid_dw_mode;
-		break;
+	/* mask for supporting double write value bigger than 0x100 */
+	if (valid_dw_mode & 0xffffff00) {
+		if (!cm->cur_frame)
+			return 1;/*no valid frame,*/
+		cur_pic_config = &cm->cur_frame->buf;
+		w = cur_pic_config->y_crop_width;
+		h = cur_pic_config->y_crop_height;
+
+		dw = 0x1; /*1:1*/
+		switch (valid_dw_mode) {
+		case 0x100:
+			if (w > 1920 && h > 1088)
+				dw = 0x4; /*1:2*/
+			break;
+		case 0x200:
+			if (w > 1920 && h > 1088)
+				dw = 0x2; /*1:4*/
+			break;
+		case 0x300:
+			if (w > 1280 && h > 720)
+				dw = 0x4; /*1:2*/
+			break;
+		default:
+			break;
+		}
+		return dw;
 	}
-	return dw;
+
+	return valid_dw_mode;
 }
 
 /* for double write buf alloc */
@@ -2738,7 +2742,7 @@ int vp9_bufmgr_postproc(struct VP9Decoder_s *pbi)
 	return 0;
 }
 
-struct VP9Decoder_s vp9_decoder;
+/*struct VP9Decoder_s vp9_decoder;*/
 union param_u vp9_param;
 
 /**************************************************
@@ -6283,7 +6287,7 @@ static int vp9_local_init(struct VP9Decoder_s *pbi)
 	/* video is not support unaligned with 64 in tl1
 	** vdec canvas mode will be linear when dump yuv is set
 	*/
-	if ((get_cpu_major_id() >= AM_MESON_CPU_MAJOR_ID_SM1) &&
+	if ((get_cpu_major_id() >= AM_MESON_CPU_MAJOR_ID_G12A) &&
 		(pbi->double_write_mode != 0) &&
 		(((pbi->max_pic_w % 64) != 0) ||
 		(pbi->vvp9_amstream_dec_info.width % 64) != 0)) {
@@ -7173,6 +7177,14 @@ int continue_decoding(struct VP9Decoder_s *pbi)
 	bit_depth_luma = vp9_param.p.bit_depth;
 	bit_depth_chroma = vp9_param.p.bit_depth;
 
+	if ((vp9_param.p.bit_depth >= VPX_BITS_10) &&
+		(get_double_write_mode(pbi) == 0x10)) {
+		pbi->fatal_error |= DECODER_FATAL_ERROR_SIZE_OVERFLOW;
+		pr_err("fatal err, bit_depth %d, unsupport dw 0x10\n",
+			vp9_param.p.bit_depth);
+		return -1;
+	}
+
 	if (pbi->process_state != PROC_STATE_SENDAGAIN) {
 		ret = vp9_bufmgr_process(pbi, &vp9_param);
 		if (!pbi->m_ins_flag)
